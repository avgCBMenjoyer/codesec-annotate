[
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-189",
        "CVE": "CVE-2009-1194",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "pango/glyphstring.c": "pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n\n   while (new_len > string->space)\n     {\n       if (string->space == 0)\n\tstring->space = 1;\n       else\n\tstring->space *= 2;\n      if (string->space < 0)\n \t{\n\t  g_warning (\"glyph string length overflows maximum integer size, truncated\");\n\t  new_len = string->space = G_MAXINT - 8;\n \t}\n     }\n \n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}\n"
        },
        "vulnerabilities": "Integer overflow in the pango_glyph_string_set_size function in pango/glyphstring.c in Pango before 1.24 allows context-dependent attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a long glyph string that triggers a heap-based buffer overflow, as demonstrated by a long document.location value in Firefox.",
        "annotation": "[Mandatory] ID:\nCVE-2009-1194\n\n[Mandatory] Title: CVE-2009-1194 / CWE-189:\nInteger Overflow in Pango Glyph String Function\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2009-05-11 \u2014 Patch release: 2018-10-10\n\n[Optional] Affected products/versions:\nPango before 1.24\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-189: Integer Overflow\n[Mandatory] Summary:\nThe vulnerability exists in the `pango_glyph_string_set_size` function where an integer overflow can occur during memory allocation when resizing glyph strings. This allows an attacker to craft a long glyph string that might trigger a heap-based buffer overflow, potentially leading to a crash of the application or the execution of arbitrary code. This is demonstrated by triggering the flaw with a long document location in Firefox.\n[Mandatory] Root cause:\nFailure to validate the resultant size leading to integer overflow during memory allocation.\n[Mandatory] Attack Surface:\nLibrary function\n[Mandatory] Impact Summary:\nDenial of service \u2192 Arbitrary code execution\n[Optional] Trigger / Attack vector:\nLong glyph string input\n[Mandatory] Key code/struct excerpt (minimal):\n```c\npango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n  \n   while (new_len > string->space)\n     {\n       if (string->space == 0)\n         string->space = 1;\n       else\n         string->space *= 2;\n       if (string->space < 0)\n       {\n          g_warning (\"glyph string length overflows maximum integer size, truncated\");\n          new_len = string->space = G_MAXINT - 8;\n       }\n     }\n  \n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nAPI\n\n[Mandatory] Exploit primitive(s) available:\nHeap-based buffer overflow\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit can be easily triggered by sending specially crafted long glyph strings to the vulnerable function, with minimal mitigations available.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Initialize a PangoGlyphString variable.\n- Call `pango_glyph_string_set_size` with an excessively large `new_len`.\n- The function performs calculations leading to an integer overflow.\n- Observe resulting application crash or arbitrary code execution.\n\n[Mandatory] Exploitation Example script payload code:\n```c\nPangoGlyphString glyphString;\npango_glyph_string_set_size(&glyphString, INT_MAX);\n```\n\nFix\n[Mandatory] Fix code:\n```c\npango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n  \n   while (new_len > string->space)\n     {\n       if (string->space == 0)\n       {\n          string->space = 4;\n       }\n       else\n       {\n          const guint max_space =\n            MIN (G_MAXINT, G_MAXSIZE / MAX (sizeof(PangoGlyphInfo), sizeof(gint)));\n\n          guint more_space = (guint)string->space * 2;\n\n          if (more_space > max_space)\n          {\n            more_space = max_space;\n\n            if ((guint)new_len > max_space)\n            {\n              g_error (\"%s: failed to allocate glyph string of length %i\\n\",\n                       G_STRLOC, new_len);\n            }\n          }\n       }\n     }\n\n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}\n```\n\n[Mandatory] Fix summary:\nThe patch alters the memory allocation logic to include checks for maximum size limits, preventing integer overflow during the resize of the glyph string array.\n\n[Optional] Patch reference:\nhttps://github.com/bratsche/pango/commit/4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e\n\n[Optional] Patch Analysis:\nThe fix implements bounds checking and limits the maximum space to prevent overflow.\n\nField: PatchType (e.g., bounds check added, logic refactor, feature removal)\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review similar memory allocation functions within the library.\n- Test additional string handling cases.\n- Assess other data types that may be impacted by integer overflow.\n\n[Optional] Likely variants/impact (one line):\nPotential for similar vulnerabilities in other string-handling functions.",
        "tests": "NA",
        "solutions": "pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n\n   while (new_len > string->space)\n     {\n       if (string->space == 0)\n\t{\n\t  string->space = 4;\n\t}\n       else\n \t{\n\t  const guint max_space =\n\t    MIN (G_MAXINT, G_MAXSIZE / MAX (sizeof(PangoGlyphInfo), sizeof(gint)));\n\n\t  guint more_space = (guint)string->space * 2;\n\n\t  if (more_space > max_space)\n\t    {\n\t      more_space = max_space;\n\n\t      if ((guint)new_len > max_space)\n\t\t{\n\t\t  g_error (\"%s: failed to allocate glyph string of length %i\\n\",\n\t\t\t   G_STRLOC, new_len);\n\t\t}\n\t    }\n\n\t  string->space = more_space;\n \t}\n     }\n \n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}\n",
        "Publish Date": "2009-05-11",
        "Update Date": "2018-10-10",
        "Vulnerability type": "DoS Exec Code Overflow ",
        "commit_url": "https://github.com/bratsche/pango/commit/4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e",
        "commit_id": "4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e",
        "commit_message": "[glyphstring] Handle overflow with very long glyphstrings",
        "project": "pango"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-20",
        "CVE": "CVE-2010-1152",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "memcached.c": "static int try_read_command(conn *c) {\n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {\n        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n            c->protocol = binary_prot;\n        } else {\n            c->protocol = ascii_prot;\n        }\n\n        if (settings.verbose > 1) {\n            fprintf(stderr, \"%d: Client using the %s protocol\\n\", c->sfd,\n                    prot_text(c->protocol));\n        }\n    }\n\n    if (c->protocol == binary_prot) {\n        /* Do we have the complete packet header? */\n        if (c->rbytes < sizeof(c->binary_header)) {\n            /* need more data! */\n            return 0;\n        } else {\n#ifdef NEED_ALIGN\n            if (((long)(c->rcurr)) % 8 != 0) {\n                /* must realign input buffer */\n                memmove(c->rbuf, c->rcurr, c->rbytes);\n                c->rcurr = c->rbuf;\n                if (settings.verbose > 1) {\n                    fprintf(stderr, \"%d: Realign input buffer\\n\", c->sfd);\n                }\n            }\n#endif\n            protocol_binary_request_header* req;\n            req = (protocol_binary_request_header*)c->rcurr;\n\n            if (settings.verbose > 1) {\n                /* Dump the packet before we convert it to host order */\n                int ii;\n                fprintf(stderr, \"<%d Read binary protocol data:\", c->sfd);\n                for (ii = 0; ii < sizeof(req->bytes); ++ii) {\n                    if (ii % 4 == 0) {\n                        fprintf(stderr, \"\\n<%d   \", c->sfd);\n                    }\n                    fprintf(stderr, \" 0x%02x\", req->bytes[ii]);\n                }\n                fprintf(stderr, \"\\n\");\n            }\n\n            c->binary_header = *req;\n            c->binary_header.request.keylen = ntohs(req->request.keylen);\n            c->binary_header.request.bodylen = ntohl(req->request.bodylen);\n            c->binary_header.request.cas = ntohll(req->request.cas);\n\n            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {\n                if (settings.verbose) {\n                    fprintf(stderr, \"Invalid magic:  %x\\n\",\n                            c->binary_header.request.magic);\n                }\n                conn_set_state(c, conn_closing);\n                return -1;\n            }\n\n            c->msgcurr = 0;\n            c->msgused = 0;\n            c->iovused = 0;\n            if (add_msghdr(c) != 0) {\n                out_string(c, \"SERVER_ERROR out of memory\");\n                return 0;\n            }\n\n            c->cmd = c->binary_header.request.opcode;\n            c->keylen = c->binary_header.request.keylen;\n            c->opaque = c->binary_header.request.opaque;\n            /* clear the returned cas value */\n            c->cas = 0;\n\n            dispatch_bin_command(c);\n\n            c->rbytes -= sizeof(c->binary_header);\n            c->rcurr += sizeof(c->binary_header);\n        }\n    } else {\n        char *el, *cont;\n\n        if (c->rbytes == 0)\n            return 0;\n\n        el = memchr(c->rcurr, '\\n', c->rbytes);\n        if (!el) {\n            if (c->rbytes > 1024) {\n                /*\n                 * We didn't have a '\\n' in the first k. This _has_ to be a\n                 * large multiget, if not we should just nuke the connection.\n                 */\n                char *ptr = c->rcurr;\n                while (*ptr == ' ') { /* ignore leading whitespaces */\n                     ++ptr;\n                 }\n \n                if (strcmp(ptr, \"get \") && strcmp(ptr, \"gets \")) {\n                     conn_set_state(c, conn_closing);\n                     return 1;\n                 }\n            }\n\n            return 0;\n        }\n        cont = el + 1;\n        if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n            el--;\n        }\n        *el = '\\0';\n\n        assert(cont <= (c->rcurr + c->rbytes));\n\n        process_command(c, c->rcurr);\n\n        c->rbytes -= (cont - c->rcurr);\n        c->rcurr = cont;\n\n        assert(c->rcurr <= (c->rbuf + c->rsize));\n    }\n\n    return 1;\n}\n"
        },
        "vulnerabilities": "memcached.c in memcached before 1.4.3 allows remote attackers to cause a denial of service (daemon hang or crash) via a long line that triggers excessive memory allocation.  NOTE: some of these details are obtained from third party information.",
        "annotation": "[Mandatory] ID:\nCVE-2010-1152\n\n[Mandatory] Title: CVE-2010-1152 / CWE-20:\nInput validation error leading to denial of service\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2010-04-12 \u2014 Patch release: 2011-03-01\n\n[Optional] Affected products/versions:\nmemcached before 1.4.3\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-20: Improper Input Validation\n[Mandatory] Summary:\nIn memcached before 1.4.3, a remote attacker can cause a denial of service by sending a long line that triggers excessive memory allocation. The function `try_read_command` does not properly validate the length of incoming data, allowing for potential memory issues. This is shown where it blindly processes commands without sufficient checks for the size of the read buffer.\n[Mandatory] Root cause:\nLack of proper input length validation for commands being processed.\n[Mandatory] Attack Surface:\nNetwork service\n[Mandatory] Impact Summary:\nDenial of Service\n[Optional] Trigger / Attack vector:\nSending crafted requests to the memcached server\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nif (c->rbytes == 0)\n    return 0;\n\nel = memchr(c->rcurr, '\\n', c->rbytes);\nif (!el) {\n    if (c->rbytes > 1024) {\n        /* We didn't have a '\\n' in the first k. This _has_ to be a\n         * large multiget, if not we should just nuke the connection.\n         */\n        char *ptr = c->rcurr;\n        while (*ptr == ' ') { /* ignore leading whitespaces */\n            ++ptr;\n        }\n\n        if (ptr - c->rcurr > 100 ||\n            (strncmp(ptr, \"get \", 4) && strncmp(ptr, \"gets \", 5))) {\n            conn_set_state(c, conn_closing);\n            return 1;\n        }\n    }\n    return 0;\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nNetwork request\n[Mandatory] Exploit primitive(s) available:\nExcessive memory allocation leading to service hang/crash\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit is relatively easy to execute by sending long commands, especially if proper request limits are not enforced.\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Establish a connection to the memcached server.\n- Prepare a long request string that exceeds expected input limits.\n- Send the crafted request to the server.\n- Monitor the server's response or behavior, aiming for a hang or crash.\n- Optionally repeat with varying lengths to identify thresholds.\n\n[Mandatory] Exploitation Example script payload code:\n```python\nimport socket\n\n# Connect to the memcached server\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect(('localhost', 11211))\n\n# Send a long command that triggers the vulnerability\ns.sendall(b'GET ' + b'A' * 2048 + b'\\r\\n')\n\n# Close the connection\ns.close()\n```\n\nFix\n[Mandatory] Fix code:\n```c\nif (ptr - c->rcurr > 100 ||\n    (strncmp(ptr, \"get \", 4) && strncmp(ptr, \"gets \", 5))) {\n    conn_set_state(c, conn_closing);\n    return 1;\n}\n```\n\n[Mandatory] Fix summary:\nThe patch uses `strncmp` to properly handle and limit the size of incoming character buffers when checking for specific commands, preventing excessive long input processing.\n\n[Optional] Patch reference:\nhttps://github.com/memcached/memcached/commit/d9cd01ede97f4145af9781d448c62a3318952719\n\n[Optional] Patch Analysis:\nThe fix added input size checks using `strncmp` to mitigate the risk of handling excessively large input that could lead to denial of service.\n\nField: PatchType (e.g., bounds check added, logic refactor, feature removal)\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review input handling across other command types for similar validation issues.\n- Implement fuzz testing to probe for additional edge cases.\n- Evaluate command length limits across all protocols supported.\n\n[Optional] Likely variants/impact (one line):\nAdditional command types may be susceptible to similar memory allocation flaws if not validated correctly.",
        "tests": "NA",
        "solutions": "static int try_read_command(conn *c) {\n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {\n        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n            c->protocol = binary_prot;\n        } else {\n            c->protocol = ascii_prot;\n        }\n\n        if (settings.verbose > 1) {\n            fprintf(stderr, \"%d: Client using the %s protocol\\n\", c->sfd,\n                    prot_text(c->protocol));\n        }\n    }\n\n    if (c->protocol == binary_prot) {\n        /* Do we have the complete packet header? */\n        if (c->rbytes < sizeof(c->binary_header)) {\n            /* need more data! */\n            return 0;\n        } else {\n#ifdef NEED_ALIGN\n            if (((long)(c->rcurr)) % 8 != 0) {\n                /* must realign input buffer */\n                memmove(c->rbuf, c->rcurr, c->rbytes);\n                c->rcurr = c->rbuf;\n                if (settings.verbose > 1) {\n                    fprintf(stderr, \"%d: Realign input buffer\\n\", c->sfd);\n                }\n            }\n#endif\n            protocol_binary_request_header* req;\n            req = (protocol_binary_request_header*)c->rcurr;\n\n            if (settings.verbose > 1) {\n                /* Dump the packet before we convert it to host order */\n                int ii;\n                fprintf(stderr, \"<%d Read binary protocol data:\", c->sfd);\n                for (ii = 0; ii < sizeof(req->bytes); ++ii) {\n                    if (ii % 4 == 0) {\n                        fprintf(stderr, \"\\n<%d   \", c->sfd);\n                    }\n                    fprintf(stderr, \" 0x%02x\", req->bytes[ii]);\n                }\n                fprintf(stderr, \"\\n\");\n            }\n\n            c->binary_header = *req;\n            c->binary_header.request.keylen = ntohs(req->request.keylen);\n            c->binary_header.request.bodylen = ntohl(req->request.bodylen);\n            c->binary_header.request.cas = ntohll(req->request.cas);\n\n            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {\n                if (settings.verbose) {\n                    fprintf(stderr, \"Invalid magic:  %x\\n\",\n                            c->binary_header.request.magic);\n                }\n                conn_set_state(c, conn_closing);\n                return -1;\n            }\n\n            c->msgcurr = 0;\n            c->msgused = 0;\n            c->iovused = 0;\n            if (add_msghdr(c) != 0) {\n                out_string(c, \"SERVER_ERROR out of memory\");\n                return 0;\n            }\n\n            c->cmd = c->binary_header.request.opcode;\n            c->keylen = c->binary_header.request.keylen;\n            c->opaque = c->binary_header.request.opaque;\n            /* clear the returned cas value */\n            c->cas = 0;\n\n            dispatch_bin_command(c);\n\n            c->rbytes -= sizeof(c->binary_header);\n            c->rcurr += sizeof(c->binary_header);\n        }\n    } else {\n        char *el, *cont;\n\n        if (c->rbytes == 0)\n            return 0;\n\n        el = memchr(c->rcurr, '\\n', c->rbytes);\n        if (!el) {\n            if (c->rbytes > 1024) {\n                /*\n                 * We didn't have a '\\n' in the first k. This _has_ to be a\n                 * large multiget, if not we should just nuke the connection.\n                 */\n                char *ptr = c->rcurr;\n                while (*ptr == ' ') { /* ignore leading whitespaces */\n                     ++ptr;\n                 }\n \n                if (ptr - c->rcurr > 100 ||\n                    (strncmp(ptr, \"get \", 4) && strncmp(ptr, \"gets \", 5))) {\n\n                     conn_set_state(c, conn_closing);\n                     return 1;\n                 }\n            }\n\n            return 0;\n        }\n        cont = el + 1;\n        if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n            el--;\n        }\n        *el = '\\0';\n\n        assert(cont <= (c->rcurr + c->rbytes));\n\n        process_command(c, c->rcurr);\n\n        c->rbytes -= (cont - c->rcurr);\n        c->rcurr = cont;\n\n        assert(c->rcurr <= (c->rbuf + c->rsize));\n    }\n\n    return 1;\n}\n",
        "Publish Date": "2010-04-12",
        "Update Date": "2011-03-01",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/memcached/memcached/commit/d9cd01ede97f4145af9781d448c62a3318952719",
        "commit_id": "d9cd01ede97f4145af9781d448c62a3318952719",
        "commit_message": "Use strncmp when checking for large ascii multigets.",
        "project": "memcached"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-264",
        "CVE": "CVE-2010-0011",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "tests/test-command.c": "test_js (void) {\n    GString *result = g_string_new(\"\");\n\n    /* simple javascript can be evaluated and returned */\n     parse_cmd_line(\"js ('x' + 345).toUpperCase()\", result);\n     g_assert_cmpstr(\"X345\", ==, result->str);\n \n    /* uzbl commands can be run from javascript */\n    uzbl.net.useragent = \"Test useragent\";\n    parse_cmd_line(\"js Uzbl.run('print @useragent').toUpperCase();\", result);\n    g_assert_cmpstr(\"TEST USERAGENT\", ==, result->str);\n     g_string_free(result, TRUE);\n }\n"
        },
        "vulnerabilities": "The eval_js function in uzbl-core.c in Uzbl before 2010.01.05 exposes the run method of the Uzbl object, which allows remote attackers to execute arbitrary commands via JavaScript code.",
        "annotation": "[Mandatory] ID:\nCVE-2010-0011\n\n[Mandatory] Title: CVE-2010-0011 / CWE-264:\nCode execution through JavaScript injection\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2010-02-25 \u2014 Patch release: 2017-08-16\n\n[Optional] Affected products/versions:\nUzbl before 2010.01.05\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-264: Permissions, Privileges, and Access Control\n\n[Mandatory] Summary:\nThe eval_js function in uzbl-core.c exposes the run method of the Uzbl object, allowing remote attackers to execute arbitrary commands through injected JavaScript code. This vulnerability is triggered when the parse_cmd_line function processes user-supplied JavaScript, enabling the execution of potentially harmful commands. Key code demonstrating the vulnerability is indicated in the provided test function.\n\n[Mandatory] Root cause:\nInsufficient validation of user input in JavaScript execution.\n\n[Mandatory] Attack Surface:\nWeb application using JavaScript execution capabilities\n\n[Mandatory] Impact Summary:\nRemote Code Execution (RCE)\n\n[Optional] Trigger / Attack vector:\nJavaScript commands via user input\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\ntest_js (void) {\n    GString *result = g_string_new(\"\");\n    parse_cmd_line(\"js Uzbl.run('print @useragent').toUpperCase();\", result);\n    g_assert_cmpstr(\"TEST USERAGENT\", ==, result->str);\n    g_string_free(result, TRUE);\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nJavaScript execution via API\n\n[Mandatory] Exploit primitive(s) available:\narbitrary command execution\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit is straightforward as it relies on user-defined JavaScript input without adequate sanitization.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create a malicious JavaScript command.\n- Execute the command using the `parse_cmd_line` API.\n- Observe the arbitrary command execution's impact.\n\n[Mandatory] Exploitation Example script payload code:\n```c\nparse_cmd_line(\"js Uzbl.run('malicious_command');\", result);\n```\n\nFix\n[Mandatory] Fix code:\n```c\ntest_js (void) {\n    GString *result = g_string_new(\"\");\n    parse_cmd_line(\"js ('x' + 345).toUpperCase()\", result);\n    g_string_free(result, TRUE);\n}\n```\n\n[Mandatory] Fix summary:\nThe patch modified the JavaScript execution to remove the exposure of the Uzbl object, thus preventing arbitrary command execution.\n\n[Optional] Patch reference:\nhttps://github.com/Dieterbe/uzbl/commit/1958b52d41cba96956dc1995660de49525ed1047\n\n[Optional] Patch Analysis:\nWhat did the fix do?\n\nField: PatchType (e.g., bounds check added, logic refactor, feature removal)\nFeature removal for security hardening.",
        "tests": "NA",
        "solutions": "test_js (void) {\n    GString *result = g_string_new(\"\");\n\n    /* simple javascript can be evaluated and returned */\n     parse_cmd_line(\"js ('x' + 345).toUpperCase()\", result);\n     g_assert_cmpstr(\"X345\", ==, result->str);\n \n     g_string_free(result, TRUE);\n }\n",
        "Publish Date": "2010-02-25",
        "Update Date": "2017-08-16",
        "Vulnerability type": "Exec Code ",
        "commit_url": "https://github.com/Dieterbe/uzbl/commit/1958b52d41cba96956dc1995660de49525ed1047",
        "commit_id": "1958b52d41cba96956dc1995660de49525ed1047",
        "commit_message": "disable Uzbl javascript object because of security problem.",
        "project": "uzbl"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-264",
        "CVE": "CVE-2010-0011",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "uzbl-core.c": "eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n     WebKitWebFrame *frame;\n     JSGlobalContextRef context;\n     JSObjectRef globalobject;\n    JSStringRef var_name;\n \n     JSStringRef js_script;\n     JSValueRef js_result;\n    JSStringRef js_result_string;\n    size_t js_result_size;\n\n    js_init();\n\n    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));\n     context = webkit_web_frame_get_global_context(frame);\n     globalobject = JSContextGetGlobalObject(context);\n \n    /* uzbl javascript namespace */\n    var_name = JSStringCreateWithUTF8CString(\"Uzbl\");\n    JSObjectSetProperty(context, globalobject, var_name,\n                        JSObjectMake(context, uzbl.js.classref, NULL),\n                        kJSClassAttributeNone, NULL);\n     /* evaluate the script and get return value*/\n     js_script = JSStringCreateWithUTF8CString(script);\n     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);\n    if (js_result && !JSValueIsUndefined(context, js_result)) {\n        js_result_string = JSValueToStringCopy(context, js_result, NULL);\n        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);\n\n        if (js_result_size) {\n            char js_result_utf8[js_result_size];\n            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);\n            g_string_assign(result, js_result_utf8);\n        }\n\n        JSStringRelease(js_result_string);\n     }\n \n     /* cleanup */\n    JSObjectDeleteProperty(context, globalobject, var_name, NULL);\n    JSStringRelease(var_name);\n     JSStringRelease(js_script);\n }\n"
        },
        "vulnerabilities": "The eval_js function in uzbl-core.c in Uzbl before 2010.01.05 exposes the run method of the Uzbl object, which allows remote attackers to execute arbitrary commands via JavaScript code.",
        "annotation": "[Mandatory] ID:\nCVE-2010-0011\n\n[Mandatory] Title: CVE-2010-0011 / CWE-264:\nImproper Access Control in Uzbl\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2010-02-25 \u2014 Patch release: 2017-08-16\n\n[Optional] Affected products/versions:\nUzbl before 2010.01.05\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-264: Permissions, Privileges, and Access Control\n\n[Mandatory] Summary:\nThe eval_js function in uzbl-core.c in Uzbl exposes the run method of the Uzbl object, allowing remote attackers to execute arbitrary commands via JavaScript code. The flaw occurs due to the absence of proper access control, enabling exploitation of the functionality provided by eval_js when unsanitized input is processed from JavaScript.\n\n[Mandatory] Root cause:\nImproper access control in the evaluation of JavaScript within the application.\n\n[Mandatory] Attack Surface:\nWeb application interface\n\n[Mandatory] Impact Summary:\nRemote code execution via JavaScript\n\n[Optional] Trigger / Attack vector:\nJavaScript code injection\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\neval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n    /* evaluate the script and get return value*/\n    js_script = JSStringCreateWithUTF8CString(script);\n    js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);\n    ...\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nJavaScript execution in web context\n\n[Mandatory] Exploit primitive(s) available:\nRemote code execution via script injection\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit is straightforward for attackers familiar with JavaScript, posing significant risks without effective mitigations.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create a malicious JavaScript snippet.\n- Load this snippet in the context of the Uzbl browser.\n- Use the eval_js function to execute arbitrary commands.\n- Achieve execution of attacker-controlled code.\n\n[Mandatory] Exploitation Example script payload code:\n```javascript\n// Malicious JavaScript code to exploit the vulnerability\nvar xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"http://vulnerable-site.com/malicious\", true);\nxhr.send();\n```\n\nFix\n[Mandatory] Fix code:\n```c\neval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n    /* evaluate the script and get return value*/\n    js_script = JSStringCreateWithUTF8CString(script);\n    js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);\n    ...\n    /* cleanup */\n    JSStringRelease(js_script);\n}\n```\n\n[Mandatory] Fix summary:\nThe patch disables the Uzbl JavaScript object to mitigate the security problem and prevents arbitrary command execution through the eval_js function.\n\n[Optional] Patch reference:\nhttps://github.com/Dieterbe/uzbl/commit/1958b52d41cba96956dc1995660de49525ed1047\n\n[Optional] Patch Analysis:\nShort note: \u201cWhat did the fix do?\u201d\nField: PatchType (e.g., logic refactor, feature removal)\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other functions that evaluate JavaScript.\n- Test for similar vulnerabilities in related components.\n- Analyze potential injection points across the application.\n\n[Optional] Likely variants/impact (one line):\nRemote execution weaknesses present in related functionalities.",
        "tests": "NA",
        "solutions": "eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n     WebKitWebFrame *frame;\n     JSGlobalContextRef context;\n     JSObjectRef globalobject;\n \n     JSStringRef js_script;\n     JSValueRef js_result;\n    JSStringRef js_result_string;\n    size_t js_result_size;\n\n    js_init();\n\n    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));\n     context = webkit_web_frame_get_global_context(frame);\n     globalobject = JSContextGetGlobalObject(context);\n \n     /* evaluate the script and get return value*/\n     js_script = JSStringCreateWithUTF8CString(script);\n     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);\n    if (js_result && !JSValueIsUndefined(context, js_result)) {\n        js_result_string = JSValueToStringCopy(context, js_result, NULL);\n        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);\n\n        if (js_result_size) {\n            char js_result_utf8[js_result_size];\n            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);\n            g_string_assign(result, js_result_utf8);\n        }\n\n        JSStringRelease(js_result_string);\n     }\n \n     /* cleanup */\n     JSStringRelease(js_script);\n }\n",
        "Publish Date": "2010-02-25",
        "Update Date": "2017-08-16",
        "Vulnerability type": "Exec Code ",
        "commit_url": "https://github.com/Dieterbe/uzbl/commit/1958b52d41cba96956dc1995660de49525ed1047",
        "commit_id": "1958b52d41cba96956dc1995660de49525ed1047",
        "commit_message": "disable Uzbl javascript object because of security problem.",
        "project": "uzbl"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-399",
        "CVE": "CVE-2011-2161",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "libavformat/ape.c": "static int ape_read_header(AVFormatContext * s, AVFormatParameters * ap)\n{\n    AVIOContext *pb = s->pb;\n    APEContext *ape = s->priv_data;\n    AVStream *st;\n    uint32_t tag;\n    int i;\n    int total_blocks;\n    int64_t pts;\n\n    /* TODO: Skip any leading junk such as id3v2 tags */\n    ape->junklength = 0;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('M', 'A', 'C', ' '))\n        return -1;\n\n    ape->fileversion = avio_rl16(pb);\n\n    if (ape->fileversion < APE_MIN_VERSION || ape->fileversion > APE_MAX_VERSION) {\n        av_log(s, AV_LOG_ERROR, \"Unsupported file version - %d.%02d\\n\", ape->fileversion / 1000, (ape->fileversion % 1000) / 10);\n        return -1;\n    }\n\n    if (ape->fileversion >= 3980) {\n        ape->padding1             = avio_rl16(pb);\n        ape->descriptorlength     = avio_rl32(pb);\n        ape->headerlength         = avio_rl32(pb);\n        ape->seektablelength      = avio_rl32(pb);\n        ape->wavheaderlength      = avio_rl32(pb);\n        ape->audiodatalength      = avio_rl32(pb);\n        ape->audiodatalength_high = avio_rl32(pb);\n        ape->wavtaillength        = avio_rl32(pb);\n        avio_read(pb, ape->md5, 16);\n\n        /* Skip any unknown bytes at the end of the descriptor.\n           This is for future compatibility */\n        if (ape->descriptorlength > 52)\n            avio_seek(pb, ape->descriptorlength - 52, SEEK_CUR);\n\n        /* Read header data */\n        ape->compressiontype      = avio_rl16(pb);\n        ape->formatflags          = avio_rl16(pb);\n        ape->blocksperframe       = avio_rl32(pb);\n        ape->finalframeblocks     = avio_rl32(pb);\n        ape->totalframes          = avio_rl32(pb);\n        ape->bps                  = avio_rl16(pb);\n        ape->channels             = avio_rl16(pb);\n        ape->samplerate           = avio_rl32(pb);\n    } else {\n        ape->descriptorlength = 0;\n        ape->headerlength = 32;\n\n        ape->compressiontype      = avio_rl16(pb);\n        ape->formatflags          = avio_rl16(pb);\n        ape->channels             = avio_rl16(pb);\n        ape->samplerate           = avio_rl32(pb);\n        ape->wavheaderlength      = avio_rl32(pb);\n        ape->wavtaillength        = avio_rl32(pb);\n        ape->totalframes          = avio_rl32(pb);\n        ape->finalframeblocks     = avio_rl32(pb);\n\n        if (ape->formatflags & MAC_FORMAT_FLAG_HAS_PEAK_LEVEL) {\n            avio_seek(pb, 4, SEEK_CUR); /* Skip the peak level */\n            ape->headerlength += 4;\n        }\n\n        if (ape->formatflags & MAC_FORMAT_FLAG_HAS_SEEK_ELEMENTS) {\n            ape->seektablelength = avio_rl32(pb);\n            ape->headerlength += 4;\n            ape->seektablelength *= sizeof(int32_t);\n        } else\n            ape->seektablelength = ape->totalframes * sizeof(int32_t);\n\n        if (ape->formatflags & MAC_FORMAT_FLAG_8_BIT)\n            ape->bps = 8;\n        else if (ape->formatflags & MAC_FORMAT_FLAG_24_BIT)\n            ape->bps = 24;\n        else\n            ape->bps = 16;\n\n        if (ape->fileversion >= 3950)\n            ape->blocksperframe = 73728 * 4;\n        else if (ape->fileversion >= 3900 || (ape->fileversion >= 3800  && ape->compressiontype >= 4000))\n            ape->blocksperframe = 73728;\n        else\n            ape->blocksperframe = 9216;\n\n        /* Skip any stored wav header */\n        if (!(ape->formatflags & MAC_FORMAT_FLAG_CREATE_WAV_HEADER))\n             avio_seek(pb, ape->wavheaderlength, SEEK_CUR);\n     }\n \n     if(ape->totalframes > UINT_MAX / sizeof(APEFrame)){\n         av_log(s, AV_LOG_ERROR, \"Too many frames: %d\\n\", ape->totalframes);\n         return -1;\n    }\n    ape->frames       = av_malloc(ape->totalframes * sizeof(APEFrame));\n    if(!ape->frames)\n        return AVERROR(ENOMEM);\n    ape->firstframe   = ape->junklength + ape->descriptorlength + ape->headerlength + ape->seektablelength + ape->wavheaderlength;\n    ape->currentframe = 0;\n\n\n    ape->totalsamples = ape->finalframeblocks;\n    if (ape->totalframes > 1)\n        ape->totalsamples += ape->blocksperframe * (ape->totalframes - 1);\n\n    if (ape->seektablelength > 0) {\n        ape->seektable = av_malloc(ape->seektablelength);\n        for (i = 0; i < ape->seektablelength / sizeof(uint32_t); i++)\n            ape->seektable[i] = avio_rl32(pb);\n    }\n\n    ape->frames[0].pos     = ape->firstframe;\n    ape->frames[0].nblocks = ape->blocksperframe;\n    ape->frames[0].skip    = 0;\n    for (i = 1; i < ape->totalframes; i++) {\n        ape->frames[i].pos      = ape->seektable[i]; //ape->frames[i-1].pos + ape->blocksperframe;\n        ape->frames[i].nblocks  = ape->blocksperframe;\n        ape->frames[i - 1].size = ape->frames[i].pos - ape->frames[i - 1].pos;\n        ape->frames[i].skip     = (ape->frames[i].pos - ape->frames[0].pos) & 3;\n    }\n    ape->frames[ape->totalframes - 1].size    = ape->finalframeblocks * 4;\n    ape->frames[ape->totalframes - 1].nblocks = ape->finalframeblocks;\n\n    for (i = 0; i < ape->totalframes; i++) {\n        if(ape->frames[i].skip){\n            ape->frames[i].pos  -= ape->frames[i].skip;\n            ape->frames[i].size += ape->frames[i].skip;\n        }\n        ape->frames[i].size = (ape->frames[i].size + 3) & ~3;\n    }\n\n\n    ape_dumpinfo(s, ape);\n\n    /* try to read APE tags */\n    if (!url_is_streamed(pb)) {\n        ff_ape_parse_tag(s);\n        avio_seek(pb, 0, SEEK_SET);\n    }\n\n    av_log(s, AV_LOG_DEBUG, \"Decoding file - v%d.%02d, compression level %d\\n\", ape->fileversion / 1000, (ape->fileversion % 1000) / 10, ape->compressiontype);\n\n    /* now we are ready: build format streams */\n    st = av_new_stream(s, 0);\n    if (!st)\n        return -1;\n\n    total_blocks = (ape->totalframes == 0) ? 0 : ((ape->totalframes - 1) * ape->blocksperframe) + ape->finalframeblocks;\n\n    st->codec->codec_type      = AVMEDIA_TYPE_AUDIO;\n    st->codec->codec_id        = CODEC_ID_APE;\n    st->codec->codec_tag       = MKTAG('A', 'P', 'E', ' ');\n    st->codec->channels        = ape->channels;\n    st->codec->sample_rate     = ape->samplerate;\n    st->codec->bits_per_coded_sample = ape->bps;\n    st->codec->frame_size      = MAC_SUBFRAME_SIZE;\n\n    st->nb_frames = ape->totalframes;\n    st->start_time = 0;\n    st->duration  = total_blocks / MAC_SUBFRAME_SIZE;\n    av_set_pts_info(st, 64, MAC_SUBFRAME_SIZE, ape->samplerate);\n\n    st->codec->extradata = av_malloc(APE_EXTRADATA_SIZE);\n    st->codec->extradata_size = APE_EXTRADATA_SIZE;\n    AV_WL16(st->codec->extradata + 0, ape->fileversion);\n    AV_WL16(st->codec->extradata + 2, ape->compressiontype);\n    AV_WL16(st->codec->extradata + 4, ape->formatflags);\n\n    pts = 0;\n    for (i = 0; i < ape->totalframes; i++) {\n        ape->frames[i].pts = pts;\n        av_add_index_entry(st, ape->frames[i].pos, ape->frames[i].pts, 0, 0, AVINDEX_KEYFRAME);\n        pts += ape->blocksperframe / MAC_SUBFRAME_SIZE;\n    }\n\n    return 0;\n}\n"
        },
        "vulnerabilities": "The ape_read_header function in ape.c in libavformat in FFmpeg before 0.5.4, as used in MPlayer, VideoLAN VLC media player, and other products, allows remote attackers to cause a denial of service (application crash) via an APE (aka Monkey's Audio) file that contains a header but no frames.",
        "annotation": "[Mandatory] ID:\nCVE-2011-2161\n\n[Mandatory] Title: CVE-2011-2161 / CWE-399:\nDenial of Service in APE header processing\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2011-05-20 \u2014 Patch release: 2018-10-17\n\n[Optional] Affected products/versions:\nFFmpeg before 0.5.4, MPlayer, VideoLAN VLC media player\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-399: Resource Management Errors\n[Mandatory] Summary:\nThe `ape_read_header` function in `ape.c` allows attackers to cause a denial of service (application crash) via a specially crafted APE file that contains a header but no frames. The flaw arises from insufficient checks on the total number of frames leading to potential invalid memory access, as revealed in the code excerpt dealing with frame reads.\n[Mandatory] Root cause:\nInsufficient validation of the `totalframes` variable before memory allocations and processing.\n[Mandatory] Attack Surface:\nMedia file processing\n[Mandatory] Impact Summary:\nDenial of Service (application crash)\n[Optional] Trigger / Attack vector:\nMalformed APE file\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nif(!ape->totalframes){\n    av_log(s, AV_LOG_ERROR, \"No frames in the file!\\n\");\n    return AVERROR(EINVAL);\n}\nape->frames = av_malloc(ape->totalframes * sizeof(APEFrame));\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nFile format\n\n[Mandatory] Exploit primitive(s) available:\nInvalid memory access\n\n[Mandatory] Exploitability summary (1 sentence):\nExploiting this vulnerability is straightforward with a specially crafted APE file that contains a header but no actual audio frames.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create an APE file with a valid header\n- Set the frame count to zero\n- Attempt to process the APE file with the vulnerable function\n- Observe the application crash due to invalid memory access\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\nint main() {\n    // Crafting an APE file with a header but no frames\n    FILE *file = fopen(\"malicious.ape\", \"wb\");\n    // Write valid header data\n    fwrite(\"MAC \", 4, 1, file);\n    // Write a header indicating zero frames\n    fwrite(\"\\x00\\x00\\x00\\x00\", 4, 1, file);\n    fclose(file);\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nif(!ape->totalframes){\n    av_log(s, AV_LOG_ERROR, \"No frames in the file!\\n\");\n    return AVERROR(EINVAL);\n}\n```\n\n[Mandatory] Fix summary:\nThe patch added a check for zero frames in the APE file, preventing invalid reads/writes before processing the frames.\n\n[Optional] Patch reference:\nhttps://github.com/FFmpeg/FFmpeg/commit/8312e3fc9041027a33c8bc667bb99740fdf41dd5\n\n[Optional] Patch Analysis:\nThe fix added a validation step to ensure the total frames are greater than zero before proceeding with memory allocation and processing.\n\nField: PatchType (e.g., bounds check added, logic refactor, feature removal)\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other file format parsers for similar validation issues\n- Conduct fuzz testing on media files to identify further vulnerabilities\n- Assess the error handling strategies in related file-reading functions\n\n[Optional] Likely variants/impact (one line):\nPotential for similar issues in other media processing functions not validating frame counts correctly.",
        "tests": "NA",
        "solutions": "static int ape_read_header(AVFormatContext * s, AVFormatParameters * ap)\n{\n    AVIOContext *pb = s->pb;\n    APEContext *ape = s->priv_data;\n    AVStream *st;\n    uint32_t tag;\n    int i;\n    int total_blocks;\n    int64_t pts;\n\n    /* TODO: Skip any leading junk such as id3v2 tags */\n    ape->junklength = 0;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('M', 'A', 'C', ' '))\n        return -1;\n\n    ape->fileversion = avio_rl16(pb);\n\n    if (ape->fileversion < APE_MIN_VERSION || ape->fileversion > APE_MAX_VERSION) {\n        av_log(s, AV_LOG_ERROR, \"Unsupported file version - %d.%02d\\n\", ape->fileversion / 1000, (ape->fileversion % 1000) / 10);\n        return -1;\n    }\n\n    if (ape->fileversion >= 3980) {\n        ape->padding1             = avio_rl16(pb);\n        ape->descriptorlength     = avio_rl32(pb);\n        ape->headerlength         = avio_rl32(pb);\n        ape->seektablelength      = avio_rl32(pb);\n        ape->wavheaderlength      = avio_rl32(pb);\n        ape->audiodatalength      = avio_rl32(pb);\n        ape->audiodatalength_high = avio_rl32(pb);\n        ape->wavtaillength        = avio_rl32(pb);\n        avio_read(pb, ape->md5, 16);\n\n        /* Skip any unknown bytes at the end of the descriptor.\n           This is for future compatibility */\n        if (ape->descriptorlength > 52)\n            avio_seek(pb, ape->descriptorlength - 52, SEEK_CUR);\n\n        /* Read header data */\n        ape->compressiontype      = avio_rl16(pb);\n        ape->formatflags          = avio_rl16(pb);\n        ape->blocksperframe       = avio_rl32(pb);\n        ape->finalframeblocks     = avio_rl32(pb);\n        ape->totalframes          = avio_rl32(pb);\n        ape->bps                  = avio_rl16(pb);\n        ape->channels             = avio_rl16(pb);\n        ape->samplerate           = avio_rl32(pb);\n    } else {\n        ape->descriptorlength = 0;\n        ape->headerlength = 32;\n\n        ape->compressiontype      = avio_rl16(pb);\n        ape->formatflags          = avio_rl16(pb);\n        ape->channels             = avio_rl16(pb);\n        ape->samplerate           = avio_rl32(pb);\n        ape->wavheaderlength      = avio_rl32(pb);\n        ape->wavtaillength        = avio_rl32(pb);\n        ape->totalframes          = avio_rl32(pb);\n        ape->finalframeblocks     = avio_rl32(pb);\n\n        if (ape->formatflags & MAC_FORMAT_FLAG_HAS_PEAK_LEVEL) {\n            avio_seek(pb, 4, SEEK_CUR); /* Skip the peak level */\n            ape->headerlength += 4;\n        }\n\n        if (ape->formatflags & MAC_FORMAT_FLAG_HAS_SEEK_ELEMENTS) {\n            ape->seektablelength = avio_rl32(pb);\n            ape->headerlength += 4;\n            ape->seektablelength *= sizeof(int32_t);\n        } else\n            ape->seektablelength = ape->totalframes * sizeof(int32_t);\n\n        if (ape->formatflags & MAC_FORMAT_FLAG_8_BIT)\n            ape->bps = 8;\n        else if (ape->formatflags & MAC_FORMAT_FLAG_24_BIT)\n            ape->bps = 24;\n        else\n            ape->bps = 16;\n\n        if (ape->fileversion >= 3950)\n            ape->blocksperframe = 73728 * 4;\n        else if (ape->fileversion >= 3900 || (ape->fileversion >= 3800  && ape->compressiontype >= 4000))\n            ape->blocksperframe = 73728;\n        else\n            ape->blocksperframe = 9216;\n\n        /* Skip any stored wav header */\n        if (!(ape->formatflags & MAC_FORMAT_FLAG_CREATE_WAV_HEADER))\n             avio_seek(pb, ape->wavheaderlength, SEEK_CUR);\n     }\n \n    if(!ape->totalframes){\n        av_log(s, AV_LOG_ERROR, \"No frames in the file!\\n\");\n        return AVERROR(EINVAL);\n    }\n     if(ape->totalframes > UINT_MAX / sizeof(APEFrame)){\n         av_log(s, AV_LOG_ERROR, \"Too many frames: %d\\n\", ape->totalframes);\n         return -1;\n    }\n    ape->frames       = av_malloc(ape->totalframes * sizeof(APEFrame));\n    if(!ape->frames)\n        return AVERROR(ENOMEM);\n    ape->firstframe   = ape->junklength + ape->descriptorlength + ape->headerlength + ape->seektablelength + ape->wavheaderlength;\n    ape->currentframe = 0;\n\n\n    ape->totalsamples = ape->finalframeblocks;\n    if (ape->totalframes > 1)\n        ape->totalsamples += ape->blocksperframe * (ape->totalframes - 1);\n\n    if (ape->seektablelength > 0) {\n        ape->seektable = av_malloc(ape->seektablelength);\n        for (i = 0; i < ape->seektablelength / sizeof(uint32_t); i++)\n            ape->seektable[i] = avio_rl32(pb);\n    }\n\n    ape->frames[0].pos     = ape->firstframe;\n    ape->frames[0].nblocks = ape->blocksperframe;\n    ape->frames[0].skip    = 0;\n    for (i = 1; i < ape->totalframes; i++) {\n        ape->frames[i].pos      = ape->seektable[i]; //ape->frames[i-1].pos + ape->blocksperframe;\n        ape->frames[i].nblocks  = ape->blocksperframe;\n        ape->frames[i - 1].size = ape->frames[i].pos - ape->frames[i - 1].pos;\n        ape->frames[i].skip     = (ape->frames[i].pos - ape->frames[0].pos) & 3;\n    }\n    ape->frames[ape->totalframes - 1].size    = ape->finalframeblocks * 4;\n    ape->frames[ape->totalframes - 1].nblocks = ape->finalframeblocks;\n\n    for (i = 0; i < ape->totalframes; i++) {\n        if(ape->frames[i].skip){\n            ape->frames[i].pos  -= ape->frames[i].skip;\n            ape->frames[i].size += ape->frames[i].skip;\n        }\n        ape->frames[i].size = (ape->frames[i].size + 3) & ~3;\n    }\n\n\n    ape_dumpinfo(s, ape);\n\n    /* try to read APE tags */\n    if (!url_is_streamed(pb)) {\n        ff_ape_parse_tag(s);\n        avio_seek(pb, 0, SEEK_SET);\n    }\n\n    av_log(s, AV_LOG_DEBUG, \"Decoding file - v%d.%02d, compression level %d\\n\", ape->fileversion / 1000, (ape->fileversion % 1000) / 10, ape->compressiontype);\n\n    /* now we are ready: build format streams */\n    st = av_new_stream(s, 0);\n    if (!st)\n        return -1;\n\n    total_blocks = (ape->totalframes == 0) ? 0 : ((ape->totalframes - 1) * ape->blocksperframe) + ape->finalframeblocks;\n\n    st->codec->codec_type      = AVMEDIA_TYPE_AUDIO;\n    st->codec->codec_id        = CODEC_ID_APE;\n    st->codec->codec_tag       = MKTAG('A', 'P', 'E', ' ');\n    st->codec->channels        = ape->channels;\n    st->codec->sample_rate     = ape->samplerate;\n    st->codec->bits_per_coded_sample = ape->bps;\n    st->codec->frame_size      = MAC_SUBFRAME_SIZE;\n\n    st->nb_frames = ape->totalframes;\n    st->start_time = 0;\n    st->duration  = total_blocks / MAC_SUBFRAME_SIZE;\n    av_set_pts_info(st, 64, MAC_SUBFRAME_SIZE, ape->samplerate);\n\n    st->codec->extradata = av_malloc(APE_EXTRADATA_SIZE);\n    st->codec->extradata_size = APE_EXTRADATA_SIZE;\n    AV_WL16(st->codec->extradata + 0, ape->fileversion);\n    AV_WL16(st->codec->extradata + 2, ape->compressiontype);\n    AV_WL16(st->codec->extradata + 4, ape->formatflags);\n\n    pts = 0;\n    for (i = 0; i < ape->totalframes; i++) {\n        ape->frames[i].pts = pts;\n        av_add_index_entry(st, ape->frames[i].pos, ape->frames[i].pts, 0, 0, AVINDEX_KEYFRAME);\n        pts += ape->blocksperframe / MAC_SUBFRAME_SIZE;\n    }\n\n    return 0;\n}\n",
        "Publish Date": "2011-05-20",
        "Update Date": "2018-10-17",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/8312e3fc9041027a33c8bc667bb99740fdf41dd5",
        "commit_id": "8312e3fc9041027a33c8bc667bb99740fdf41dd5",
        "commit_message": "Do not attempt to decode APE file with no frames\n\nThis fixes invalid reads/writes with this sample:\nhttp://packetstorm.linuxsecurity.com/1103-exploits/vlc105-dos.txt",
        "project": "FFmpeg"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-119",
        "CVE": "CVE-2011-0530",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "nbd-server.c": "int mainloop(CLIENT *client) {\n\tstruct nbd_request request;\n\tstruct nbd_reply reply;\n\tgboolean go_on=TRUE;\n#ifdef DODBG\n\tint i = 0;\n#endif\n\tnegotiate(client->net, client, NULL);\n\tDEBUG(\"Entering request loop!\\n\");\n\treply.magic = htonl(NBD_REPLY_MAGIC);\n\treply.error = 0;\n\twhile (go_on) {\n\t\tchar buf[BUFSIZE];\n\t\tsize_t len;\n#ifdef DODBG\n\t\ti++;\n\t\tprintf(\"%d: \", i);\n#endif\n\t\treadit(client->net, &request, sizeof(request));\n\t\trequest.from = ntohll(request.from);\n\t\trequest.type = ntohl(request.type);\n\n\t\tif (request.type==NBD_CMD_DISC) {\n\t\t\tmsg2(LOG_INFO, \"Disconnect request received.\");\n                \tif (client->server->flags & F_COPYONWRITE) { \n\t\t\t\tif (client->difmap) g_free(client->difmap) ;\n                \t\tclose(client->difffile);\n\t\t\t\tunlink(client->difffilename);\n\t\t\t\tfree(client->difffilename);\n\t\t\t}\n\t\t\tgo_on=FALSE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = ntohl(request.len);\n \n \t\tif (request.magic != htonl(NBD_REQUEST_MAGIC))\n \t\t\terr(\"Not enough magic.\");\n\t\tif (len > BUFSIZE + sizeof(struct nbd_reply))\n \t\t\terr(\"Request too big!\");\n #ifdef DODBG\n \t\tprintf(\"%s from %llu (%llu) len %d, \", request.type ? \"WRITE\" :\n\t\t\t\t\"READ\", (unsigned long long)request.from,\n\t\t\t\t(unsigned long long)request.from / 512, len);\n#endif\n\t\tmemcpy(reply.handle, request.handle, sizeof(reply.handle));\n\t\tif ((request.from + len) > (OFFT_MAX)) {\n\t\t\tDEBUG(\"[Number too large!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (((ssize_t)((off_t)request.from + len) > client->exportsize)) {\n\t\t\tDEBUG(\"[RANGE!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (request.type==NBD_CMD_WRITE) {\n\t\t\tDEBUG(\"wr: net->buf, \");\n\t\t\treadit(client->net, buf, len);\n\t\t\tDEBUG(\"buf->exp, \");\n\t\t\tif ((client->server->flags & F_READONLY) ||\n\t\t\t    (client->server->flags & F_AUTOREADONLY)) {\n\t\t\t\tDEBUG(\"[WRITE to READONLY!]\");\n\t\t\t\tERROR(client, reply, EPERM);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (expwrite(request.from, buf, len, client)) {\n\t\t\t\tDEBUG(\"Write failed: %m\" );\n\t\t\t\tERROR(client, reply, errno);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSEND(client->net, reply);\n\t\t\tDEBUG(\"OK!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* READ */\n\n\t\tDEBUG(\"exp->buf, \");\n\t\tif (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {\n\t\t\tDEBUG(\"Read failed: %m\");\n\t\t\tERROR(client, reply, errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDEBUG(\"buf->net, \");\n\t\tmemcpy(buf, &reply, sizeof(struct nbd_reply));\n\t\twriteit(client->net, buf, len + sizeof(struct nbd_reply));\n\t\tDEBUG(\"OK!\\n\");\n\t}\n\treturn 0;\n}\n"
        },
        "vulnerabilities": "Buffer overflow in the mainloop function in nbd-server.c in the server in Network Block Device (nbd) before 2.9.20 might allow remote attackers to execute arbitrary code via a long request.  NOTE: this issue exists because of a CVE-2005-3534 regression.",
        "annotation": "[Mandatory] ID:\nCVE-2011-0530\n\n[Mandatory] Title: CVE-2011-0530 / CWE-119:\nBuffer overflow in mainloop function\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2011-02-22 \u2014 Patch release: 2017-08-16\n\n[Optional] Affected products/versions:\nNetwork Block Device (nbd) before 2.9.20\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n[Mandatory] Summary:\nThe code in the mainloop function of nbd-server.c contains a buffer overflow vulnerability that allows remote attackers to execute arbitrary code via a long request message. This vulnerability is triggered when the length of the request exceeds the buffer size, leading to memory corruption. The flaw is evident where the length check for the incoming request is insufficient when handling the request type.\n[Mandatory] Root cause:\nUnchecked length of request leads to buffer overflow in `memcpy`.\n[Mandatory] Attack Surface:\nNetwork service\n[Mandatory] Impact Summary:\nRemote code execution\n[Optional] Trigger / Attack vector:\nLong request message\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nif (len > BUFSIZE + sizeof(struct nbd_reply))\n    err(\"Request too big!\");\nmemcpy(reply.handle, request.handle, sizeof(reply.handle));\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nNetwork protocol request\n\n[Mandatory] Exploit primitive(s) available:\nBuffer overflow leading to code execution\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit is likely easy to execute as it only requires a specially crafted request, with limited checks in place.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Establish a connection to the nbd server.\n- Send a request with a length exceeding the buffer size.\n- Trigger the buffer overflow in the mainloop function.\n- Control execution flow by manipulating the overflow data.\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define TARGET_SERVER \"127.0.0.1\"\n#define PORT 10809\n#define BUFFER_SIZE 1024\n\nint main() {\n    // Buffer overflow payload\n    char overflow[BUFFER_SIZE + 1];\n    memset(overflow, 'A', sizeof(overflow));\n    overflow[BUFFER_SIZE] = '\\0';\n\n    // Send overflow request to the server\n    // (Implementation to connect and send would be here)\n    printf(\"Sending overflow request to %s:%d\\n\", TARGET_SERVER, PORT);\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nif (len > BUFSIZE - sizeof(struct nbd_reply))\n    err(\"Request too big!\");\n```\n\n[Mandatory] Fix summary:\nThe patch changed the length check in the mainloop to prevent buffer overflows by ensuring the length does not exceed the adjusted buffer size.\n\n[Optional] Patch reference:\nhttps://github.com/yoe/nbd/commit/3ef52043861ab16352d49af89e048ba6339d6df8\n\n[Optional] Patch Analysis:\nThe fix added a check to ensure that the requested length does not lead to a buffer overflow, correcting a previous regression.\n\nField: PatchType (e.g., bounds check added, logic refactor, feature removal)\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other functions handling client requests for similar oversights.\n- Test with various payload sizes to ensure security improvements.\n- Analyze surrounding code for proper memory handling.\n\n[Optional] Likely variants/impact (one line):\nPotential for similar buffer overflow vulnerabilities in other parts of the codebase.",
        "tests": "NA",
        "solutions": "int mainloop(CLIENT *client) {\n\tstruct nbd_request request;\n\tstruct nbd_reply reply;\n\tgboolean go_on=TRUE;\n#ifdef DODBG\n\tint i = 0;\n#endif\n\tnegotiate(client->net, client, NULL);\n\tDEBUG(\"Entering request loop!\\n\");\n\treply.magic = htonl(NBD_REPLY_MAGIC);\n\treply.error = 0;\n\twhile (go_on) {\n\t\tchar buf[BUFSIZE];\n\t\tsize_t len;\n#ifdef DODBG\n\t\ti++;\n\t\tprintf(\"%d: \", i);\n#endif\n\t\treadit(client->net, &request, sizeof(request));\n\t\trequest.from = ntohll(request.from);\n\t\trequest.type = ntohl(request.type);\n\n\t\tif (request.type==NBD_CMD_DISC) {\n\t\t\tmsg2(LOG_INFO, \"Disconnect request received.\");\n                \tif (client->server->flags & F_COPYONWRITE) { \n\t\t\t\tif (client->difmap) g_free(client->difmap) ;\n                \t\tclose(client->difffile);\n\t\t\t\tunlink(client->difffilename);\n\t\t\t\tfree(client->difffilename);\n\t\t\t}\n\t\t\tgo_on=FALSE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = ntohl(request.len);\n \n \t\tif (request.magic != htonl(NBD_REQUEST_MAGIC))\n \t\t\terr(\"Not enough magic.\");\n\t\tif (len > BUFSIZE - sizeof(struct nbd_reply))\n \t\t\terr(\"Request too big!\");\n #ifdef DODBG\n \t\tprintf(\"%s from %llu (%llu) len %d, \", request.type ? \"WRITE\" :\n\t\t\t\t\"READ\", (unsigned long long)request.from,\n\t\t\t\t(unsigned long long)request.from / 512, len);\n#endif\n\t\tmemcpy(reply.handle, request.handle, sizeof(reply.handle));\n\t\tif ((request.from + len) > (OFFT_MAX)) {\n\t\t\tDEBUG(\"[Number too large!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (((ssize_t)((off_t)request.from + len) > client->exportsize)) {\n\t\t\tDEBUG(\"[RANGE!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (request.type==NBD_CMD_WRITE) {\n\t\t\tDEBUG(\"wr: net->buf, \");\n\t\t\treadit(client->net, buf, len);\n\t\t\tDEBUG(\"buf->exp, \");\n\t\t\tif ((client->server->flags & F_READONLY) ||\n\t\t\t    (client->server->flags & F_AUTOREADONLY)) {\n\t\t\t\tDEBUG(\"[WRITE to READONLY!]\");\n\t\t\t\tERROR(client, reply, EPERM);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (expwrite(request.from, buf, len, client)) {\n\t\t\t\tDEBUG(\"Write failed: %m\" );\n\t\t\t\tERROR(client, reply, errno);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSEND(client->net, reply);\n\t\t\tDEBUG(\"OK!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* READ */\n\n\t\tDEBUG(\"exp->buf, \");\n\t\tif (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {\n\t\t\tDEBUG(\"Read failed: %m\");\n\t\t\tERROR(client, reply, errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDEBUG(\"buf->net, \");\n\t\tmemcpy(buf, &reply, sizeof(struct nbd_reply));\n\t\twriteit(client->net, buf, len + sizeof(struct nbd_reply));\n\t\tDEBUG(\"OK!\\n\");\n\t}\n\treturn 0;\n}\n",
        "Publish Date": "2011-02-22",
        "Update Date": "2017-08-16",
        "Vulnerability type": "Exec Code Overflow ",
        "commit_url": "https://github.com/yoe/nbd/commit/3ef52043861ab16352d49af89e048ba6339d6df8",
        "commit_id": "3ef52043861ab16352d49af89e048ba6339d6df8",
        "commit_message": "Fix buffer size checking\n\nYes, this means we've re-introduced CVE-2005-3534. Sigh.",
        "project": "nbd"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-189",
        "CVE": "CVE-2012-4565",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/tcp_illinois.c": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n \t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n \t\t\t.tcpv_minrtt = ca->base_rtt,\n \t\t};\n\t\tu64 t = ca->sum_rtt;\n \n\t\tdo_div(t, ca->cnt_rtt);\n\t\tinfo.tcpv_rtt = t;\n \n \t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n \t}\n }\n"
        },
        "vulnerabilities": "The tcp_illinois_info function in net/ipv4/tcp_illinois.c in the Linux kernel before 3.4.19, when the net.ipv4.tcp_congestion_control illinois setting is enabled, allows local users to cause a denial of service (divide-by-zero error and OOPS) by reading TCP stats.",
        "annotation": "[Mandatory] ID:\nCVE-2012-4565\n\n[Mandatory] Title: CVE-2012-4565 / CWE-189:\nDivide-by-zero in tcp_illinois_info\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-12-21 \u2014 Patch release: 2013-08-21\n\n[Optional] Affected products/versions:\nLinux kernel before 3.4.19\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-189: Divide by Zero\n[Mandatory] Summary:\nThe tcp_illinois_info function in net/ipv4/tcp_illinois.c allows local users to cause a denial of service by reading TCP stats when the illinois congestion control is enabled. A divide-by-zero error occurs when the function attempts to perform a division using ca->cnt_rtt, which can be zero. This situation leads to a kernel OOPS as indicated by the code excerpt below. \n[Mandatory] Root cause:\nUnchecked value of ca->cnt_rtt can lead to a division by zero.\n[Mandatory] Attack Surface:\nKernel function\n[Mandatory] Impact Summary:\nDenial of service \u2192 Kernel panic\n[Optional] Trigger / Attack vector:\nReading TCP stats via specific sysctl command\n[Mandatory] Key code/struct excerpt (minimal):\nstatic void tcp_illinois_info(struct sock *sk, u32 ext,\n                            struct sk_buff *skb)\n{\n    const struct illinois *ca = inet_csk_ca(sk);\n\n    if (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n        struct tcpvegas_info info = {\n            .tcpv_enabled = 1,\n            .tcpv_rttcnt = ca->cnt_rtt,\n            .tcpv_minrtt = ca->base_rtt,\n        };\n        u64 t = ca->sum_rtt;\n\n        do_div(t, ca->cnt_rtt);  // Potential divide-by-zero here\n        info.tcpv_rtt = t;\n\n        nla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n    }\n}\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nDividing by zero during TCP stats reading\n\n[Mandatory] Exploit primitive(s) available:\nDenial of Service\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit can be easily triggered by a local user with sufficient privileges to read TCP statistics.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Set the congestion control to \"illinois\" using sysctl.\n- Attempt to read TCP stats via a monitoring command.\n- Wait for a condition where ca->cnt_rtt is zero.\n- Trigger the divide by zero error leading to a kernel crash.\n\n[Mandatory] Exploitation Example script payload code:\n# sysctl -w net.ipv4.tcp_congestion_control=illinois\n# watch -d ss -i  # Monitor internal TCP information\n\nFix\n[Mandatory] Fix code:\nstatic void tcp_illinois_info(struct sock *sk, u32 ext,\n                            struct sk_buff *skb)\n{\n    const struct illinois *ca = inet_csk_ca(sk);\n\n    if (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n        struct tcpvegas_info info = {\n            .tcpv_enabled = 1,\n            .tcpv_rttcnt = ca->cnt_rtt,\n            .tcpv_minrtt = ca->base_rtt,\n        };\n\n        if (info.tcpv_rttcnt > 0) {\n            u64 t = ca->sum_rtt;\n\n            do_div(t, info.tcpv_rttcnt);  // Safe division check\n            info.tcpv_rtt = t;\n        }\n        nla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n    }\n}\n\n[Mandatory] Fix summary:\nThe patch adds a check to ensure that the variable info.tcpv_rttcnt is greater than zero before performing the division, thus preventing the divide-by-zero error.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664\n\n[Optional] Patch Analysis:\nThe fix added a conditional check to avoid division by zero and used a local variable for safe access to cnt_rtt.\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review similar functions for divide-by-zero vulnerabilities.\n- Assess the impact of removing the race condition in related functions.\n- Test in environments with varying TCP implementations.\n\n[Optional] Likely variants/impact (one line):\nSimilar flaws may exist in other TCP congestion control algorithms that don't check critical counters before division.",
        "tests": "NA",
        "solutions": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n \t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n \t\t\t.tcpv_minrtt = ca->base_rtt,\n \t\t};\n \n\t\tif (info.tcpv_rttcnt > 0) {\n\t\t\tu64 t = ca->sum_rtt;\n \n\t\t\tdo_div(t, info.tcpv_rttcnt);\n\t\t\tinfo.tcpv_rtt = t;\n\t\t}\n \t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n \t}\n }\n",
        "Publish Date": "2012-12-21",
        "Update Date": "2013-08-21",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664",
        "commit_id": "8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664",
        "commit_message": "net: fix divide by zero in tcp algorithm illinois\n\nReading TCP stats when using TCP Illinois congestion control algorithm\ncan cause a divide by zero kernel oops.\n\nThe division by zero occur in tcp_illinois_info() at:\n do_div(t, ca->cnt_rtt);\nwhere ca->cnt_rtt can become zero (when rtt_reset is called)\n\nSteps to Reproduce:\n 1. Register tcp_illinois:\n     # sysctl -w net.ipv4.tcp_congestion_control=illinois\n 2. Monitor internal TCP information via command \"ss -i\"\n     # watch -d ss -i\n 3. Establish new TCP conn to machine\n\nEither it fails at the initial conn, or else it needs to wait\nfor a loss or a reset.\n\nThis is only related to reading stats.  The function avg_delay() also\nperforms the same divide, but is guarded with a (ca->cnt_rtt > 0) at its\ncalling point in update_params().  Thus, simply fix tcp_illinois_info().\n\nFunction tcp_illinois_info() / get_info() is called without\nsocket lock.  Thus, eliminate any race condition on ca->cnt_rtt\nby using a local stack variable.  Simply reuse info.tcpv_rttcnt,\nas its already set to ca->cnt_rtt.\nFunction avg_delay() is not affected by this race condition, as\nits called with the socket lock.\n\nCc: Petr Matousek <pmatouse@redhat.com>\nSigned-off-by: Jesper Dangaard Brouer <brouer@redhat.com>\nAcked-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Stephen Hemminger <shemminger@vyatta.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-4508",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "fs/ext4/extents.c": " static int ext4_convert_unwritten_extents_endio(handle_t *handle,\n\t\t\t\t\t      struct inode *inode,\n\t\t\t\t\t      struct ext4_ext_path *path)\n {\n \tstruct ext4_extent *ex;\n \tint depth;\n \tint err = 0;\n \n \tdepth = ext_depth(inode);\n \tex = path[depth].p_ext;\n \n \text_debug(\"ext4_convert_unwritten_extents_endio: inode %lu, logical\"\n \t\t\"block %llu, max_blocks %u\\n\", inode->i_ino,\n\t\t(unsigned long long)le32_to_cpu(ex->ee_block),\n\t\text4_ext_get_actual_len(ex));\n \n \terr = ext4_ext_get_access(handle, inode, path + depth);\n \tif (err)\n\t\tgoto out;\n\t/* first mark the extent as initialized */\n\text4_ext_mark_initialized(ex);\n\n\t/* note: ext4_ext_correct_indexes() isn't needed here because\n\t * borders are not changed\n\t */\n\text4_ext_try_to_merge(handle, inode, path, ex);\n\n\t/* Mark modified extent as dirty */\n\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\nout:\n\text4_ext_show_leaf(inode, path);\n\treturn err;\n}\n"
        },
        "vulnerabilities": "Race condition in fs/ext4/extents.c in the Linux kernel before 3.4.16 allows local users to obtain sensitive information from a deleted file by reading an extent that was not properly marked as uninitialized.",
        "annotation": "[Mandatory] ID:\nCVE-2012-4508\n\n[Mandatory] Title: CVE-2012-4508 / CWE-362:\nRace condition in ext4_convert_unwritten_extents_endio\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-12-21 \u2014 Patch release: 2014-01-07\n\n[Optional] Affected products/versions:\nLinux kernel before 3.4.16\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-362: Race Condition\n[Mandatory] Summary:\nIn the ext4_convert_unwritten_extents_endio function, a race condition allows local users to read uninitialized extents from deleted files. This occurs because the extent may not be correctly marked as initialized, leading to potential information disclosure. The code excerpt demonstrates the operation on extents but fails to account for concurrent modifications.\n[Mandatory] Root cause:\nThe root cause is an insufficient synchronization during the handling of file extents under concurrent conditions.\n[Mandatory] Attack Surface:\nFile system access in kernel space\n[Mandatory] Impact Summary:\nInformation disclosure from uninitialized extents\n[Optional] Trigger / Attack vector:\nLocal user file access\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nstatic int ext4_convert_unwritten_extents_endio(handle_t *handle,\n                                               struct inode *inode,\n                                               struct ext4_ext_path *path)\n{\n    struct ext4_extent *ex;\n    int depth;\n    int err = 0;\n\n    depth = ext_depth(inode);\n    ex = path[depth].p_ext;\n\n    err = ext4_ext_get_access(handle, inode, path + depth);\n    if (err)\n        goto out;\n    /* first mark the extent as initialized */\n    ext4_ext_mark_initialized(ex);\n    ...\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nFile system API calls\n[Mandatory] Exploit primitive(s) available:\nRead race conditions on deleted file extents\n[Mandatory] Exploitability summary (1 sentence):\nExploiting this vulnerability is controlled but requires local access to the file system where the race condition can be triggered.\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Start a process that deletes a file while simultaneously reading its extents.\n- Attempt to access the extent structure that may not be marked initialized.\n- Potentially obtain sensitive information that was supposed to be inaccessible.\n- Can be repeated to increase success rate of information retrieval.\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdio.h>\n\nint main() {\n    // Simulate deleting a file and trying to read its extent\n    unlink(\"sensitive_file.txt\");\n    int fd = open(\"sensitive_file.txt\", O_RDONLY);\n    // Attempt to read from the deleted file\n    char buffer[100];\n    read(fd, buffer, sizeof(buffer));\n    printf(\"Data read: %s\\n\", buffer);\n    close(fd);\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nstatic int ext4_convert_unwritten_extents_endio(handle_t *handle,\n                                                struct inode *inode,\n                                                struct ext4_map_blocks *map,\n                                                struct ext4_ext_path *path)\n{\n    struct ext4_extent *ex;\n    ext4_lblk_t ee_block;\n    unsigned int ee_len;\n    int depth;\n    int err = 0;\n\n    depth = ext_depth(inode);\n    ex = path[depth].p_ext;\n\n    /* If extent is larger than requested then split is required */\n    if (ee_block != map->m_lblk || ee_len > map->m_len) {\n        err = ext4_split_unwritten_extents(handle, inode, map, path,\n                                            EXT4_GET_BLOCKS_CONVERT);\n        if (err < 0)\n            goto out;\n    }\n\n    err = ext4_ext_get_access(handle, inode, path + depth);\n    if (err)\n        goto out;\n    /* first mark the extent as initialized */\n    ext4_ext_mark_initialized(ex);\n    ...\n}\n```\n[Mandatory] Fix summary:\nThe patch adds additional checks to ensure that the extents are properly initialized and managed during concurrent operations, preventing race conditions.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/dee1f973ca341c266229faa5a1a5bb268bed3531\n\n[Optional] Patch Analysis:\nShort note: Improved synchronization during file extent management.\n\nField: PatchType (e.g., bounds check added, logic refactor, feature removal)\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other extent handling functions for similar race conditions.\n- Ensure all filesystems with concurrent operations are scrutinized for synchronization issues.\n- Test against high-load scenarios to validate effectiveness of the patch.\n\n[Optional] Likely variants/impact (one line):\nPotential for similar race conditions in other filesystem operations.",
        "tests": "NA",
        "solutions": " static int ext4_convert_unwritten_extents_endio(handle_t *handle,\n\t\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\t\t\tstruct ext4_ext_path *path)\n {\n \tstruct ext4_extent *ex;\n\text4_lblk_t ee_block;\n\tunsigned int ee_len;\n \tint depth;\n \tint err = 0;\n \n \tdepth = ext_depth(inode);\n \tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n \n \text_debug(\"ext4_convert_unwritten_extents_endio: inode %lu, logical\"\n \t\t\"block %llu, max_blocks %u\\n\", inode->i_ino,\n\t\t  (unsigned long long)ee_block, ee_len);\n\n\t/* If extent is larger than requested then split is required */\n\tif (ee_block != map->m_lblk || ee_len > map->m_len) {\n\t\terr = ext4_split_unwritten_extents(handle, inode, map, path,\n\t\t\t\t\t\t   EXT4_GET_BLOCKS_CONVERT);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\text4_ext_drop_refs(path);\n\t\tpath = ext4_ext_find_extent(inode, map->m_lblk, path);\n\t\tif (IS_ERR(path)) {\n\t\t\terr = PTR_ERR(path);\n\t\t\tgoto out;\n\t\t}\n\t\tdepth = ext_depth(inode);\n\t\tex = path[depth].p_ext;\n\t}\n \n \terr = ext4_ext_get_access(handle, inode, path + depth);\n \tif (err)\n\t\tgoto out;\n\t/* first mark the extent as initialized */\n\text4_ext_mark_initialized(ex);\n\n\t/* note: ext4_ext_correct_indexes() isn't needed here because\n\t * borders are not changed\n\t */\n\text4_ext_try_to_merge(handle, inode, path, ex);\n\n\t/* Mark modified extent as dirty */\n\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\nout:\n\text4_ext_show_leaf(inode, path);\n\treturn err;\n}\n",
        "Publish Date": "2012-12-21",
        "Update Date": "2014-01-07",
        "Vulnerability type": "+Info ",
        "commit_url": "https://github.com/torvalds/linux/commit/dee1f973ca341c266229faa5a1a5bb268bed3531",
        "commit_id": "dee1f973ca341c266229faa5a1a5bb268bed3531",
        "commit_message": "ext4: race-condition protection for ext4_convert_unwritten_extents_endio\n\nWe assumed that at the time we call ext4_convert_unwritten_extents_endio()\nextent in question is fully inside [map.m_lblk, map->m_len] because\nit was already split during submission.  But this may not be true due to\na race between writeback vs fallocate.\n\nIf extent in question is larger than requested we will split it again.\nSpecial precautions should being done if zeroout required because\n[map.m_lblk, map->m_len] already contains valid data.\n\nSigned-off-by: Dmitry Monakhov <dmonakhov@openvz.org>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@vger.kernel.org",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-4508",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "fs/ext4/extents.c": "ext4_ext_handle_uninitialized_extents(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map,\n\t\t\tstruct ext4_ext_path *path, int flags,\n\t\t\tunsigned int allocated, ext4_fsblk_t newblock)\n{\n\tint ret = 0;\n\tint err = 0;\n\text4_io_end_t *io = ext4_inode_aio(inode);\n\n\text_debug(\"ext4_ext_handle_uninitialized_extents: inode %lu, logical \"\n\t\t  \"block %llu, max_blocks %u, flags %x, allocated %u\\n\",\n\t\t  inode->i_ino, (unsigned long long)map->m_lblk, map->m_len,\n\t\t  flags, allocated);\n\text4_ext_show_leaf(inode, path);\n\n\ttrace_ext4_ext_handle_uninitialized_extents(inode, map, allocated,\n\t\t\t\t\t\t    newblock);\n\n\t/* get_block() before submit the IO, split the extent */\n\tif ((flags & EXT4_GET_BLOCKS_PRE_IO)) {\n\t\tret = ext4_split_unwritten_extents(handle, inode, map,\n\t\t\t\t\t\t   path, flags);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Flag the inode(non aio case) or end_io struct (aio case)\n\t\t * that this IO needs to conversion to written when IO is\n\t\t * completed\n\t\t */\n\t\tif (io)\n\t\t\text4_set_io_unwritten_flag(inode, io);\n\t\telse\n\t\t\text4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);\n\t\tif (ext4_should_dioread_nolock(inode))\n\t\t\tmap->m_flags |= EXT4_MAP_UNINIT;\n\t\tgoto out;\n \t}\n \t/* IO end_io complete, convert the filled extent to written */\n \tif ((flags & EXT4_GET_BLOCKS_CONVERT)) {\n\t\tret = ext4_convert_unwritten_extents_endio(handle, inode,\n \t\t\t\t\t\t\tpath);\n \t\tif (ret >= 0) {\n \t\t\text4_update_inode_fsync_trans(handle, inode, 1);\n\t\t\terr = check_eofblocks_fl(handle, inode, map->m_lblk,\n\t\t\t\t\t\t path, map->m_len);\n\t\t} else\n\t\t\terr = ret;\n\t\tgoto out2;\n\t}\n\t/* buffered IO case */\n\t/*\n\t * repeat fallocate creation request\n\t * we already have an unwritten extent\n\t */\n\tif (flags & EXT4_GET_BLOCKS_UNINIT_EXT)\n\t\tgoto map_out;\n\n\t/* buffered READ or buffered write_begin() lookup */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\t/*\n\t\t * We have blocks reserved already.  We\n\t\t * return allocated blocks so that delalloc\n\t\t * won't do block reservation for us.  But\n\t\t * the buffer head will be unmapped so that\n\t\t * a read from the block returns 0s.\n\t\t */\n\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t\tgoto out1;\n\t}\n\n\t/* buffered write, writepage time, convert*/\n\tret = ext4_ext_convert_to_initialized(handle, inode, map, path);\n\tif (ret >= 0)\n\t\text4_update_inode_fsync_trans(handle, inode, 1);\nout:\n\tif (ret <= 0) {\n\t\terr = ret;\n\t\tgoto out2;\n\t} else\n\t\tallocated = ret;\n\tmap->m_flags |= EXT4_MAP_NEW;\n\t/*\n\t * if we allocated more blocks than requested\n\t * we need to make sure we unmap the extra block\n\t * allocated. The actual needed block will get\n\t * unmapped later when we find the buffer_head marked\n\t * new.\n\t */\n\tif (allocated > map->m_len) {\n\t\tunmap_underlying_metadata_blocks(inode->i_sb->s_bdev,\n\t\t\t\t\tnewblock + map->m_len,\n\t\t\t\t\tallocated - map->m_len);\n\t\tallocated = map->m_len;\n\t}\n\n\t/*\n\t * If we have done fallocate with the offset that is already\n\t * delayed allocated, we would have block reservation\n\t * and quota reservation done in the delayed write path.\n\t * But fallocate would have already updated quota and block\n\t * count for this offset. So cancel these reservation\n\t */\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) {\n\t\tunsigned int reserved_clusters;\n\t\treserved_clusters = get_reserved_cluster_alloc(inode,\n\t\t\t\tmap->m_lblk, map->m_len);\n\t\tif (reserved_clusters)\n\t\t\text4_da_update_reserve_space(inode,\n\t\t\t\t\t\t     reserved_clusters,\n\t\t\t\t\t\t     0);\n\t}\n\nmap_out:\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tif ((flags & EXT4_GET_BLOCKS_KEEP_SIZE) == 0) {\n\t\terr = check_eofblocks_fl(handle, inode, map->m_lblk, path,\n\t\t\t\t\t map->m_len);\n\t\tif (err < 0)\n\t\t\tgoto out2;\n\t}\nout1:\n\tif (allocated > map->m_len)\n\t\tallocated = map->m_len;\n\text4_ext_show_leaf(inode, path);\n\tmap->m_pblk = newblock;\n\tmap->m_len = allocated;\nout2:\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tkfree(path);\n\t}\n\treturn err ? err : allocated;\n}\n"
        },
        "vulnerabilities": "Race condition in fs/ext4/extents.c in the Linux kernel before 3.4.16 allows local users to obtain sensitive information from a deleted file by reading an extent that was not properly marked as uninitialized.",
        "annotation": "[Mandatory] ID:\nCVE-2012-4508\n\n[Mandatory] Title: CVE-2012-4508 / CWE-362:\nRace condition in ext4 filesystem\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-12-21 \u2014 Patch release: 2014-01-07\n\n[Optional] Affected products/versions:\nLinux kernel before 3.4.16\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-362: Race Condition\n[Mandatory] Summary:\nThe vulnerability exists in the ext4_ext_handle_uninitialized_extents function within the ext4 filesystem of the Linux kernel. An attacker can exploit this race condition to read uninitialized extents from a deleted file, leading to exposure of sensitive information. This flaw arises when handling unwritten extents that are not properly marked, as shown in the code excerpt.\n[Mandatory] Root cause:\nRace condition during extent handling in the ext4 filesystem.\n[Mandatory] Attack Surface:\nFilesystem operations\n[Mandatory] Impact Summary:\nInformation disclosure\n\n[Optional] Trigger / Attack vector:\nLocal filesystem access\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nif ((flags & EXT4_GET_BLOCKS_PRE_IO)) {\n    ret = ext4_split_unwritten_extents(handle, inode, map, path, flags);\n    if (ret <= 0)\n        goto out;\n}\nif ((flags & EXT4_GET_BLOCKS_CONVERT)) {\n    ret = ext4_convert_unwritten_extents_endio(handle, inode, path);\n    if (ret >= 0) {\n        ext4_update_inode_fsync_trans(handle, inode, 1);\n    }\n}\nif (flags & EXT4_GET_BLOCKS_UNINIT_EXT)\n    goto map_out;\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nLocal filesystem operation\n\n[Mandatory] Exploit primitive(s) available:\nReading uninitialized extents\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit requires local access to the filesystem and can be easily triggered by accessing deleted files.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Open a file using the ext4 filesystem.\n- Delete the file to prepare for exploitation.\n- Attempt to read the uninitialized extents.\n- Access data from the deleted file that has not been properly marked as uninitialized.\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    // Open a file and then delete it\n    int fd = open(\"sensitive_data.txt\", O_RDWR | O_CREAT);\n    write(fd, \"secret data\", strlen(\"secret data\"));\n    close(fd);\n    remove(\"sensitive_data.txt\");\n\n    // Attempt to read the uninitialized extent\n    // (Exploitation will depend on triggering code path that doesn't mark it)\n    // This part is pseudo-code as it requires specific ext4 syscall interaction\n    // read_extent(\"sensitive_data.txt\");\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nif ((flags & EXT4_GET_BLOCKS_PRE_IO)) {\n    ret = ext4_split_unwritten_extents(handle, inode, map, path, flags);\n    if (ret <= 0)\n        goto out;\n}\nif ((flags & EXT4_GET_BLOCKS_CONVERT)) {\n    ret = ext4_convert_unwritten_extents_endio(handle, inode, map, path);\n    if (ret >= 0) {\n        ext4_update_inode_fsync_trans(handle, inode, 1);\n    }\n}\n```\n\n[Mandatory] Fix summary:\nThe fix added proper handling of unwritten extents to ensure they are correctly marked as initialized to prevent unauthorized access to sensitive information.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/dee1f973ca341c266229faa5a1a5bb268bed3531\n\n[Optional] Patch Analysis:\nThe patch introduced race condition protections to ensure that extents are fully marked before being accessed, preventing unintended information disclosure.",
        "tests": "NA",
        "solutions": "ext4_ext_handle_uninitialized_extents(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map,\n\t\t\tstruct ext4_ext_path *path, int flags,\n\t\t\tunsigned int allocated, ext4_fsblk_t newblock)\n{\n\tint ret = 0;\n\tint err = 0;\n\text4_io_end_t *io = ext4_inode_aio(inode);\n\n\text_debug(\"ext4_ext_handle_uninitialized_extents: inode %lu, logical \"\n\t\t  \"block %llu, max_blocks %u, flags %x, allocated %u\\n\",\n\t\t  inode->i_ino, (unsigned long long)map->m_lblk, map->m_len,\n\t\t  flags, allocated);\n\text4_ext_show_leaf(inode, path);\n\n\ttrace_ext4_ext_handle_uninitialized_extents(inode, map, allocated,\n\t\t\t\t\t\t    newblock);\n\n\t/* get_block() before submit the IO, split the extent */\n\tif ((flags & EXT4_GET_BLOCKS_PRE_IO)) {\n\t\tret = ext4_split_unwritten_extents(handle, inode, map,\n\t\t\t\t\t\t   path, flags);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Flag the inode(non aio case) or end_io struct (aio case)\n\t\t * that this IO needs to conversion to written when IO is\n\t\t * completed\n\t\t */\n\t\tif (io)\n\t\t\text4_set_io_unwritten_flag(inode, io);\n\t\telse\n\t\t\text4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);\n\t\tif (ext4_should_dioread_nolock(inode))\n\t\t\tmap->m_flags |= EXT4_MAP_UNINIT;\n\t\tgoto out;\n \t}\n \t/* IO end_io complete, convert the filled extent to written */\n \tif ((flags & EXT4_GET_BLOCKS_CONVERT)) {\n\t\tret = ext4_convert_unwritten_extents_endio(handle, inode, map,\n \t\t\t\t\t\t\tpath);\n \t\tif (ret >= 0) {\n \t\t\text4_update_inode_fsync_trans(handle, inode, 1);\n\t\t\terr = check_eofblocks_fl(handle, inode, map->m_lblk,\n\t\t\t\t\t\t path, map->m_len);\n\t\t} else\n\t\t\terr = ret;\n\t\tgoto out2;\n\t}\n\t/* buffered IO case */\n\t/*\n\t * repeat fallocate creation request\n\t * we already have an unwritten extent\n\t */\n\tif (flags & EXT4_GET_BLOCKS_UNINIT_EXT)\n\t\tgoto map_out;\n\n\t/* buffered READ or buffered write_begin() lookup */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\t/*\n\t\t * We have blocks reserved already.  We\n\t\t * return allocated blocks so that delalloc\n\t\t * won't do block reservation for us.  But\n\t\t * the buffer head will be unmapped so that\n\t\t * a read from the block returns 0s.\n\t\t */\n\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t\tgoto out1;\n\t}\n\n\t/* buffered write, writepage time, convert*/\n\tret = ext4_ext_convert_to_initialized(handle, inode, map, path);\n\tif (ret >= 0)\n\t\text4_update_inode_fsync_trans(handle, inode, 1);\nout:\n\tif (ret <= 0) {\n\t\terr = ret;\n\t\tgoto out2;\n\t} else\n\t\tallocated = ret;\n\tmap->m_flags |= EXT4_MAP_NEW;\n\t/*\n\t * if we allocated more blocks than requested\n\t * we need to make sure we unmap the extra block\n\t * allocated. The actual needed block will get\n\t * unmapped later when we find the buffer_head marked\n\t * new.\n\t */\n\tif (allocated > map->m_len) {\n\t\tunmap_underlying_metadata_blocks(inode->i_sb->s_bdev,\n\t\t\t\t\tnewblock + map->m_len,\n\t\t\t\t\tallocated - map->m_len);\n\t\tallocated = map->m_len;\n\t}\n\n\t/*\n\t * If we have done fallocate with the offset that is already\n\t * delayed allocated, we would have block reservation\n\t * and quota reservation done in the delayed write path.\n\t * But fallocate would have already updated quota and block\n\t * count for this offset. So cancel these reservation\n\t */\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) {\n\t\tunsigned int reserved_clusters;\n\t\treserved_clusters = get_reserved_cluster_alloc(inode,\n\t\t\t\tmap->m_lblk, map->m_len);\n\t\tif (reserved_clusters)\n\t\t\text4_da_update_reserve_space(inode,\n\t\t\t\t\t\t     reserved_clusters,\n\t\t\t\t\t\t     0);\n\t}\n\nmap_out:\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tif ((flags & EXT4_GET_BLOCKS_KEEP_SIZE) == 0) {\n\t\terr = check_eofblocks_fl(handle, inode, map->m_lblk, path,\n\t\t\t\t\t map->m_len);\n\t\tif (err < 0)\n\t\t\tgoto out2;\n\t}\nout1:\n\tif (allocated > map->m_len)\n\t\tallocated = map->m_len;\n\text4_ext_show_leaf(inode, path);\n\tmap->m_pblk = newblock;\n\tmap->m_len = allocated;\nout2:\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tkfree(path);\n\t}\n\treturn err ? err : allocated;\n}\n",
        "Publish Date": "2012-12-21",
        "Update Date": "2014-01-07",
        "Vulnerability type": "+Info ",
        "commit_url": "https://github.com/torvalds/linux/commit/dee1f973ca341c266229faa5a1a5bb268bed3531",
        "commit_id": "dee1f973ca341c266229faa5a1a5bb268bed3531",
        "commit_message": "ext4: race-condition protection for ext4_convert_unwritten_extents_endio\n\nWe assumed that at the time we call ext4_convert_unwritten_extents_endio()\nextent in question is fully inside [map.m_lblk, map->m_len] because\nit was already split during submission.  But this may not be true due to\na race between writeback vs fallocate.\n\nIf extent in question is larger than requested we will split it again.\nSpecial precautions should being done if zeroout required because\n[map.m_lblk, map->m_len] already contains valid data.\n\nSigned-off-by: Dmitry Monakhov <dmonakhov@openvz.org>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@vger.kernel.org",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-4508",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "fs/ext4/extents.c": "static int ext4_split_extent(handle_t *handle,\n\t\t\t      struct inode *inode,\n\t\t\t      struct ext4_ext_path *path,\n\t\t\t      struct ext4_map_blocks *map,\n\t\t\t      int split_flag,\n\t\t\t      int flags)\n{\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex;\n\tunsigned int ee_len, depth;\n\tint err = 0;\n\tint uninitialized;\n\tint split_flag1, flags1;\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n \tuninitialized = ext4_ext_is_uninitialized(ex);\n \n \tif (map->m_lblk + map->m_len < ee_block + ee_len) {\n\t\tsplit_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?\n\t\t\t      EXT4_EXT_MAY_ZEROOUT : 0;\n \t\tflags1 = flags | EXT4_GET_BLOCKS_PRE_IO;\n \t\tif (uninitialized)\n \t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT1 |\n \t\t\t\t       EXT4_EXT_MARK_UNINIT2;\n \t\terr = ext4_split_extent_at(handle, inode, path,\n \t\t\t\tmap->m_lblk + map->m_len, split_flag1, flags1);\n \t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\text4_ext_drop_refs(path);\n\tpath = ext4_ext_find_extent(inode, map->m_lblk, path);\n\tif (IS_ERR(path))\n \t\treturn PTR_ERR(path);\n \n \tif (map->m_lblk >= ee_block) {\n\t\tsplit_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?\n\t\t\t      EXT4_EXT_MAY_ZEROOUT : 0;\n \t\tif (uninitialized)\n \t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT1;\n \t\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT2;\n\t\terr = ext4_split_extent_at(handle, inode, path,\n\t\t\t\tmap->m_lblk, split_flag1, flags);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\text4_ext_show_leaf(inode, path);\nout:\n\treturn err ? err : map->m_len;\n}\n"
        },
        "vulnerabilities": "Race condition in fs/ext4/extents.c in the Linux kernel before 3.4.16 allows local users to obtain sensitive information from a deleted file by reading an extent that was not properly marked as uninitialized.",
        "annotation": "[Mandatory] ID:\nCVE-2012-4508\n\n[Mandatory] Title: CVE-2012-4508 / CWE-362:\nRace condition in ext4 file system\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-12-21 \u2014 Patch release: 2014-01-07\n\n[Optional] Affected products/versions:\nLinux kernel before 3.4.16\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-362 - Race Condition\n[Mandatory] Summary:\nThe vulnerable function `ext4_split_extent` in the ext4 file system can be exploited due to a race condition that allows local users to read sensitive information from a deleted file. The bug occurs when the extent is not properly marked as uninitialized, which is visible in the provided code excerpt, particularly when the `uninitialized` condition is not adequately checked before the extent is accessed.\n[Mandatory] Root cause:\nRace condition due to incorrect handling of uninitialized extents.\n[Mandatory] Attack Surface:\nFile system operation in Linux kernel.\n[Mandatory] Impact Summary:\nInformation disclosure of deleted files\n[Optional] Trigger / Attack vector:\nLocal user file operation\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nif (map->m_lblk + map->m_len < ee_block + ee_len) {\n    split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?\n                  EXT4_EXT_MAY_ZEROOUT : 0;\n    flags1 = flags | EXT4_GET_BLOCKS_PRE_IO;\n    if (uninitialized)\n        split_flag1 |= EXT4_EXT_MARK_UNINIT1 |\n                       EXT4_EXT_MARK_UNINIT2;\n    err = ext4_split_extent_at(handle, inode, path,\n                    map->m_lblk + map->m_len, split_flag1, flags1);\n    if (err)\n        goto out;\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nFile operation via ext4 file system\n\n[Mandatory] Exploit primitive(s) available:\nArbitrary read of deleted file extents\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit is relatively easy since it can be triggered by local users through standard file operations without requiring special privileges.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Open a file that was recently deleted from the ext4 file system.\n- Attempt to access the deleted file's extents while ensuring they are not marked as uninitialized.\n- Use concurrent processes to exploit the timing of the race condition.\n- Read the data returned from the deleted file extents.\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdio.h>\n\nint main() {\n    int fd = open(\"deleted_file\", O_RDONLY);\n    if (fd < 0) {\n        perror(\"Failed to open deleted file\");\n        return 1;\n    }\n    char buffer[1024];\n    read(fd, buffer, sizeof(buffer));\n    printf(\"Read from deleted file: %s\\n\", buffer);\n    close(fd);\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nif (map->m_lblk + map->m_len < ee_block + ee_len) {\n    split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT;\n    flags1 = flags | EXT4_GET_BLOCKS_PRE_IO;\n    if (uninitialized)\n        split_flag1 |= EXT4_EXT_MARK_UNINIT1 |\n                       EXT4_EXT_DATA_VALID2;\n    err = ext4_split_extent_at(handle, inode, path,\n                    map->m_lblk + map->m_len, split_flag1, flags1);\n    if (err)\n        goto out;\n}\n```\n\n[Mandatory] Fix summary:\nThe patch modifies how uninitialized extents are handled by ensuring that they are properly marked before being accessed, thus preventing the race condition from occurring.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/dee1f973ca341c266229faa5a1a5bb268bed3531\n\n[Optional] Patch Analysis:\nWhat did the fix do?\nField: Logic refactor to ensure proper extent initialization checks.",
        "tests": "NA",
        "solutions": "static int ext4_split_extent(handle_t *handle,\n\t\t\t      struct inode *inode,\n\t\t\t      struct ext4_ext_path *path,\n\t\t\t      struct ext4_map_blocks *map,\n\t\t\t      int split_flag,\n\t\t\t      int flags)\n{\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex;\n\tunsigned int ee_len, depth;\n\tint err = 0;\n\tint uninitialized;\n\tint split_flag1, flags1;\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n \tuninitialized = ext4_ext_is_uninitialized(ex);\n \n \tif (map->m_lblk + map->m_len < ee_block + ee_len) {\n\t\tsplit_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT;\n \t\tflags1 = flags | EXT4_GET_BLOCKS_PRE_IO;\n \t\tif (uninitialized)\n \t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT1 |\n \t\t\t\t       EXT4_EXT_MARK_UNINIT2;\n\t\tif (split_flag & EXT4_EXT_DATA_VALID2)\n\t\t\tsplit_flag1 |= EXT4_EXT_DATA_VALID1;\n \t\terr = ext4_split_extent_at(handle, inode, path,\n \t\t\t\tmap->m_lblk + map->m_len, split_flag1, flags1);\n \t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\text4_ext_drop_refs(path);\n\tpath = ext4_ext_find_extent(inode, map->m_lblk, path);\n\tif (IS_ERR(path))\n \t\treturn PTR_ERR(path);\n \n \tif (map->m_lblk >= ee_block) {\n\t\tsplit_flag1 = split_flag & (EXT4_EXT_MAY_ZEROOUT |\n\t\t\t\t\t    EXT4_EXT_DATA_VALID2);\n \t\tif (uninitialized)\n \t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT1;\n \t\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT2;\n\t\terr = ext4_split_extent_at(handle, inode, path,\n\t\t\t\tmap->m_lblk, split_flag1, flags);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\text4_ext_show_leaf(inode, path);\nout:\n\treturn err ? err : map->m_len;\n}\n",
        "Publish Date": "2012-12-21",
        "Update Date": "2014-01-07",
        "Vulnerability type": "+Info ",
        "commit_url": "https://github.com/torvalds/linux/commit/dee1f973ca341c266229faa5a1a5bb268bed3531",
        "commit_id": "dee1f973ca341c266229faa5a1a5bb268bed3531",
        "commit_message": "ext4: race-condition protection for ext4_convert_unwritten_extents_endio\n\nWe assumed that at the time we call ext4_convert_unwritten_extents_endio()\nextent in question is fully inside [map.m_lblk, map->m_len] because\nit was already split during submission.  But this may not be true due to\na race between writeback vs fallocate.\n\nIf extent in question is larger than requested we will split it again.\nSpecial precautions should being done if zeroout required because\n[map.m_lblk, map->m_len] already contains valid data.\n\nSigned-off-by: Dmitry Monakhov <dmonakhov@openvz.org>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@vger.kernel.org",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-4508",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "fs/ext4/extents.c": "static int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path *path,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags)\n{\n\text4_fsblk_t newblock;\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex, newex, orig_ex;\n\tstruct ext4_extent *ex2 = NULL;\n \tunsigned int ee_len, depth;\n \tint err = 0;\n \n \text_debug(\"ext4_split_extents_at: inode %lu, logical\"\n \t\t\"block %llu\\n\", inode->i_ino, (unsigned long long)split);\n \n\text4_ext_show_leaf(inode, path);\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tnewblock = split - ee_block + ext4_ext_pblock(ex);\n\n\tBUG_ON(split < ee_block || split >= (ee_block + ee_len));\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto out;\n\n\tif (split == ee_block) {\n\t\t/*\n\t\t * case b: block @split is the block that the extent begins with\n\t\t * then we just change the state of the extent, and splitting\n\t\t * is not needed.\n\t\t */\n\t\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\t\text4_ext_mark_uninitialized(ex);\n\t\telse\n\t\t\text4_ext_mark_initialized(ex);\n\n\t\tif (!(flags & EXT4_GET_BLOCKS_PRE_IO))\n\t\t\text4_ext_try_to_merge(handle, inode, path, ex);\n\n\t\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\t\tgoto out;\n\t}\n\n\t/* case a */\n\tmemcpy(&orig_ex, ex, sizeof(orig_ex));\n\tex->ee_len = cpu_to_le16(split - ee_block);\n\tif (split_flag & EXT4_EXT_MARK_UNINIT1)\n\t\text4_ext_mark_uninitialized(ex);\n\n\t/*\n\t * path may lead to new leaf, not to original leaf any more\n\t * after ext4_ext_insert_extent() returns,\n\t */\n\terr = ext4_ext_dirty(handle, inode, path + depth);\n\tif (err)\n\t\tgoto fix_extent_len;\n\n\tex2 = &newex;\n\tex2->ee_block = cpu_to_le32(split);\n\tex2->ee_len   = cpu_to_le16(ee_len - (split - ee_block));\n\text4_ext_store_pblock(ex2, newblock);\n\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\text4_ext_mark_uninitialized(ex2);\n \n \terr = ext4_ext_insert_extent(handle, inode, path, &newex, flags);\n \tif (err == -ENOSPC && (EXT4_EXT_MAY_ZEROOUT & split_flag)) {\n\t\terr = ext4_ext_zeroout(inode, &orig_ex);\n \t\tif (err)\n \t\t\tgoto fix_extent_len;\n \t\t/* update the extent length and mark as initialized */\n\t\tex->ee_len = cpu_to_le16(ee_len);\n\t\text4_ext_try_to_merge(handle, inode, path, ex);\n\t\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\t\tgoto out;\n\t} else if (err)\n\t\tgoto fix_extent_len;\n\nout:\n\text4_ext_show_leaf(inode, path);\n\treturn err;\n\nfix_extent_len:\n\tex->ee_len = orig_ex.ee_len;\n\text4_ext_dirty(handle, inode, path + depth);\n\treturn err;\n}\n"
        },
        "vulnerabilities": "Race condition in fs/ext4/extents.c in the Linux kernel before 3.4.16 allows local users to obtain sensitive information from a deleted file by reading an extent that was not properly marked as uninitialized.",
        "annotation": "[Mandatory] ID:\nCVE-2012-4508\n\n[Mandatory] Title: CVE-2012-4508 / CWE-362:\nRace condition in Linux kernel ext4\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-12-21 \u2014 Patch release: 2014-01-07\n\n[Optional] Affected products/versions:\nLinux kernel before 3.4.16\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-362: Race Condition\n[Mandatory] Summary:\nThe vulnerability allows local users to read sensitive data from a deleted file due to a race condition in the ext4 filesystem's handling of uninitialized extents. This is triggered when the extent being accessed is not properly marked as uninitialized during a read operation, as shown in the function `ext4_split_extent_at` where the state of extents may not be updated correctly after a split operation.\n[Mandatory] Root cause:\nThe underlying technical reason is that the code does not adequately synchronize access to extents while operations that modify them are in progress.\n[Mandatory] Attack Surface:\nKernel filesystem operations\n[Mandatory] Impact Summary:\nLocal information disclosure\n[Optional] Trigger / Attack vector:\nAccessing extents after file deletion\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nBUG_ON(split < ee_block || split >= (ee_block + ee_len));\n\nerr = ext4_ext_get_access(handle, inode, path + depth);\nif (err)\n    goto out;\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nFilesystem operations\n\n[Mandatory] Exploit primitive(s) available:\nReading stale data from uninitialized extents\n\n[Mandatory] Exploitability summary (1 sentence):\nExploitation can be straightforward for local users, especially in systems with multiple threads accessing shared resources.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Attempt to access a deleted file's extent.\n- Trigger concurrent write operations on the filesystem.\n- Read back the extent data despite it being marked as deleted.\n- Observe potentially old or sensitive information from these extents.\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nint main() {\n    int fd = open(\"deleted_file\", O_RDONLY);\n    char buffer[1024];\n    read(fd, buffer, sizeof(buffer));\n    printf(\"Read data: %s\\n\", buffer);\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nBUG_ON((split_flag & (EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2)) ==\n       (EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2));\n```\n\n[Mandatory] Fix summary:\nThe patch adds checks to ensure that split flags are valid and that race conditions do not allow reading uninitialized extents.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/dee1f973ca341c266229faa5a1a5bb268bed3531\n\n[Optional] Patch Analysis:\nWhat did the fix do?\nField: PatchType (e.g., bounds check added, logic refactor, feature removal)\nAdded logic to prevent race conditions when accessing extents. \n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Analyze other filesystem operations for similar race conditions.\n- Review concurrent access patterns in ext4 code.\n- Fuzz test ext4 extent management functions.\n\n[Optional] Likely variants/impact (one line):\nPotentially impacts any operation that interacts with ext4 extents and simultaneous file modification actions.",
        "tests": "NA",
        "solutions": "static int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path *path,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags)\n{\n\text4_fsblk_t newblock;\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex, newex, orig_ex;\n\tstruct ext4_extent *ex2 = NULL;\n \tunsigned int ee_len, depth;\n \tint err = 0;\n \n\tBUG_ON((split_flag & (EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2)) ==\n\t       (EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2));\n\n \text_debug(\"ext4_split_extents_at: inode %lu, logical\"\n \t\t\"block %llu\\n\", inode->i_ino, (unsigned long long)split);\n \n\text4_ext_show_leaf(inode, path);\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tnewblock = split - ee_block + ext4_ext_pblock(ex);\n\n\tBUG_ON(split < ee_block || split >= (ee_block + ee_len));\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto out;\n\n\tif (split == ee_block) {\n\t\t/*\n\t\t * case b: block @split is the block that the extent begins with\n\t\t * then we just change the state of the extent, and splitting\n\t\t * is not needed.\n\t\t */\n\t\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\t\text4_ext_mark_uninitialized(ex);\n\t\telse\n\t\t\text4_ext_mark_initialized(ex);\n\n\t\tif (!(flags & EXT4_GET_BLOCKS_PRE_IO))\n\t\t\text4_ext_try_to_merge(handle, inode, path, ex);\n\n\t\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\t\tgoto out;\n\t}\n\n\t/* case a */\n\tmemcpy(&orig_ex, ex, sizeof(orig_ex));\n\tex->ee_len = cpu_to_le16(split - ee_block);\n\tif (split_flag & EXT4_EXT_MARK_UNINIT1)\n\t\text4_ext_mark_uninitialized(ex);\n\n\t/*\n\t * path may lead to new leaf, not to original leaf any more\n\t * after ext4_ext_insert_extent() returns,\n\t */\n\terr = ext4_ext_dirty(handle, inode, path + depth);\n\tif (err)\n\t\tgoto fix_extent_len;\n\n\tex2 = &newex;\n\tex2->ee_block = cpu_to_le32(split);\n\tex2->ee_len   = cpu_to_le16(ee_len - (split - ee_block));\n\text4_ext_store_pblock(ex2, newblock);\n\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\text4_ext_mark_uninitialized(ex2);\n \n \terr = ext4_ext_insert_extent(handle, inode, path, &newex, flags);\n \tif (err == -ENOSPC && (EXT4_EXT_MAY_ZEROOUT & split_flag)) {\n\t\tif (split_flag & (EXT4_EXT_DATA_VALID1|EXT4_EXT_DATA_VALID2)) {\n\t\t\tif (split_flag & EXT4_EXT_DATA_VALID1)\n\t\t\t\terr = ext4_ext_zeroout(inode, ex2);\n\t\t\telse\n\t\t\t\terr = ext4_ext_zeroout(inode, ex);\n\t\t} else\n\t\t\terr = ext4_ext_zeroout(inode, &orig_ex);\n\n \t\tif (err)\n \t\t\tgoto fix_extent_len;\n \t\t/* update the extent length and mark as initialized */\n\t\tex->ee_len = cpu_to_le16(ee_len);\n\t\text4_ext_try_to_merge(handle, inode, path, ex);\n\t\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\t\tgoto out;\n\t} else if (err)\n\t\tgoto fix_extent_len;\n\nout:\n\text4_ext_show_leaf(inode, path);\n\treturn err;\n\nfix_extent_len:\n\tex->ee_len = orig_ex.ee_len;\n\text4_ext_dirty(handle, inode, path + depth);\n\treturn err;\n}\n",
        "Publish Date": "2012-12-21",
        "Update Date": "2014-01-07",
        "Vulnerability type": "+Info ",
        "commit_url": "https://github.com/torvalds/linux/commit/dee1f973ca341c266229faa5a1a5bb268bed3531",
        "commit_id": "dee1f973ca341c266229faa5a1a5bb268bed3531",
        "commit_message": "ext4: race-condition protection for ext4_convert_unwritten_extents_endio\n\nWe assumed that at the time we call ext4_convert_unwritten_extents_endio()\nextent in question is fully inside [map.m_lblk, map->m_len] because\nit was already split during submission.  But this may not be true due to\na race between writeback vs fallocate.\n\nIf extent in question is larger than requested we will split it again.\nSpecial precautions should being done if zeroout required because\n[map.m_lblk, map->m_len] already contains valid data.\n\nSigned-off-by: Dmitry Monakhov <dmonakhov@openvz.org>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@vger.kernel.org",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-4508",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "fs/ext4/extents.c": "static int ext4_split_unwritten_extents(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\t\tstruct ext4_ext_path *path,\n\t\t\t\t\tint flags)\n{\n\text4_lblk_t eof_block;\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex;\n\tunsigned int ee_len;\n\tint split_flag = 0, depth;\n\n\text_debug(\"ext4_split_unwritten_extents: inode %lu, logical\"\n\t\t\"block %llu, max_blocks %u\\n\", inode->i_ino,\n\t\t(unsigned long long)map->m_lblk, map->m_len);\n\n\teof_block = (inode->i_size + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\tif (eof_block < map->m_lblk + map->m_len)\n\t\teof_block = map->m_lblk + map->m_len;\n\t/*\n\t * It is safe to convert extent to initialized via explicit\n\t * zeroout only if extent is fully insde i_size or new_size.\n\t */\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n \n \tsplit_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;\n \tsplit_flag |= EXT4_EXT_MARK_UNINIT2;\n \tflags |= EXT4_GET_BLOCKS_PRE_IO;\n \treturn ext4_split_extent(handle, inode, path, map, split_flag, flags);\n }\n"
        },
        "vulnerabilities": "Race condition in fs/ext4/extents.c in the Linux kernel before 3.4.16 allows local users to obtain sensitive information from a deleted file by reading an extent that was not properly marked as uninitialized.",
        "annotation": "[Mandatory] ID:\nCVE-2012-4508\n\n[Mandatory] Title: CVE-2012-4508 / CWE-362:\nRace Condition in Ext4 File System\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-12-21 \u2014 Patch release: 2014-01-07\n\n[Optional] Affected products/versions:\nLinux kernel before 3.4.16\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-362: Race Condition\n[Mandatory] Summary:\nThe vulnerability is located in the function ext4_split_unwritten_extents in the ext4 file system code. A race condition allows local users to read uninitialized data from deleted files. This occurs when the extent is not properly marked as uninitialized under certain conditions. If a user can trigger the race condition, they may expose sensitive deleted file information.\n[Mandatory] Root cause:\nThe root cause is a race condition that allows access to uninitialized extents in a concurrent execution context.\n[Mandatory] Attack Surface:\nFile system access.\n[Mandatory] Impact Summary:\nExposure of sensitive information from deleted files.\n[Optional] Trigger / Attack vector:\nLocal user race condition during concurrent access.\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nstatic int ext4_split_unwritten_extents(handle_t *handle,\n        struct inode *inode,\n        struct ext4_map_blocks *map,\n        struct ext4_ext_path *path,\n        int flags)\n{\n    ...\n    if (eof_block < map->m_lblk + map->m_len)\n        eof_block = map->m_lblk + map->m_len;\n    ...\n    return ext4_split_extent(handle, inode, path, map, split_flag, flags);\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nFile system interaction.\n\n[Mandatory] Exploit primitive(s) available:\nRead uninitialized data.\n\n[Mandatory] Exploitability summary (1 sentence):\nExploitation is feasible if multiple threads access the file system concurrently without synchronization.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create a file and write data to it.\n- Delete the file and attempt to access its extents.\n- Trigger multiple concurrent read operations on extents.\n- Successfully read data not intended to be accessible.\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nint main() {\n    // Simulate file deletion and concurrent reads\n    // This is a conceptual example to demonstrate the interaction\n    char buffer[1024];\n    int fd = open(\"deleted_file\", O_RDONLY);\n    read(fd, buffer, sizeof(buffer)); // Attempt to read uninitialized data\n    close(fd);\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nstatic int ext4_split_unwritten_extents(handle_t *handle,\n        struct inode *inode,\n        struct ext4_map_blocks *map,\n        struct ext4_ext_path *path,\n        int flags)\n{\n    ...\n    if (flags & EXT4_GET_BLOCKS_CONVERT)\n        split_flag |= EXT4_EXT_DATA_VALID2;\n    ...\n    return ext4_split_extent(handle, inode, path, map, split_flag, flags);\n}\n```\n\n[Mandatory] Fix summary:\nThe patch introduced a check for the EXT4_GET_BLOCKS_CONVERT flag, ensuring proper marking of extents as valid before processing, preventing sensitive data exposure.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/dee1f973ca341c266229faa5a1a5bb268bed3531\n\n[Optional] Patch Analysis:\nThe fix added specific flags to ensure that extents are addressed safely, thus protecting against concurrent access issues.\n\nField: PatchType (e.g., bounds check added, logic refactor, feature removal)\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other file system functions for similar race conditions.\n- Analyze the impact of concurrent operations across different file systems.\n- Implement additional testing for concurrent access scenarios.\n\n[Optional] Likely variants/impact (one line):\nSimilar vulnerabilities could exist in other parts of the file system code.",
        "tests": "NA",
        "solutions": "static int ext4_split_unwritten_extents(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\t\tstruct ext4_ext_path *path,\n\t\t\t\t\tint flags)\n{\n\text4_lblk_t eof_block;\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex;\n\tunsigned int ee_len;\n\tint split_flag = 0, depth;\n\n\text_debug(\"ext4_split_unwritten_extents: inode %lu, logical\"\n\t\t\"block %llu, max_blocks %u\\n\", inode->i_ino,\n\t\t(unsigned long long)map->m_lblk, map->m_len);\n\n\teof_block = (inode->i_size + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\tif (eof_block < map->m_lblk + map->m_len)\n\t\teof_block = map->m_lblk + map->m_len;\n\t/*\n\t * It is safe to convert extent to initialized via explicit\n\t * zeroout only if extent is fully insde i_size or new_size.\n\t */\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n \n \tsplit_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;\n \tsplit_flag |= EXT4_EXT_MARK_UNINIT2;\n\tif (flags & EXT4_GET_BLOCKS_CONVERT)\n\t\tsplit_flag |= EXT4_EXT_DATA_VALID2;\n \tflags |= EXT4_GET_BLOCKS_PRE_IO;\n \treturn ext4_split_extent(handle, inode, path, map, split_flag, flags);\n }\n",
        "Publish Date": "2012-12-21",
        "Update Date": "2014-01-07",
        "Vulnerability type": "+Info ",
        "commit_url": "https://github.com/torvalds/linux/commit/dee1f973ca341c266229faa5a1a5bb268bed3531",
        "commit_id": "dee1f973ca341c266229faa5a1a5bb268bed3531",
        "commit_message": "ext4: race-condition protection for ext4_convert_unwritten_extents_endio\n\nWe assumed that at the time we call ext4_convert_unwritten_extents_endio()\nextent in question is fully inside [map.m_lblk, map->m_len] because\nit was already split during submission.  But this may not be true due to\na race between writeback vs fallocate.\n\nIf extent in question is larger than requested we will split it again.\nSpecial precautions should being done if zeroout required because\n[map.m_lblk, map->m_len] already contains valid data.\n\nSigned-off-by: Dmitry Monakhov <dmonakhov@openvz.org>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@vger.kernel.org",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-399",
        "CVE": "CVE-2012-4467",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/socket.c": "static int do_siocgstamp(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timeval ktv;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n \terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);\n \tset_fs(old_fs);\n \tif (!err)\n\t\terr = compat_put_timeval(up, &ktv);\n \n \treturn err;\n }\n"
        },
        "vulnerabilities": "The (1) do_siocgstamp and (2) do_siocgstampns functions in net/socket.c in the Linux kernel before 3.5.4 use an incorrect argument order, which allows local users to obtain sensitive information from kernel memory or cause a denial of service (system crash) via a crafted ioctl call.",
        "annotation": "[Mandatory] ID:\nCVE-2012-4467\n\n[Mandatory] Title: CVE-2012-4467 / CWE-399:\nIncorrect Argument Order Leading to Information Disclosure and DoS\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-10 \u2014 Patch release: 2013-01-29\n\n[Optional] Affected products/versions:\nLinux kernel before 3.5.4\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-399: Resource Management Errors\n[Mandatory] Summary:\nThe `do_siocgstamp` function in `net/socket.c` of the Linux kernel has a vulnerability due to the incorrect order of arguments in a call to `compat_put_timeval`, which allows local users to obtain sensitive information from kernel memory or trigger a system crash through crafted ioctl calls. This flaw can lead to denial of service or unauthorized access to sensitive information. The relevant code shows that the user pointer is improperly managed, allowing for such exploitation.\n[Mandatory] Root cause:\nIncorrect argument order in kernel function calls leading to improper access checks.\n[Mandatory] Attack Surface:\nKernel ioctl interface\n[Mandatory] Impact Summary:\nDenial of service + Information disclosure\n[Optional] Trigger / Attack vector:\nCrafted ioctl call\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nstatic int do_siocgstamp(struct net *net, struct socket *sock,\n\t\tunsigned int cmd, void __user *up)\n{\n   mm_segment_t old_fs = get_fs();\n   struct timeval ktv;\n   int err;\n\n   set_fs(KERNEL_DS);\n   err = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);\n   set_fs(old_fs);\n   if (!err)\n       err = compat_put_timeval(up, &ktv);\n\n   return err;\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nKernel ioctl interface\n\n[Mandatory] Exploit primitive(s) available:\nArbitrary read of kernel memory\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit is relatively easy to perform as it only requires a crafted ioctl call, without mitigations in place against this specific attack vector.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Set up a socket in user space\n- Prepare a crafted ioctl command\n- Call the ioctl with user pointer pointing to a buffer\n- Observe the kernel memory being read into the user space buffer\n- Use the extracted information for further attacks (or causing a crash)\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <sys/ioctl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nint main() {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    struct timeval ktv;\n\n    // Prepare a crafted ioctl call\n    if (ioctl(sockfd, SOME_IOCTL_CMD, &ktv) < 0) {\n        perror(\"ioctl failed\");\n    } else {\n        printf(\"Kernel memory read successful!\");\n    }\n    close(sockfd);\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nstatic int do_siocgstamp(struct net *net, struct socket *sock,\n\t\tunsigned int cmd, void __user *up)\n{\n   mm_segment_t old_fs = get_fs();\n   struct timeval ktv;\n   int err;\n\n   set_fs(KERNEL_DS);\n   err = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);\n   set_fs(old_fs);\n   if (!err)\n       err = compat_put_timeval(&ktv, up);\n\n   return err;\n}\n```\n\n[Mandatory] Fix summary:\nThe fix changed the argument order in the call to `compat_put_timeval` to use the appropriate user pointer and kernel stack pointer, which resolves the information disclosure vulnerability.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/ed6fe9d614fc1bca95eb8c0ccd0e92db00ef9d5d\n\n[Optional] Patch Analysis:\nThe fix corrected the order of arguments passed to `compat_put_timeval`, addressing the security flaw that allowed unauthorized access to kernel memory.\n\nField: PatchType (e.g., bounds check added, logic refactor, feature removal)",
        "tests": "NA",
        "solutions": "static int do_siocgstamp(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timeval ktv;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n \terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);\n \tset_fs(old_fs);\n \tif (!err)\n\t\terr = compat_put_timeval(&ktv, up);\n \n \treturn err;\n }\n",
        "Publish Date": "2012-10-10",
        "Update Date": "2013-01-29",
        "Vulnerability type": "DoS +Info ",
        "commit_url": "https://github.com/torvalds/linux/commit/ed6fe9d614fc1bca95eb8c0ccd0e92db00ef9d5d",
        "commit_id": "ed6fe9d614fc1bca95eb8c0ccd0e92db00ef9d5d",
        "commit_message": "Fix order of arguments to compat_put_time[spec|val]\n\nCommit 644595f89620 (\"compat: Handle COMPAT_USE_64BIT_TIME in\nnet/socket.c\") introduced a bug where the helper functions to take\neither a 64-bit or compat time[spec|val] got the arguments in the wrong\norder, passing the kernel stack pointer off as a user pointer (and vice\nversa).\n\nBecause of the user address range check, that in turn then causes an\nEFAULT due to the user pointer range checking failing for the kernel\naddress.  Incorrectly resuling in a failed system call for 32-bit\nprocesses with a 64-bit kernel.\n\nOn odder architectures like HP-PA (with separate user/kernel address\nspaces), it can be used read kernel memory.\n\nSigned-off-by: Mikulas Patocka <mpatocka@redhat.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-399",
        "CVE": "CVE-2012-4467",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/socket.c": "static int do_siocgstampns(struct net *net, struct socket *sock,\n\t\t\t   unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timespec kts;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n \terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);\n \tset_fs(old_fs);\n \tif (!err)\n\t\terr = compat_put_timespec(up, &kts);\n \n \treturn err;\n }\n"
        },
        "vulnerabilities": "The (1) do_siocgstamp and (2) do_siocgstampns functions in net/socket.c in the Linux kernel before 3.5.4 use an incorrect argument order, which allows local users to obtain sensitive information from kernel memory or cause a denial of service (system crash) via a crafted ioctl call.",
        "annotation": "[Mandatory] ID:\nCVE-2012-4467\n\n[Mandatory] Title: CVE-2012-4467 / CWE-399:\nIncorrect Argument Order in ioctl function\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-10 \u2014 Patch release: 2013-01-29\n\n[Optional] Affected products/versions:\nLinux kernel versions before 3.5.4\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-399: Resource Management Errors\n[Mandatory] Summary:\nThe `do_siocgstampns` function in net/socket.c in the Linux kernel allows local users to exploit an incorrect argument order in an ioctl call, which can lead to sensitive information disclosure from kernel memory or cause a denial of service via a system crash. The vulnerability is triggered when the function is called with incorrect parameters that affect memory access. \n[Mandatory] Root cause:\nIncorrect argument order in the function calls leading to mishandled memory addresses.\n[Mandatory] Attack Surface:\nKernel space, socket interface\n[Mandatory] Impact Summary:\nDenial of Service \u2192 Information Disclosure\n[Optional] Trigger / Attack vector:\nCrafted ioctl call\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nstatic int do_siocgstampns(struct net *net, struct socket *sock,\n                            unsigned int cmd, void __user *up)\n{\n    mm_segment_t old_fs = get_fs();\n    struct timespec kts;\n    int err;\n\n    set_fs(KERNEL_DS);\n    err = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);\n    set_fs(old_fs);\n    if (!err)\n        err = compat_put_timespec(up, &kts);\n\n    return err;\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nioctl API\n\n[Mandatory] Exploit primitive(s) available:\nArbitrary read from kernel memory\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit is straightforward for local users with access to socket interfaces, as it relies on incorrect handling of ioctl calls without significant mitigations.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create a socket using the socket library.\n- Prepare a crafted ioctl command with incorrect parameters.\n- Call the `do_siocgstampns` function to invoke the ioctl.\n- Capture the output, potentially accessing sensitive kernel memory.\n- Observe for any denial of service or system crashes.\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <sys/socket.h>\n#include <linux/socket.h>\n#include <unistd.h>\n\nint main() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    unsigned int cmd = /* crafted command */;\n    void *up = /* user pointer, crafted to exploit the flaw */;\n    ioctl(sock, cmd, up);\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nstatic int do_siocgstampns(struct net *net, struct socket *sock,\n                            unsigned int cmd, void __user *up)\n{\n    mm_segment_t old_fs = get_fs();\n    struct timespec kts;\n    int err;\n\n    set_fs(KERNEL_DS);\n    err = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);\n    set_fs(old_fs);\n    if (!err)\n        err = compat_put_timespec(&kts, up);\n\n    return err;\n}\n```\n\n[Mandatory] Fix summary:\nThe patch corrects the argument order in the `compat_put_timespec` call to ensure it receives the right pointers, preventing the disclosure of sensitive information and system crashes.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/ed6fe9d614fc1bca95eb8c0ccd0e92db00ef9d5d\n\n[Optional] Patch Analysis:\nThe fix corrected the order of arguments passed to `compat_put_timespec`, properly configuring the kernel/user memory boundaries.\n\nField: PatchType (e.g., bounds check added, logic refactor, feature removal)\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other ioctl handlers for similar argument order issues.\n- Test compatibility with other architectures, ensuring no variant exists.\n- Perform fuzz testing on related socket calls to uncover other vulnerabilities.\n\n[Optional] Likely variants/impact (one line):\nImproper handling of memory addresses in kernel functions may expose other attack vectors.",
        "tests": "NA",
        "solutions": "static int do_siocgstampns(struct net *net, struct socket *sock,\n\t\t\t   unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timespec kts;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n \terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);\n \tset_fs(old_fs);\n \tif (!err)\n\t\terr = compat_put_timespec(&kts, up);\n \n \treturn err;\n }\n",
        "Publish Date": "2012-10-10",
        "Update Date": "2013-01-29",
        "Vulnerability type": "DoS +Info ",
        "commit_url": "https://github.com/torvalds/linux/commit/ed6fe9d614fc1bca95eb8c0ccd0e92db00ef9d5d",
        "commit_id": "ed6fe9d614fc1bca95eb8c0ccd0e92db00ef9d5d",
        "commit_message": "Fix order of arguments to compat_put_time[spec|val]\n\nCommit 644595f89620 (\"compat: Handle COMPAT_USE_64BIT_TIME in\nnet/socket.c\") introduced a bug where the helper functions to take\neither a 64-bit or compat time[spec|val] got the arguments in the wrong\norder, passing the kernel stack pointer off as a user pointer (and vice\nversa).\n\nBecause of the user address range check, that in turn then causes an\nEFAULT due to the user pointer range checking failing for the kernel\naddress.  Incorrectly resuling in a failed system call for 32-bit\nprocesses with a 64-bit kernel.\n\nOn odder architectures like HP-PA (with separate user/kernel address\nspaces), it can be used read kernel memory.\n\nSigned-off-by: Mikulas Patocka <mpatocka@redhat.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/dccp/ipv4.c": "int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tconst struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\t__be16 orig_sport, orig_dport;\n\t__be32 daddr, nexthop;\n \tstruct flowi4 fl4;\n \tstruct rtable *rt;\n \tint err;\n \n \tdp->dccps_role = DCCP_ROLE_CLIENT;\n \n\tif (addr_len < sizeof(struct sockaddr_in))\n\t\treturn -EINVAL;\n\n\tif (usin->sin_family != AF_INET)\n \t\treturn -EAFNOSUPPORT;\n \n \tnexthop = daddr = usin->sin_addr.s_addr;\n\tif (inet->opt != NULL && inet->opt->srr) {\n \t\tif (daddr == 0)\n \t\t\treturn -EINVAL;\n\t\tnexthop = inet->opt->faddr;\n \t}\n \n \torig_sport = inet->inet_sport;\n\torig_dport = usin->sin_port;\n\trt = ip_route_connect(&fl4, nexthop, inet->inet_saddr,\n\t\t\t      RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,\n\t\t\t      IPPROTO_DCCP,\n\t\t\t      orig_sport, orig_dport, sk, true);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\tif (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {\n\t\tip_rt_put(rt);\n \t\treturn -ENETUNREACH;\n \t}\n \n\tif (inet->opt == NULL || !inet->opt->srr)\n \t\tdaddr = rt->rt_dst;\n \n \tif (inet->inet_saddr == 0)\n\t\tinet->inet_saddr = rt->rt_src;\n\tinet->inet_rcv_saddr = inet->inet_saddr;\n\n\tinet->inet_dport = usin->sin_port;\n \tinet->inet_daddr = daddr;\n \n \tinet_csk(sk)->icsk_ext_hdr_len = 0;\n\tif (inet->opt != NULL)\n\t\tinet_csk(sk)->icsk_ext_hdr_len = inet->opt->optlen;\n \t/*\n \t * Socket identity is still unknown (sport may be zero).\n \t * However we set state to DCCP_REQUESTING and not releasing socket\n\t * lock select source port, enter ourselves into the hash tables and\n\t * complete initialization after this.\n\t */\n\tdccp_set_state(sk, DCCP_REQUESTING);\n\terr = inet_hash_connect(&dccp_death_row, sk);\n\tif (err != 0)\n\t\tgoto failure;\n\n\trt = ip_route_newports(&fl4, rt, orig_sport, orig_dport,\n\t\t\t       inet->inet_sport, inet->inet_dport, sk);\n\tif (IS_ERR(rt)) {\n\t\trt = NULL;\n\t\tgoto failure;\n\t}\n\t/* OK, now commit destination to socket.  */\n\tsk_setup_caps(sk, &rt->dst);\n\n\tdp->dccps_iss = secure_dccp_sequence_number(inet->inet_saddr,\n\t\t\t\t\t\t    inet->inet_daddr,\n\t\t\t\t\t\t    inet->inet_sport,\n\t\t\t\t\t\t    inet->inet_dport);\n\tinet->inet_id = dp->dccps_iss ^ jiffies;\n\n\terr = dccp_connect(sk);\n\trt = NULL;\n\tif (err != 0)\n\t\tgoto failure;\nout:\n\treturn err;\nfailure:\n\t/*\n\t * This unhashes the socket and releases the local port, if necessary.\n\t */\n\tdccp_set_state(sk, DCCP_CLOSED);\n\tip_rt_put(rt);\n\tsk->sk_route_caps = 0;\n\tinet->inet_dport = 0;\n\tgoto out;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in IP implementation\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-362: Race Condition\n[Mandatory] Summary:\nThe Linux kernel's IP implementation has a race condition when handling socket options that may allow attackers to cause a denial of service via crafted packets. This can lead to slab corruption and a system crash, triggered during the `dccp_v4_connect` function when managing socket connections while other threads manipulate socket options concurrently.\n[Mandatory] Root cause:\nImproper synchronization on the `inet->opt` pointer.\n[Mandatory] Attack Surface:\nKernel network service\n[Mandatory] Impact Summary:\nDenial of Service (DoS) due to potential system crash\n[Optional] Trigger / Attack vector:\nSending crafted network packets\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nint dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n    ...\n    if (inet->opt != NULL && inet->opt->srr) {\n        ...\n    }\n    ...\n    if (inet->opt == NULL || !inet->opt->srr)\n        daddr = rt->rt_dst;\n    ...\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nNetwork packet delivery\n\n[Mandatory] Exploit primitive(s) available:\nDenial of Service (DoS)\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit is feasible due to the race condition in the socket option handling, which can be triggered easily by sending specific packets.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create a socket and bind it to an address.\n- Set socket options that will interact with others.\n- Rapidly send packets to the socket.\n- Simultaneously modify socket options to trigger race condition.\n- Observe system behavior for crashes or instability.\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <stdio.h>\n\nint main() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    struct sockaddr_in addr;\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(12345); // use an appropriate port\n    addr.sin_addr.s_addr = INADDR_ANY;\n\n    bind(sock, (struct sockaddr *)&addr, sizeof(addr));\n    // Here send packets looping while changing socket options\n    // This triggers the vulnerability as described \n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nint dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n    ...\n    inet_opt = rcu_dereference_protected(inet->inet_opt, sock_owned_by_user(sk));\n    ...\n}\n```\n\n[Mandatory] Fix summary:\nThe fix introduced RCU protection for the `inet->opt` pointer, ensuring that concurrent modifications do not lead to race conditions during socket option handling.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\n[Optional] Patch Analysis:\nThis patch added RCU protection, ensuring safe access to socket options without risking data races by synchronizing access across potentially conflicting threads.\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other socket connection handling methods for similar race conditions.\n- Analyze network traffic patterns that lead to DoS.\n- Examine other protocols in the kernel for potential analogous issues. \n\n[Optional] Likely variants/impact (one line):\nExploits similar vulnerabilities in other networking protocols may lead to additional DoS capabilities.",
        "tests": "NA",
        "solutions": "int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tconst struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\t__be16 orig_sport, orig_dport;\n\t__be32 daddr, nexthop;\n \tstruct flowi4 fl4;\n \tstruct rtable *rt;\n \tint err;\n\tstruct ip_options_rcu *inet_opt;\n \n \tdp->dccps_role = DCCP_ROLE_CLIENT;\n \n\tif (addr_len < sizeof(struct sockaddr_in))\n\t\treturn -EINVAL;\n\n\tif (usin->sin_family != AF_INET)\n \t\treturn -EAFNOSUPPORT;\n \n \tnexthop = daddr = usin->sin_addr.s_addr;\n\n\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t     sock_owned_by_user(sk));\n\tif (inet_opt != NULL && inet_opt->opt.srr) {\n \t\tif (daddr == 0)\n \t\t\treturn -EINVAL;\n\t\tnexthop = inet_opt->opt.faddr;\n \t}\n \n \torig_sport = inet->inet_sport;\n\torig_dport = usin->sin_port;\n\trt = ip_route_connect(&fl4, nexthop, inet->inet_saddr,\n\t\t\t      RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,\n\t\t\t      IPPROTO_DCCP,\n\t\t\t      orig_sport, orig_dport, sk, true);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\tif (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {\n\t\tip_rt_put(rt);\n \t\treturn -ENETUNREACH;\n \t}\n \n\tif (inet_opt == NULL || !inet_opt->opt.srr)\n \t\tdaddr = rt->rt_dst;\n \n \tif (inet->inet_saddr == 0)\n\t\tinet->inet_saddr = rt->rt_src;\n\tinet->inet_rcv_saddr = inet->inet_saddr;\n\n\tinet->inet_dport = usin->sin_port;\n \tinet->inet_daddr = daddr;\n \n \tinet_csk(sk)->icsk_ext_hdr_len = 0;\n\tif (inet_opt)\n\t\tinet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen;\n \t/*\n \t * Socket identity is still unknown (sport may be zero).\n \t * However we set state to DCCP_REQUESTING and not releasing socket\n\t * lock select source port, enter ourselves into the hash tables and\n\t * complete initialization after this.\n\t */\n\tdccp_set_state(sk, DCCP_REQUESTING);\n\terr = inet_hash_connect(&dccp_death_row, sk);\n\tif (err != 0)\n\t\tgoto failure;\n\n\trt = ip_route_newports(&fl4, rt, orig_sport, orig_dport,\n\t\t\t       inet->inet_sport, inet->inet_dport, sk);\n\tif (IS_ERR(rt)) {\n\t\trt = NULL;\n\t\tgoto failure;\n\t}\n\t/* OK, now commit destination to socket.  */\n\tsk_setup_caps(sk, &rt->dst);\n\n\tdp->dccps_iss = secure_dccp_sequence_number(inet->inet_saddr,\n\t\t\t\t\t\t    inet->inet_daddr,\n\t\t\t\t\t\t    inet->inet_sport,\n\t\t\t\t\t\t    inet->inet_dport);\n\tinet->inet_id = dp->dccps_iss ^ jiffies;\n\n\terr = dccp_connect(sk);\n\trt = NULL;\n\tif (err != 0)\n\t\tgoto failure;\nout:\n\treturn err;\nfailure:\n\t/*\n\t * This unhashes the socket and releases the local port, if necessary.\n\t */\n\tdccp_set_state(sk, DCCP_CLOSED);\n\tip_rt_put(rt);\n\tsk->sk_route_caps = 0;\n\tinet->inet_dport = 0;\n\tgoto out;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/dccp/ipv4.c": "struct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t       struct request_sock *req,\n\t\t\t\t       struct dst_entry *dst)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct sock *newsk;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto exit_overflow;\n\n\tif (dst == NULL && (dst = inet_csk_route_req(sk, req)) == NULL)\n\t\tgoto exit;\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto exit_nonewsk;\n\n\tsk_setup_caps(newsk, dst);\n\n\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n \tnewinet->inet_daddr\t= ireq->rmt_addr;\n \tnewinet->inet_rcv_saddr = ireq->loc_addr;\n \tnewinet->inet_saddr\t= ireq->loc_addr;\n\tnewinet->opt\t   = ireq->opt;\n \tireq->opt\t   = NULL;\n \tnewinet->mc_index  = inet_iif(skb);\n \tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tnewinet->inet_id   = jiffies;\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;\n\t}\n\t__inet_hash_nolisten(newsk, NULL);\n\n\treturn newsk;\n\nexit_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in Linux kernel\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel versions prior to 3.0\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-362: Race condition\n[Mandatory] Summary:\nA race condition exists in the IP implementation of the Linux kernel that allows remote attackers to send packets to an application manipulating socket options during network traffic handling, potentially causing a denial of service through slab corruption or system crashes. This is triggered in the `dccp_v4_request_recv_sock` function when the socket options are accessed without proper synchronization. \n[Mandatory] Root cause:\nImproper synchronization in accessing socket option structures leading to potential concurrent modifications.\n[Mandatory] Attack Surface:\nKernel network stack\n[Mandatory] Impact Summary:\nDenial of Service (DoS) due to slab corruption\n[Optional] Trigger / Attack vector:\nSending crafted network packets\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nstruct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb,\n...\nnewinet->inet_opt   = ireq->opt;  // Potential race condition here\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nNetwork packets\n\n[Mandatory] Exploit primitive(s) available:\nRace condition leading to denial of service\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit is relatively straightforward as an attacker only needs to send crafted packets to trigger the vulnerability under specific conditions.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create a socket for communication\n- Send crafted packets to the socket during option handling\n- Observe system behavior and potential crash or instability\n- Loop the sending to maximize impact\n- Monitor the response and system health\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\nint main() {\n    int sock = socket(AF_INET, SOCK_DCCP, 0);\n    // Code to send malformed packets that trigger the race condition\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nstruct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb,\n...\nnewinet->inet_opt   = ireq->opt; // Fixed synchronization to ensure safe access\n```\n\n[Mandatory] Fix summary:\nThe patch introduces RCU protection to the manipulation of socket option structures to prevent concurrent access issues that lead to race conditions.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\n[Optional] Patch Analysis:\nThe fix ensures that access to `inet->opt` is properly synchronized via RCU, preventing one thread from modifying it while another is using it.\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other socket option handling functions for similar race conditions\n- Conduct fuzz testing on network traffic to identify other potential issues\n- Analyze the locking mechanisms in related modules for robustness\n\n[Optional] Likely variants/impact (one line):\nSimilar race conditions might exist in other parts of the kernel handling concurrent network operations.",
        "tests": "NA",
        "solutions": "struct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t       struct request_sock *req,\n\t\t\t\t       struct dst_entry *dst)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct sock *newsk;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto exit_overflow;\n\n\tif (dst == NULL && (dst = inet_csk_route_req(sk, req)) == NULL)\n\t\tgoto exit;\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto exit_nonewsk;\n\n\tsk_setup_caps(newsk, dst);\n\n\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n \tnewinet->inet_daddr\t= ireq->rmt_addr;\n \tnewinet->inet_rcv_saddr = ireq->loc_addr;\n \tnewinet->inet_saddr\t= ireq->loc_addr;\n\tnewinet->inet_opt\t= ireq->opt;\n \tireq->opt\t   = NULL;\n \tnewinet->mc_index  = inet_iif(skb);\n \tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tnewinet->inet_id   = jiffies;\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;\n\t}\n\t__inet_hash_nolisten(newsk, NULL);\n\n\treturn newsk;\n\nexit_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/dccp/ipv6.c": "static struct sock *dccp_v6_request_recv_sock(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct request_sock *req,\n\t\t\t\t\t      struct dst_entry *dst)\n{\n\tstruct inet6_request_sock *ireq6 = inet6_rsk(req);\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct inet_sock *newinet;\n\tstruct dccp6_sock *newdp6;\n\tstruct sock *newsk;\n\tstruct ipv6_txoptions *opt;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\t\tnewsk = dccp_v4_request_recv_sock(sk, skb, req, dst);\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewdp6 = (struct dccp6_sock *)newsk;\n\t\tnewinet = inet_sk(newsk);\n\t\tnewinet->pinet6 = &newdp6->inet6;\n\t\tnewnp = inet6_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_daddr, &newnp->daddr);\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_saddr, &newnp->saddr);\n\n\t\tipv6_addr_copy(&newnp->rcv_saddr, &newnp->saddr);\n\n\t\tinet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = dccp_v4_do_rcv;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = inet6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, dccp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\tdccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\topt = np->opt;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (dst == NULL) {\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = IPPROTO_DCCP;\n\t\tipv6_addr_copy(&fl6.daddr, &ireq6->rmt_addr);\n\t\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\t\tipv6_addr_copy(&fl6.saddr, &ireq6->loc_addr);\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.fl6_dport = inet_rsk(req)->rmt_port;\n\t\tfl6.fl6_sport = inet_rsk(req)->loc_port;\n\t\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p, false);\n\t\tif (IS_ERR(dst))\n\t\t\tgoto out;\n\t}\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, dccp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\tnewsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |\n\t\t\t\t\t\t      NETIF_F_TSO);\n\tnewdp6 = (struct dccp6_sock *)newsk;\n\tnewinet = inet_sk(newsk);\n\tnewinet->pinet6 = &newdp6->inet6;\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tipv6_addr_copy(&newnp->daddr, &ireq6->rmt_addr);\n\tipv6_addr_copy(&newnp->saddr, &ireq6->loc_addr);\n\tipv6_addr_copy(&newnp->rcv_saddr, &ireq6->loc_addr);\n\tnewsk->sk_bound_dev_if = ireq6->iif;\n\n\t/* Now IPv6 options...\n \n \t   First: no IPv4 options.\n \t */\n\tnewinet->opt = NULL;\n \n \t/* Clone RX bits */\n \tnewnp->rxopt.all = np->rxopt.all;\n\n\t/* Clone pktoptions received with SYN */\n\tnewnp->pktoptions = NULL;\n\tif (ireq6->pktopts != NULL) {\n\t\tnewnp->pktoptions = skb_clone(ireq6->pktopts, GFP_ATOMIC);\n\t\tkfree_skb(ireq6->pktopts);\n\t\tireq6->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t/*\n\t * Clone native IPv6 options from listening socket (if any)\n\t *\n\t * Yes, keeping reference count would be much more clever, but we make\n\t * one more one thing there: reattach optmem to newsk.\n\t */\n\tif (opt != NULL) {\n\t\tnewnp->opt = ipv6_dup_options(newsk, opt);\n\t\tif (opt != np->opt)\n\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\t}\n\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt != NULL)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto out;\n\t}\n\t__inet6_hash(newsk, NULL);\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\tif (opt != NULL && opt != np->opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\treturn NULL;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in socket option handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-362: Race condition\n[Mandatory] Summary:\nThe vulnerability in the Linux kernel's IP implementation allows a race condition when handling socket options, which could lead to denial of service via slab corruption and system crashes. This occurs in the function `dccp_v6_request_recv_sock`, particularly when socket options are set while packets are received. An example of this can be seen where the code attempts to sync handling between IPv4 and IPv6 sockets, leading to potential race conditions due to lack of proper synchronization.\n[Mandatory] Root cause:\nImproper synchronization while manipulating socket options\n[Mandatory] Attack Surface:\nKernel network stack\n[Mandatory] Impact Summary:\nDenial of Service (DoS)\n[Optional] Trigger / Attack vector:\nMalformed network packets\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nstatic struct sock *dccp_v6_request_recv_sock(struct sock *sk,\n                struct sk_buff *skb,\n                struct request_sock *req,\n                struct dst_entry *dst)\n{\n    struct inet6_request_sock *ireq6 = inet6_rsk(req);\n    struct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n    // ... additional code ...\n    if (dst == NULL) {\n        struct flowi6 fl6;\n        // ... additional code ...\n        dst = ip6_dst_lookup_flow(sk, &fl6, final_p, false);\n        if (IS_ERR(dst))\n            goto out;\n    }\n    // ... additional code ...\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nNetwork packet manipulation\n\n[Mandatory] Exploit primitive(s) available:\nDenial of service via packet injection\n\n[Mandatory] Exploitability summary (1 sentence):\nAn attacker can exploit this vulnerability with crafted packets to achieve denial of service, particularly in environments where IP options are being altered in parallel.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Send crafted packets to a target application.\n- Ensure the application processes socket options concurrently.\n- Monitor for system crashes or instability.\n- Repeat to increase likelihood of successful exploitation.\n- Error handling in the script to catch disruptions.\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <string.h>\n#include <arpa/inet.h>\n\nint main() {\n    // Pseudocode for sending crafted packets to trigger the flaw\n    // Set up raw socket with appropriate options\n    // Send packets with altered socket options\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nstatic struct sock *dccp_v6_request_recv_sock(struct sock *sk,\n                struct sk_buff *skb,\n                struct request_sock *req,\n                struct dst_entry *dst)\n{\n    // Implementation adjusted for RCU protection\n    // \u201cNew\u201d handling to synchronize access to inet->opt\n}\n```\n\n[Mandatory] Fix summary:\nThe patch added RCU protection to socket option manipulation, ensuring that changes to `inet->opt` are thread-safe, thus preventing race conditions.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\n[Optional] Patch Analysis:\nThe fix implemented RCU to protect `inet->opt`, allowing safe concurrent modifications without risking the crashing of the kernel due to race conditions.\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other socket option handlers for similar race conditions.\n- Conduct performance testing under high-load scenarios.\n- Analyze historical issues in older kernel versions.\n\n[Optional] Likely variants/impact (one line):\nPotential impact on various networking features utilizing socket options.",
        "tests": "NA",
        "solutions": "static struct sock *dccp_v6_request_recv_sock(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct request_sock *req,\n\t\t\t\t\t      struct dst_entry *dst)\n{\n\tstruct inet6_request_sock *ireq6 = inet6_rsk(req);\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct inet_sock *newinet;\n\tstruct dccp6_sock *newdp6;\n\tstruct sock *newsk;\n\tstruct ipv6_txoptions *opt;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\t\tnewsk = dccp_v4_request_recv_sock(sk, skb, req, dst);\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewdp6 = (struct dccp6_sock *)newsk;\n\t\tnewinet = inet_sk(newsk);\n\t\tnewinet->pinet6 = &newdp6->inet6;\n\t\tnewnp = inet6_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_daddr, &newnp->daddr);\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_saddr, &newnp->saddr);\n\n\t\tipv6_addr_copy(&newnp->rcv_saddr, &newnp->saddr);\n\n\t\tinet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = dccp_v4_do_rcv;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = inet6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, dccp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\tdccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\topt = np->opt;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (dst == NULL) {\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = IPPROTO_DCCP;\n\t\tipv6_addr_copy(&fl6.daddr, &ireq6->rmt_addr);\n\t\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\t\tipv6_addr_copy(&fl6.saddr, &ireq6->loc_addr);\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.fl6_dport = inet_rsk(req)->rmt_port;\n\t\tfl6.fl6_sport = inet_rsk(req)->loc_port;\n\t\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p, false);\n\t\tif (IS_ERR(dst))\n\t\t\tgoto out;\n\t}\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, dccp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\tnewsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |\n\t\t\t\t\t\t      NETIF_F_TSO);\n\tnewdp6 = (struct dccp6_sock *)newsk;\n\tnewinet = inet_sk(newsk);\n\tnewinet->pinet6 = &newdp6->inet6;\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tipv6_addr_copy(&newnp->daddr, &ireq6->rmt_addr);\n\tipv6_addr_copy(&newnp->saddr, &ireq6->loc_addr);\n\tipv6_addr_copy(&newnp->rcv_saddr, &ireq6->loc_addr);\n\tnewsk->sk_bound_dev_if = ireq6->iif;\n\n\t/* Now IPv6 options...\n \n \t   First: no IPv4 options.\n \t */\n\tnewinet->inet_opt = NULL;\n \n \t/* Clone RX bits */\n \tnewnp->rxopt.all = np->rxopt.all;\n\n\t/* Clone pktoptions received with SYN */\n\tnewnp->pktoptions = NULL;\n\tif (ireq6->pktopts != NULL) {\n\t\tnewnp->pktoptions = skb_clone(ireq6->pktopts, GFP_ATOMIC);\n\t\tkfree_skb(ireq6->pktopts);\n\t\tireq6->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t/*\n\t * Clone native IPv6 options from listening socket (if any)\n\t *\n\t * Yes, keeping reference count would be much more clever, but we make\n\t * one more one thing there: reattach optmem to newsk.\n\t */\n\tif (opt != NULL) {\n\t\tnewnp->opt = ipv6_dup_options(newsk, opt);\n\t\tif (opt != np->opt)\n\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\t}\n\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt != NULL)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto out;\n\t}\n\t__inet6_hash(newsk, NULL);\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\tif (opt != NULL && opt != np->opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\treturn NULL;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/af_inet.c": "int inet_sk_rebuild_header(struct sock *sk)\n{\n \tstruct inet_sock *inet = inet_sk(sk);\n \tstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\n \t__be32 daddr;\n \tint err;\n \n \t/* Route is OK, nothing to do. */\n \tif (rt)\n \t\treturn 0;\n \n \t/* Reroute. */\n \tdaddr = inet->inet_daddr;\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n \trt = ip_route_output_ports(sock_net(sk), sk, daddr, inet->inet_saddr,\n \t\t\t\t   inet->inet_dport, inet->inet_sport,\n \t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t   sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt)) {\n\t\terr = 0;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t} else {\n\t\terr = PTR_ERR(rt);\n\n\t\t/* Routing failed... */\n\t\tsk->sk_route_caps = 0;\n\t\t/*\n\t\t * Other protocols have to map its equivalent state to TCP_SYN_SENT.\n\t\t * DCCP maps its DCCP_REQUESTING state to TCP_SYN_SENT. -acme\n\t\t */\n\t\tif (!sysctl_ip_dynaddr ||\n\t\t    sk->sk_state != TCP_SYN_SENT ||\n\t\t    (sk->sk_userlocks & SOCK_BINDADDR_LOCK) ||\n\t\t    (err = inet_sk_reselect_saddr(sk)) != 0)\n\t\t\tsk->sk_err_soft = -err;\n\t}\n\n\treturn err;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in socket option handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-362: Race Condition\n[Mandatory] Summary:\nA race condition in the IP implementation of the Linux kernel allows remote attackers to cause a denial of service through slab corruption and system crashes. This occurs when packets are sent to applications that are modifying socket options while handling network traffic, leading to unprotected access to shared data structures in the code excerpt. \n[Mandatory] Root cause:\nImproper synchronization when accessing the `inet->opt` structure leads to race conditions.\n[Mandatory] Attack Surface:\nNetwork service\n[Mandatory] Impact Summary:\nDenial of Service (DoS)\n[Optional] Trigger / Attack vector:\nSending packets during socket option modifications\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nint inet_sk_rebuild_header(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\n\t__be32 daddr;\n\tint err;\n\n\tif (rt)\n\t\treturn 0;\n\n\tdaddr = inet->inet_daddr;\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n\trt = ip_route_output_ports(sock_net(sk), sk, daddr, inet->inet_saddr,\n\t\tinet->inet_dport, inet->inet_sport,\n\t\tsk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\tsk->sk_bound_dev_if);\n\tif (!IS_ERR(rt)) {\n\t\terr = 0;\n\t}\n``` \n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nNetwork packets\n\n[Mandatory] Exploit primitive(s) available:\nDenial of Service via race condition\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit is straightforward due to the nature of the race condition in socket handling, compromising network stability.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Set up a socket for communication\n- Simultaneously modify socket options\n- Send crafted packets to the socket\n- Trigger the race condition\n- Monitor for system instability or crashes\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n// Example to demonstrate sending while modifying options\nint main() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    struct sockaddr_in server;\n    server.sin_family = AF_INET;\n    server.sin_port = htons(12345);\n    inet_pton(AF_INET, \"192.168.1.1\", &server.sin_addr);\n    connect(sock, (struct sockaddr *)&server, sizeof(server));\n    // Temporarily set socket options\n    int opt = 1;\n    setsockopt(sock, IPPROTO_IP, IP_MULTICAST_LOOP, &opt, sizeof(opt));\n    // Send packets while manipulating socket options\n    send(sock, \"attack payload\", sizeof(\"attack payload\"), 0);\n    close(sock);\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nint inet_sk_rebuild_header(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\n\t__be32 daddr;\n\tstruct ip_options_rcu *inet_opt;\n\tint err;\n\n\tif (rt)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tdaddr = inet->inet_daddr;\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trcu_read_unlock();\n\trt = ip_route_output_ports(sock_net(sk), sk, daddr, inet->inet_saddr,\n\t\tinet->inet_dport, inet->inet_sport,\n\t\tsk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\tsk->sk_bound_dev_if);\n\tif (!IS_ERR(rt)) {\n\t\terr = 0;\n\t}\n```\n\n[Mandatory] Fix summary:\nThe fix introduces RCU (Read-Copy-Update) locking to safely access shared resources, preventing race conditions regarding socket options during network handling.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\n[Optional] Patch Analysis:\nThe fix added RCU protection for the `inet->opt` to synchronize access across threads and ensure consistent data handling without race conditions.",
        "tests": "NA",
        "solutions": "int inet_sk_rebuild_header(struct sock *sk)\n{\n \tstruct inet_sock *inet = inet_sk(sk);\n \tstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\n \t__be32 daddr;\n\tstruct ip_options_rcu *inet_opt;\n \tint err;\n \n \t/* Route is OK, nothing to do. */\n \tif (rt)\n \t\treturn 0;\n \n \t/* Reroute. */\n\trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n \tdaddr = inet->inet_daddr;\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trcu_read_unlock();\n \trt = ip_route_output_ports(sock_net(sk), sk, daddr, inet->inet_saddr,\n \t\t\t\t   inet->inet_dport, inet->inet_sport,\n \t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t   sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt)) {\n\t\terr = 0;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t} else {\n\t\terr = PTR_ERR(rt);\n\n\t\t/* Routing failed... */\n\t\tsk->sk_route_caps = 0;\n\t\t/*\n\t\t * Other protocols have to map its equivalent state to TCP_SYN_SENT.\n\t\t * DCCP maps its DCCP_REQUESTING state to TCP_SYN_SENT. -acme\n\t\t */\n\t\tif (!sysctl_ip_dynaddr ||\n\t\t    sk->sk_state != TCP_SYN_SENT ||\n\t\t    (sk->sk_userlocks & SOCK_BINDADDR_LOCK) ||\n\t\t    (err = inet_sk_reselect_saddr(sk)) != 0)\n\t\t\tsk->sk_err_soft = -err;\n\t}\n\n\treturn err;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/af_inet.c": "static int inet_sk_reselect_saddr(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__be32 old_saddr = inet->inet_saddr;\n\t__be32 daddr = inet->inet_daddr;\n \tstruct flowi4 fl4;\n \tstruct rtable *rt;\n \t__be32 new_saddr;\n \n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n \n \t/* Query new route. */\n \trt = ip_route_connect(&fl4, daddr, 0, RT_CONN_FLAGS(sk),\n\t\t\t      sk->sk_bound_dev_if, sk->sk_protocol,\n\t\t\t      inet->inet_sport, inet->inet_dport, sk, false);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\tsk_setup_caps(sk, &rt->dst);\n\n\tnew_saddr = rt->rt_src;\n\n\tif (new_saddr == old_saddr)\n\t\treturn 0;\n\n\tif (sysctl_ip_dynaddr > 1) {\n\t\tprintk(KERN_INFO \"%s(): shifting inet->saddr from %pI4 to %pI4\\n\",\n\t\t       __func__, &old_saddr, &new_saddr);\n\t}\n\n\tinet->inet_saddr = inet->inet_rcv_saddr = new_saddr;\n\n\t/*\n\t * XXX The only one ugly spot where we need to\n\t * XXX really change the sockets identity after\n\t * XXX it has entered the hashes. -DaveM\n\t *\n\t * Besides that, it does not check for connection\n\t * uniqueness. Wait for troubles.\n\t */\n\t__sk_prot_rehash(sk);\n\treturn 0;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in the IP implementation\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-362: Race Condition\n[Mandatory] Summary:\nThe vulnerability is located in the function inet_sk_reselect_saddr, which processes incoming packets. A race condition occurs when multiple threads manipulate socket options concurrently. An attacker can exploit this flaw by sending crafted packets to trigger a denial of service, leading to slab corruption and system crashes.\n[Mandatory] Root cause:\nImproper synchronization allowing concurrent access to socket options.\n[Mandatory] Attack Surface:\nNetwork service\n[Mandatory] Impact Summary:\nDenial of Service (DoS) \n[Optional] Trigger / Attack vector:\nSending packets that manipulate socket options\n[Mandatory] Key code/struct excerpt (minimal):\nstatic int inet_sk_reselect_saddr(struct sock *sk)\n{\n    struct inet_sock *inet = inet_sk(sk);\n    __be32 old_saddr = inet->inet_saddr;\n    __be32 daddr = inet->inet_daddr;\n    struct flowi4 fl4;\n    struct rtable *rt;\n    __be32 new_saddr;\n\n    if (inet->opt && inet->opt->srr)\n        daddr = inet->opt->faddr;\n\n    /* Query new route. */\n    rt = ip_route_connect(&fl4, daddr, 0, RT_CONN_FLAGS(sk),\n              sk->sk_bound_dev_if, sk->sk_protocol,\n              inet->inet_sport, inet->inet_dport, sk, false);\n    if (IS_ERR(rt))\n        return PTR_ERR(rt);\n\n    sk_setup_caps(sk, &rt->dst);\n\n    new_saddr = rt->rt_src;\n    if (new_saddr == old_saddr)\n        return 0;\n    \n    __sk_prot_rehash(sk);\n    return 0;\n}\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nAPI\n\n[Mandatory] Exploit primitive(s) available:\nDenial of service via crafted packets\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit is relatively straightforward for an attacker, as it only requires sending specific network packets while a socket option change is in progress.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create a socket and configure it to receive packets.\n- Begin a thread to modify socket options during the packet handling.\n- Send crafted packets to the target application.\n- Trigger simultaneous access to socket options.\n- Observe the resulting crash or instability in the application.\n\n[Mandatory] Exploitation Example script payload code:\nimport socket\nimport threading\nimport time\n\ndef modify_socket_options(sock):\n    while True:\n        # Placeholder for modifying socket options\n        time.sleep(0.1)\n\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.bind(('localhost', 12345))\nthreading.Thread(target=modify_socket_options, args=(sock,)).start()\n\nfor i in range(100):\n    sock.sendto(b'Attack packet', ('localhost', 12346))\n\nFix\n[Mandatory] Fix code:\nstatic int inet_sk_reselect_saddr(struct sock *sk)\n{\n    struct inet_sock *inet = inet_sk(sk);\n    __be32 old_saddr = inet->inet_saddr;\n    __be32 daddr = inet->inet_daddr;\n    struct flowi4 fl4;\n    struct rtable *rt;\n    __be32 new_saddr;\n    struct ip_options_rcu *inet_opt;\n\n    inet_opt = rcu_dereference_protected(inet->inet_opt,\n                     sock_owned_by_user(sk));\n    if (inet_opt && inet_opt->opt.srr)\n        daddr = inet_opt->opt.faddr;\n\n    /* Query new route. */\n    rt = ip_route_connect(&fl4, daddr, 0, RT_CONN_FLAGS(sk),\n              sk->sk_bound_dev_if, sk->sk_protocol,\n              inet->inet_sport, inet->inet_dport, sk, false);\n    if (IS_ERR(rt))\n        return PTR_ERR(rt);\n\n    sk_setup_caps(sk, &rt->dst);\n\n    new_saddr = rt->rt_src;\n    if (new_saddr == old_saddr)\n        return 0;\n\n    inet->inet_saddr = inet->inet_rcv_saddr = new_saddr;\n    __sk_prot_rehash(sk);\n    return 0;\n}\n\n[Mandatory] Fix summary:\nThe patch adds RCU protection to the manipulation of the inet->opt socket options, ensuring safe access during concurrent operations.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\n[Optional] Patch Analysis:\nThe fix introduces RCU synchronization for ip_options, preventing corruption when accessed by multiple threads simultaneously.\n\nField: PatchType (e.g., bounds check added, logic refactor, feature removal)\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other socket handling functions for similar race conditions.\n- Test for concurrent access in other networking modules.\n- Analyze low-level socket options manipulation for thread safety.\n\n[Optional] Likely variants/impact (one line):\nPotential for similar issues in other protocol implementations.",
        "tests": "NA",
        "solutions": "static int inet_sk_reselect_saddr(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__be32 old_saddr = inet->inet_saddr;\n\t__be32 daddr = inet->inet_daddr;\n \tstruct flowi4 fl4;\n \tstruct rtable *rt;\n \t__be32 new_saddr;\n\tstruct ip_options_rcu *inet_opt;\n \n\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t     sock_owned_by_user(sk));\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n \n \t/* Query new route. */\n \trt = ip_route_connect(&fl4, daddr, 0, RT_CONN_FLAGS(sk),\n\t\t\t      sk->sk_bound_dev_if, sk->sk_protocol,\n\t\t\t      inet->inet_sport, inet->inet_dport, sk, false);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\tsk_setup_caps(sk, &rt->dst);\n\n\tnew_saddr = rt->rt_src;\n\n\tif (new_saddr == old_saddr)\n\t\treturn 0;\n\n\tif (sysctl_ip_dynaddr > 1) {\n\t\tprintk(KERN_INFO \"%s(): shifting inet->saddr from %pI4 to %pI4\\n\",\n\t\t       __func__, &old_saddr, &new_saddr);\n\t}\n\n\tinet->inet_saddr = inet->inet_rcv_saddr = new_saddr;\n\n\t/*\n\t * XXX The only one ugly spot where we need to\n\t * XXX really change the sockets identity after\n\t * XXX it has entered the hashes. -DaveM\n\t *\n\t * Besides that, it does not check for connection\n\t * uniqueness. Wait for troubles.\n\t */\n\t__sk_prot_rehash(sk);\n\treturn 0;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/af_inet.c": "void inet_sock_destruct(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_error_queue);\n\n\tsk_mem_reclaim(sk);\n\n\tif (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {\n\t\tpr_err(\"Attempt to release TCP socket in state %d %p\\n\",\n\t\t       sk->sk_state, sk);\n\t\treturn;\n\t}\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n \tWARN_ON(sk->sk_wmem_queued);\n \tWARN_ON(sk->sk_forward_alloc);\n \n\tkfree(inet->opt);\n \tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n \tsk_refcnt_debug_dec(sk);\n }\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in the IP implementation\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-362 (Race Condition)\n[Mandatory] Summary:\nA race condition in the `inet_sock_destruct` function in the Linux kernel allows remote attackers to cause a denial of service by sending packets to an application that sets socket options during network traffic handling. This vulnerability is particularly exploitable when a socket is released while being used, leading to slab corruption and potential system crashes.\n[Mandatory] Root cause:\nImproper synchronization when manipulating the `inet->opt` structure can lead to concurrent modifications by multiple threads.\n[Mandatory] Attack Surface:\nKernel networking stack\n[Mandatory] Impact Summary:\nDenial of Service (DoS)\n[Optional] Trigger / Attack vector:\nSending crafted packets to a vulnerable application\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nvoid inet_sock_destruct(struct sock *sk)\n{\n    struct inet_sock *inet = inet_sk(sk);\n\n    if (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {\n        pr_err(\"Attempt to release TCP socket in state %d %p\\n\", sk->sk_state, sk);\n        return;\n    }\n    if (!sock_flag(sk, SOCK_DEAD)) {\n        pr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n        return;\n    }\n\n    kfree(inet->opt);\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nNetwork packets\n\n[Mandatory] Exploit primitive(s) available:\nAccessing freed memory\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit is straightforward; attackers can repeatedly send crafted packets to trigger the vulnerability, resulting in a system crash.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Setup a socket to listen for incoming packets.\n- Send multiple packets with manipulated options.\n- Simultaneously attempt to modify socket options within the application.\n- Observe for crashes or instability as a result of the race condition.\n\n[Mandatory] Exploitation Example script payload code:\n```c\n// Example exploit script\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n// Function to send packets causing DoS\nvoid send_packets() {\n    // Code to send crafted packets\n}\nint main() {\n    // Setup socket and begin sending packets\n    send_packets();\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nvoid inet_sock_destruct(struct sock *sk)\n{\n    struct inet_sock *inet = inet_sk(sk);\n    \n    if (!sock_flag(sk, SOCK_DEAD)) {\n        pr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n        return;\n    }\n\n    kfree(rcu_dereference_protected(inet->inet_opt, 1));\n}\n```\n\n[Mandatory] Fix summary:\nThe patch adds RCU protection when accessing `inet->opt`, preventing concurrent modifications that could lead to a race condition.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\n[Optional] Patch Analysis:\nThe fix ensures proper synchronization for `inet->opt`, preventing race conditions by replacing direct access with RCU-protected access.\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other socket handling functions for similar race conditions.\n- Perform stress testing on the IP stack with concurrent connections.\n- Analyze patch history for related race condition vulnerabilities.\n\n[Optional] Likely variants/impact (one line):\nSimilar race condition vulnerabilities may exist in other socket operations.",
        "tests": "NA",
        "solutions": "void inet_sock_destruct(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_error_queue);\n\n\tsk_mem_reclaim(sk);\n\n\tif (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {\n\t\tpr_err(\"Attempt to release TCP socket in state %d %p\\n\",\n\t\t       sk->sk_state, sk);\n\t\treturn;\n\t}\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n \tWARN_ON(sk->sk_wmem_queued);\n \tWARN_ON(sk->sk_forward_alloc);\n \n\tkfree(rcu_dereference_protected(inet->inet_opt, 1));\n \tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n \tsk_refcnt_debug_dec(sk);\n }\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/cipso_ipv4.c": "static int cipso_v4_delopt(struct ip_options **opt_ptr)\n {\n \tint hdr_delta = 0;\n\tstruct ip_options *opt = *opt_ptr;\n \n\tif (opt->srr || opt->rr || opt->ts || opt->router_alert) {\n \t\tu8 cipso_len;\n \t\tu8 cipso_off;\n \t\tunsigned char *cipso_ptr;\n \t\tint iter;\n \t\tint optlen_new;\n \n\t\tcipso_off = opt->cipso - sizeof(struct iphdr);\n\t\tcipso_ptr = &opt->__data[cipso_off];\n \t\tcipso_len = cipso_ptr[1];\n \n\t\tif (opt->srr > opt->cipso)\n\t\t\topt->srr -= cipso_len;\n\t\tif (opt->rr > opt->cipso)\n\t\t\topt->rr -= cipso_len;\n\t\tif (opt->ts > opt->cipso)\n\t\t\topt->ts -= cipso_len;\n\t\tif (opt->router_alert > opt->cipso)\n\t\t\topt->router_alert -= cipso_len;\n\t\topt->cipso = 0;\n \n \t\tmemmove(cipso_ptr, cipso_ptr + cipso_len,\n\t\t\topt->optlen - cipso_off - cipso_len);\n \n \t\t/* determining the new total option length is tricky because of\n \t\t * the padding necessary, the only thing i can think to do at\n\t\t * this point is walk the options one-by-one, skipping the\n\t\t * padding at the end to determine the actual option size and\n \t\t * from there we can determine the new total option length */\n \t\titer = 0;\n \t\toptlen_new = 0;\n\t\twhile (iter < opt->optlen)\n\t\t\tif (opt->__data[iter] != IPOPT_NOP) {\n\t\t\t\titer += opt->__data[iter + 1];\n \t\t\t\toptlen_new = iter;\n \t\t\t} else\n \t\t\t\titer++;\n\t\thdr_delta = opt->optlen;\n\t\topt->optlen = (optlen_new + 3) & ~3;\n\t\thdr_delta -= opt->optlen;\n \t} else {\n \t\t/* only the cipso option was present on the socket so we can\n \t\t * remove the entire option struct */\n \t\t*opt_ptr = NULL;\n\t\thdr_delta = opt->optlen;\n\t\tkfree(opt);\n \t}\n \n \treturn hdr_delta;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in IP implementation\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel versions before 3.0\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-362\n[Mandatory] Summary:\nA race condition in the IP implementation within the Linux kernel allows remote attackers to cause a denial of service due to slab corruption and system crashes. This is triggered when packets are sent to an application that modifies socket options during network traffic handling, leading to unsafe modifications of shared kernel structures as shown in the key code excerpt.\n[Mandatory] Root cause:\nThe root cause is the lack of proper synchronization when manipulating shared kernel data structures.\n[Mandatory] Attack Surface:\nNetwork service\n[Mandatory] Impact Summary:\nDoS through slab corruption\n\n[Optional] Trigger / Attack vector:\nSending packets that manipulate socket options\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nif (opt->srr || opt->rr || opt->ts || opt->router_alert) {\n    // Code that modifies shared memory\n    ...\n    memmove(cipso_ptr, cipso_ptr + cipso_len,\n            opt->optlen - cipso_off - cipso_len);\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nSocket options manipulation\n\n[Mandatory] Exploit primitive(s) available:\nRace condition leading to unsafe memory access\n\n[Mandatory] Exploitability summary (1 sentence):\nExploitation is facilitated by simultaneous packet transmission against a vulnerable application, with no specific mitigations indicated.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create a socket to the vulnerable application.\n- Continuously send packets that set socket options.\n- Exploit the race condition by timing the packet sends to overlap with socket option modifications.\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n\nint main() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    struct sockaddr_in server;\n    server.sin_family = AF_INET;\n    server.sin_port = htons(80);\n    inet_pton(AF_INET, \"192.168.1.1\", &server.sin_addr);\n\n    connect(sock, (struct sockaddr *)&server, sizeof(server));\n\n    // Manipulate socket options\n    int opt_value = 1; // Any implementation to set options\n    setsockopt(sock, IPPROTO_IP, IP_OPTIONS, &opt_value, sizeof(opt_value));\n\n    // Send packets repeatedly to trigger race condition\n    while (1) {\n        send(sock, \"Payload\", 7, 0);\n    }\n    close(sock);\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nstatic int cipso_v4_delopt(struct ip_options_rcu **opt_ptr) {\n    ...\n    call_rcu(&opt->rcu, opt_kfree_rcu);\n}\n```\n\n[Mandatory] Fix summary:\nThe patch adds RCU protection to shared kernel structures, preventing concurrent modifications that could lead to memory corruption.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\n[Optional] Patch Analysis:\nThe fix introduced a new structure, `ip_options_rcu`, for safe manipulation of shared runtime options, avoiding race conditions.\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other uses of ip_options to ensure similar race conditions are mitigated.\n- Analyze code sections that modify network options concurrently.\n- Fuzz test for concurrent access scenarios.\n\n[Optional] Likely variants/impact (one line):\nPotential similar race conditions could exist in other networking code handling socket options.",
        "tests": "NA",
        "solutions": "static int cipso_v4_delopt(struct ip_options **opt_ptr)\nstatic int cipso_v4_delopt(struct ip_options_rcu **opt_ptr)\n {\n \tint hdr_delta = 0;\n\tstruct ip_options_rcu *opt = *opt_ptr;\n \n\tif (opt->opt.srr || opt->opt.rr || opt->opt.ts || opt->opt.router_alert) {\n \t\tu8 cipso_len;\n \t\tu8 cipso_off;\n \t\tunsigned char *cipso_ptr;\n \t\tint iter;\n \t\tint optlen_new;\n \n\t\tcipso_off = opt->opt.cipso - sizeof(struct iphdr);\n\t\tcipso_ptr = &opt->opt.__data[cipso_off];\n \t\tcipso_len = cipso_ptr[1];\n \n\t\tif (opt->opt.srr > opt->opt.cipso)\n\t\t\topt->opt.srr -= cipso_len;\n\t\tif (opt->opt.rr > opt->opt.cipso)\n\t\t\topt->opt.rr -= cipso_len;\n\t\tif (opt->opt.ts > opt->opt.cipso)\n\t\t\topt->opt.ts -= cipso_len;\n\t\tif (opt->opt.router_alert > opt->opt.cipso)\n\t\t\topt->opt.router_alert -= cipso_len;\n\t\topt->opt.cipso = 0;\n \n \t\tmemmove(cipso_ptr, cipso_ptr + cipso_len,\n\t\t\topt->opt.optlen - cipso_off - cipso_len);\n \n \t\t/* determining the new total option length is tricky because of\n \t\t * the padding necessary, the only thing i can think to do at\n\t\t * this point is walk the options one-by-one, skipping the\n\t\t * padding at the end to determine the actual option size and\n \t\t * from there we can determine the new total option length */\n \t\titer = 0;\n \t\toptlen_new = 0;\n\t\twhile (iter < opt->opt.optlen)\n\t\t\tif (opt->opt.__data[iter] != IPOPT_NOP) {\n\t\t\t\titer += opt->opt.__data[iter + 1];\n \t\t\t\toptlen_new = iter;\n \t\t\t} else\n \t\t\t\titer++;\n\t\thdr_delta = opt->opt.optlen;\n\t\topt->opt.optlen = (optlen_new + 3) & ~3;\n\t\thdr_delta -= opt->opt.optlen;\n \t} else {\n \t\t/* only the cipso option was present on the socket so we can\n \t\t * remove the entire option struct */\n \t\t*opt_ptr = NULL;\n\t\thdr_delta = opt->opt.optlen;\n\t\tcall_rcu(&opt->rcu, opt_kfree_rcu);\n \t}\n \n \treturn hdr_delta;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/cipso_ipv4.c": " void cipso_v4_req_delattr(struct request_sock *req)\n {\n\tstruct ip_options *opt;\n \tstruct inet_request_sock *req_inet;\n \n \treq_inet = inet_rsk(req);\n \topt = req_inet->opt;\n\tif (opt == NULL || opt->cipso == 0)\n \t\treturn;\n \n \tcipso_v4_delopt(&req_inet->opt);\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in IP implementation\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-362: Race Condition\n[Mandatory] Summary:\nA race condition exists in the IP implementation of the Linux kernel before version 3.0. This vulnerability could be triggered by remote attackers sending packets to an application that sets socket options during network traffic. The race condition may lead to a denial of service due to slab corruption and system crashes. The flaw is illustrated in the function `cipso_v4_req_delattr`, where an improper check on the options structure can lead to unsafe memory access.\n[Mandatory] Root cause:\nThe lack of proper synchronization when manipulating the `inet->opt` structure.\n[Mandatory] Attack Surface:\nNetwork service\n[Mandatory] Impact Summary:\nDenial of Service (DoS)\n[Optional] Trigger / Attack vector:\nRemote network packets\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nvoid cipso_v4_req_delattr(struct request_sock *req)\n{\n    struct ip_options *opt;\n    struct inet_request_sock *req_inet;\n\n    req_inet = inet_rsk(req);\n    opt = req_inet->opt;\n    if (opt == NULL || opt->cipso == 0)\n        return;\n\n    cipso_v4_delopt(&req_inet->opt);\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nNetwork traffic manipulation\n\n[Mandatory] Exploit primitive(s) available:\nMemory corruption\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit is relatively straightforward for attackers to execute, as it requires sending specially crafted packets to the vulnerable service.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Establish a connection to the target application.\n- Send a series of specially crafted packets to manipulate socket options.\n- Trigger the race condition by overlapping the timing of packet processing.\n- Cause access to an unprotected shared memory resource.\n- Result in system crash or instability.\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n\nvoid trigger_vuln() {\n    // Code to open a socket and send packets that manipulate options\n    // to trigger the race condition in the kernel.\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nvoid cipso_v4_req_delattr(struct request_sock *req)\n{\n    struct ip_options_rcu *opt;\n    struct inet_request_sock *req_inet;\n\n    req_inet = inet_rsk(req);\n    opt = req_inet->opt;\n    if (opt == NULL || opt->opt.cipso == 0)\n        return;\n\n    cipso_v4_delopt(&req_inet->opt);\n}\n```\n\n[Mandatory] Fix summary:\nThe patch adds RCU protection to the manipulation of `inet->opt` to ensure that concurrent modifications do not lead to memory corruption or crashes. \n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\n[Optional] Patch Analysis:\nWhat did the fix do?\n\nField: PatchType (e.g., bounds check added, logic refactor, feature removal) \nRCU protection added to shared structure access. \n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other vulnerable areas where socket options are set.\n- Test for similar race conditions in other network protocols.\n- Perform fuzz testing on network traffic handling components.\n\n[Optional] Likely variants/impact (one line):\nPotential for similar race conditions in other areas of the network stack.",
        "tests": "NA",
        "solutions": " void cipso_v4_req_delattr(struct request_sock *req)\n {\n\tstruct ip_options_rcu *opt;\n \tstruct inet_request_sock *req_inet;\n \n \treq_inet = inet_rsk(req);\n \topt = req_inet->opt;\n\tif (opt == NULL || opt->opt.cipso == 0)\n \t\treturn;\n \n \tcipso_v4_delopt(&req_inet->opt);\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/cipso_ipv4.c": "int cipso_v4_req_setattr(struct request_sock *req,\n\t\t\t const struct cipso_v4_doi *doi_def,\n\t\t\t const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n \tunsigned char *buf = NULL;\n \tu32 buf_len;\n \tu32 opt_len;\n\tstruct ip_options *opt = NULL;\n \tstruct inet_request_sock *req_inet;\n \n \t/* We allocate the maximum CIPSO option size here so we are probably\n\t * being a little wasteful, but it makes our life _much_ easier later\n\t * on and after all we are only talking about 40 bytes. */\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto req_setattr_failure;\n\tbuf_len = ret_val;\n\n\t/* We can't use ip_options_get() directly because it makes a call to\n\t * ip_options_get_alloc() which allocates memory with GFP_KERNEL and\n\t * we won't always have CAP_NET_RAW even though we _always_ want to\n\t * set the IPOPT_CIPSO option. */\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n \t\tret_val = -ENOMEM;\n \t\tgoto req_setattr_failure;\n \t}\n\tmemcpy(opt->__data, buf, buf_len);\n\topt->optlen = opt_len;\n\topt->cipso = sizeof(struct iphdr);\n \tkfree(buf);\n \tbuf = NULL;\n \n \treq_inet = inet_rsk(req);\n \topt = xchg(&req_inet->opt, opt);\n\tkfree(opt);\n \n \treturn 0;\n \nreq_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in IP implementation\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel before 3.0\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-362: Race Condition\n[Mandatory] Summary:\nA race condition exists in the `cipso_v4_req_setattr` function of the Linux kernel's networking subsystem, which can be exploited by sending specially crafted packets. This flaw may lead to denial of service via slab corruption, enabling remote attackers to crash the system when the socket options are being set during network traffic handling.\n[Mandatory] Root cause:\nImproper synchronization when manipulating the `inet->opt` structure allows concurrent modifications without protection.\n[Mandatory] Attack Surface:\nNetworking stack in the Linux kernel\n[Mandatory] Impact Summary:\nDenial of Service (DoS)\n[Optional] Trigger / Attack vector:\nMalicious network packet\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nint cipso_v4_req_setattr(struct request_sock *req,\n\\t\\t\\t const struct cipso_v4_doi *doi_def,\n\\t\\t\\t const struct netlbl_lsm_secattr *secattr)\n{\n\\tunsigned char *buf = NULL;\n\\tstruct ip_options *opt = NULL;\n\\tstruct inet_request_sock *req_inet;\n\n\\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\\tmemcpy(opt->__data, buf, buf_len);\n\\treq_inet = inet_rsk(req);\n\\topt = xchg(&req_inet->opt, opt);\n\\tkfree(opt);\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nNetwork packets\n\n[Mandatory] Exploit primitive(s) available:\nDenial of service via slab corruption\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit is relatively easy as it only requires sending specially crafted network packets to the vulnerable service.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Import necessary libraries for network communication.\n- Create a socket for sending packets.\n- Construct a packet that triggers the race condition.\n- Send the crafted packet to the target system.\n- Monitor the target for a crash or instability.\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n\nint main() {\n    int sock;\n    struct sockaddr_in server;\n\n    sock = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);\n    server.sin_family = AF_INET;\n    server.sin_port = htons(80);\n    server.sin_addr.s_addr = inet_addr(\"192.168.1.1\");\n\n    // Trigger the race condition\n    sendto(sock, \"malicious packet\", strlen(\"malicious packet\"), 0, (struct sockaddr *)&server, sizeof(server));\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nint cipso_v4_req_setattr(struct request_sock *req,\n\\t\\t\\t const struct cipso_v4_doi *doi_def,\n\\t\\t\\t const struct netlbl_lsm_secattr *secattr)\n{\n\\tstruct ip_options_rcu *opt = NULL;\n\n\\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\\tmemcpy(opt->opt.__data, buf, buf_len);\n\\topt->opt.optlen = opt_len;\n\\topt = xchg(&req_inet->opt, opt);\n\\tif (opt)\n\\t\\tcall_rcu(&opt->rcu, opt_kfree_rcu);\n}\n```\n\n[Mandatory] Fix summary:\nThe patch changes the structure used for socket options to include RCU protection, preventing race conditions during concurrent accesses by using appropriate memory management techniques.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\n[Optional] Patch Analysis:\nShort note: The fix implemented RCU protection around the manipulation of the socket options structure to ensure safe concurrent access.\n\nField: PatchType (e.g., bounds check added, logic refactor, feature removal)",
        "tests": "NA",
        "solutions": "int cipso_v4_req_setattr(struct request_sock *req,\n\t\t\t const struct cipso_v4_doi *doi_def,\n\t\t\t const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n \tunsigned char *buf = NULL;\n \tu32 buf_len;\n \tu32 opt_len;\n\tstruct ip_options_rcu *opt = NULL;\n \tstruct inet_request_sock *req_inet;\n \n \t/* We allocate the maximum CIPSO option size here so we are probably\n\t * being a little wasteful, but it makes our life _much_ easier later\n\t * on and after all we are only talking about 40 bytes. */\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto req_setattr_failure;\n\tbuf_len = ret_val;\n\n\t/* We can't use ip_options_get() directly because it makes a call to\n\t * ip_options_get_alloc() which allocates memory with GFP_KERNEL and\n\t * we won't always have CAP_NET_RAW even though we _always_ want to\n\t * set the IPOPT_CIPSO option. */\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n \t\tret_val = -ENOMEM;\n \t\tgoto req_setattr_failure;\n \t}\n\tmemcpy(opt->opt.__data, buf, buf_len);\n\topt->opt.optlen = opt_len;\n\topt->opt.cipso = sizeof(struct iphdr);\n \tkfree(buf);\n \tbuf = NULL;\n \n \treq_inet = inet_rsk(req);\n \topt = xchg(&req_inet->opt, opt);\n\tif (opt)\n\t\tcall_rcu(&opt->rcu, opt_kfree_rcu);\n \n \treturn 0;\n \nreq_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/cipso_ipv4.c": " void cipso_v4_sock_delattr(struct sock *sk)\n {\n \tint hdr_delta;\n\tstruct ip_options *opt;\n \tstruct inet_sock *sk_inet;\n \n \tsk_inet = inet_sk(sk);\n\topt = sk_inet->opt;\n\tif (opt == NULL || opt->cipso == 0)\n \t\treturn;\n \n\thdr_delta = cipso_v4_delopt(&sk_inet->opt);\n \tif (sk_inet->is_icsk && hdr_delta > 0) {\n \t\tstruct inet_connection_sock *sk_conn = inet_csk(sk);\n \t\tsk_conn->icsk_ext_hdr_len -= hdr_delta;\n\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n\t}\n}\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace Condition in Linux Kernel IP Implementation\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel versions before 3.0\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nCWE-362: Race Condition\n[Mandatory] Summary:\nThe Linux kernel's IP implementation has a race condition that allows remote attackers to cause a denial of service through packet transmission to an application that sets socket options while handling network traffic. This flaw occurs in the `cipso_v4_sock_delattr` function, particularly when the `opt` variable is manipulated concurrently leading to slab corruption and potential crashes.\n[Mandatory] Root cause:\nImproper synchronization when accessing the `inet->opt` structure.\n[Mandatory] Attack Surface:\nKernel network stack\n[Mandatory] Impact Summary:\nDenial of Service (DoS)\n[Optional] Trigger / Attack vector:\nSending specially crafted network packets\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nvoid cipso_v4_sock_delattr(struct sock *sk)\n{\n    int hdr_delta;\n    struct ip_options *opt;\n    struct inet_sock *sk_inet;\n\n    sk_inet = inet_sk(sk);\n    opt = sk_inet->opt;\n    if (opt == NULL || opt->cipso == 0)\n        return;\n\n    hdr_delta = cipso_v4_delopt(&sk_inet->opt);\n    if (sk_inet->is_icsk && hdr_delta > 0) {\n        struct inet_connection_sock *sk_conn = inet_csk(sk);\n        sk_conn->icsk_ext_hdr_len -= hdr_delta;\n        sk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n    }\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nNetwork packets\n\n[Mandatory] Exploit primitive(s) available:\nRace condition leading to memory corruption\n\n[Mandatory] Exploitability summary (1 sentence):\nThe exploit is moderately easy to trigger, requiring an attacker to send specific packets while a socket option is being manipulated.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Create a socket for network communication.\n- Set socket options that involve the `inet->opt`.\n- Continuously send crafted packets while invoking the `cipso_v4_sock_delattr` function.\n- Monitor for crashes or slab corruption as a result of the race condition.\n\n[Mandatory] Exploitation Example script payload code:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n\nint main() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    struct sockaddr_in server_addr;\n\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(12345);\n    inet_pton(AF_INET, \"192.168.1.1\", &server_addr.sin_addr);\n\n    // Trigger the race condition\n    while (1) {\n        connect(sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\n        // Option manipulation logic here\n    }\n    close(sock);\n    return 0;\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nvoid cipso_v4_sock_delattr(struct sock *sk)\n{\n    int hdr_delta;\n    struct ip_options_rcu *opt;\n    struct inet_sock *sk_inet;\n\n    sk_inet = inet_sk(sk);\n    opt = rcu_dereference_protected(sk_inet->inet_opt, 1);\n    if (opt == NULL || opt->opt.cipso == 0)\n        return;\n\n    hdr_delta = cipso_v4_delopt(&sk_inet->inet_opt);\n    if (sk_inet->is_icsk && hdr_delta > 0) {\n        struct inet_connection_sock *sk_conn = inet_csk(sk);\n        sk_conn->icsk_ext_hdr_len -= hdr_delta;\n        sk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n    }\n}\n```\n\n[Mandatory] Fix summary:\nThe patch introduces RCU protection for the `inet->opt` structure to prevent race conditions during access. \n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\n[Optional] Patch Analysis:\nThe fix ensures that access to the `inet->opt` is safely handled, preventing concurrent manipulation from corrupting memory.\n\nField: PatchType (e.g., bounds check added, logic refactor, feature removal)\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review all functions interacting with `inet->opt` for race conditions.\n- Enhance tests to stress concurrent accesses to the socket options.\n- Evaluate any similar structures for potential vulnerabilities.\n\n[Optional] Likely variants/impact (one line):\nPotential for similar race condition vulnerabilities in other network stack components.",
        "tests": "NA",
        "solutions": " void cipso_v4_sock_delattr(struct sock *sk)\n {\n \tint hdr_delta;\n\tstruct ip_options_rcu *opt;\n \tstruct inet_sock *sk_inet;\n \n \tsk_inet = inet_sk(sk);\n\topt = rcu_dereference_protected(sk_inet->inet_opt, 1);\n\tif (opt == NULL || opt->opt.cipso == 0)\n \t\treturn;\n \n\thdr_delta = cipso_v4_delopt(&sk_inet->inet_opt);\n \tif (sk_inet->is_icsk && hdr_delta > 0) {\n \t\tstruct inet_connection_sock *sk_conn = inet_csk(sk);\n \t\tsk_conn->icsk_ext_hdr_len -= hdr_delta;\n\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n\t}\n}\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-362",
        "CVE": "CVE-2012-3552",
        "language": "C",
        "synthetic": "0",
        "source": "BigVul",
        "source_link": "https://huggingface.co/datasets/bstee615/bigvul",
        "files": {
            "net/ipv4/cipso_ipv4.c": " int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)\n {\n\tstruct ip_options *opt;\n \n\topt = inet_sk(sk)->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn -ENOMSG;\n\treturn cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),\n\t\t\t\tsecattr);\n }\n"
        },
        "vulnerabilities": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "annotation": "[Mandatory] ID:\nCVE-2012-3552\n\n[Mandatory] Title: CVE-2012-3552 / CWE-362:\nRace condition in network socket options\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2012-10-03 \u2014 Patch release: 2013-10-11\n\n[Optional] Affected products/versions:\nLinux kernel versions before 3.0\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\n[CWE-362: Race Condition]\n\n[Mandatory] Summary:\nA race condition in the IP implementation of the Linux kernel allows remote attackers to cause a denial of service by sending packets to applications that set socket options while network traffic is being handled. This improper synchronization can lead to slab corruption, ultimately crashing the system. The bug is present in the function responsible for socket option retrieval, where the `opt` structure can be manipulated by concurrent threads.\n\n[Mandatory] Root cause:\nImproper synchronization when manipulating `inet->opt` in a multithreaded environment.\n\n[Mandatory] Attack Surface:\nNetwork service\n\n[Mandatory] Impact Summary:\nDoS due to slab corruption\n\n[Optional] Trigger / Attack vector:\nNetwork traffic with malicious packets\n\n[Mandatory] Key code/struct excerpt (minimal):\n```c\nint cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)\n{\n    struct ip_options *opt;\n    \n    opt = inet_sk(sk)->opt;\n    if (opt == NULL || opt->cipso == 0)\n        return -ENOMSG;\n    return cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr), secattr);\n}\n```\n\nExploit:\n[Mandatory] Trigger surface/attack vector:\nNetwork packets\n\n[Mandatory] Exploit primitive(s) available:\nDenial of service (slab corruption)\n\n[Mandatory] Exploitability summary (1 sentence):\nExploitation requires sending specially crafted packets within a targeted network environment.\n\n[Mandatory] Exploit script (summary, 3\u20136 bullets):\n- Craft a network packet targeting a socket where `cipso` options are used\n- Send multiple packets simultaneously to induce a race condition\n- Monitor for system crashes or abnormal behavior indicating memory corruption\n\n[Mandatory] Exploitation Example script payload code:\n```c\n// Example exploitation payload that could cause the DoS\n#include <stdio.h>\n#include <string.h>\n\nvoid send_packets() {\n    // Code that sends crafted packets causing race condition\n    // This would interact with kernel networking directly (highly simplified)\n    // Packets would be crafted to target inet->opt manipulation\n}\n\nint main() {\n    while(1) {\n        send_packets();\n    }\n}\n```\n\nFix\n[Mandatory] Fix code:\n```c\nint cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)\n{\n    struct ip_options_rcu *opt;\n    int res = -ENOMSG;\n    \n    rcu_read_lock();\n    opt = rcu_dereference(inet_sk(sk)->inet_opt);\n    if (opt && opt->opt.cipso)\n        res = cipso_v4_getattr(opt->opt.__data +\n                                opt->opt.cipso -\n                                sizeof(struct iphdr), secattr);\n    rcu_read_unlock();\n    return res;\n}\n```\n\n[Mandatory] Fix summary:\nThe patch adds Read-Copy-Update (RCU) locks to safely access the `inet->opt` structure, preventing race conditions and ensuring proper synchronization during concurrent access.\n\n[Optional] Patch reference:\nhttps://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259\n\n[Optional] Patch Analysis:\nThe fix introduces RCU protection mechanisms around the access to socket option attributes, ensuring that modifications are properly synchronized across threads.\n\nField: PatchType (e.g., bounds check added, logic refactor, feature removal)\nRCU protection added\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2\u20133 bullets):\n- Review other network-related functions for similar concurrency issues\n- Test under high load to identify other potential race conditions\n- Audit usage of `inet->opt` across the codebase\n\n[Optional] Likely variants/impact (one line):\nPotential for similar race conditions in other versioned kernel implementations.",
        "tests": "NA",
        "solutions": " int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)\n {\n\tstruct ip_options_rcu *opt;\n\tint res = -ENOMSG;\n \n\trcu_read_lock();\n\topt = rcu_dereference(inet_sk(sk)->inet_opt);\n\tif (opt && opt->opt.cipso)\n\t\tres = cipso_v4_getattr(opt->opt.__data +\n\t\t\t\t\t\topt->opt.cipso -\n\t\t\t\t\t\tsizeof(struct iphdr),\n\t\t\t\t       secattr);\n\trcu_read_unlock();\n\treturn res;\n }\n",
        "Publish Date": "2012-10-03",
        "Update Date": "2013-10-11",
        "Vulnerability type": "DoS ",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "project": "linux"
    }
]